{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst isStream = require('is-stream');\n\nconst {\n  Worker\n} = (() => {\n  try {\n    return require('worker_threads');\n  } catch (_) {\n    return {};\n  }\n})();\n\nlet worker; // Lazy\n\nlet taskIdCounter = 0;\nconst tasks = new Map();\n\nconst recreateWorkerError = sourceError => {\n  const error = new Error(sourceError.message);\n\n  for (const [key, value] of Object.entries(sourceError)) {\n    if (key !== 'message') {\n      error[key] = value;\n    }\n  }\n\n  return error;\n};\n\nconst createWorker = () => {\n  worker = new Worker(path.join(__dirname, 'thread.js'));\n  worker.on('message', message => {\n    const task = tasks.get(message.id);\n    tasks.delete(message.id);\n\n    if (tasks.size === 0) {\n      worker.unref();\n    }\n\n    if (message.error === undefined) {\n      task.resolve(message.value);\n    } else {\n      task.reject(recreateWorkerError(message.error));\n    }\n  });\n  worker.on('error', error => {\n    // Any error here is effectively an equivalent of segfault, and have no scope, so we just throw it on callback level\n    throw error;\n  });\n};\n\nconst taskWorker = (method, args, transferList) => new Promise((resolve, reject) => {\n  const id = taskIdCounter++;\n  tasks.set(id, {\n    resolve,\n    reject\n  });\n\n  if (worker === undefined) {\n    createWorker();\n  }\n\n  worker.ref();\n  worker.postMessage({\n    id,\n    method,\n    args\n  }, transferList);\n});\n\nconst hasha = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let outputEncoding = options.encoding || 'hex';\n\n  if (outputEncoding === 'buffer') {\n    outputEncoding = undefined;\n  }\n\n  const hash = crypto.createHash(options.algorithm || 'sha512');\n\n  const update = buffer => {\n    const inputEncoding = typeof buffer === 'string' ? 'utf8' : undefined;\n    hash.update(buffer, inputEncoding);\n  };\n\n  if (Array.isArray(input)) {\n    input.forEach(update);\n  } else {\n    update(input);\n  }\n\n  return hash.digest(outputEncoding);\n};\n\nhasha.stream = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let outputEncoding = options.encoding || 'hex';\n\n  if (outputEncoding === 'buffer') {\n    outputEncoding = undefined;\n  }\n\n  const stream = crypto.createHash(options.algorithm || 'sha512');\n  stream.setEncoding(outputEncoding);\n  return stream;\n};\n\nhasha.fromStream = async function (stream) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isStream(stream)) {\n    throw new TypeError('Expected a stream');\n  }\n\n  return new Promise((resolve, reject) => {\n    // TODO: Use `stream.pipeline` and `stream.finished` when targeting Node.js 10\n    stream.on('error', reject).pipe(hasha.stream(options)).on('error', reject).on('finish', function () {\n      resolve(this.read());\n    });\n  });\n};\n\nif (Worker === undefined) {\n  hasha.fromFile = async (filePath, options) => hasha.fromStream(fs.createReadStream(filePath), options);\n\n  hasha.async = async (input, options) => hasha(input, options);\n} else {\n  hasha.fromFile = async function (filePath) {\n    let {\n      algorithm = 'sha512',\n      encoding = 'hex'\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const hash = await taskWorker('hashFile', [algorithm, filePath]);\n\n    if (encoding === 'buffer') {\n      return Buffer.from(hash);\n    }\n\n    return Buffer.from(hash).toString(encoding);\n  };\n\n  hasha.async = async function (input) {\n    let {\n      algorithm = 'sha512',\n      encoding = 'hex'\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (encoding === 'buffer') {\n      encoding = undefined;\n    }\n\n    const hash = await taskWorker('hash', [algorithm, input]);\n\n    if (encoding === undefined) {\n      return Buffer.from(hash);\n    }\n\n    return Buffer.from(hash).toString(encoding);\n  };\n}\n\nhasha.fromFileSync = (filePath, options) => hasha(fs.readFileSync(filePath), options);\n\nmodule.exports = hasha;","map":{"version":3,"sources":["/Users/komalfulwar/Downloads/candy-machine-ui/node_modules/hasha/index.js"],"names":["fs","require","path","crypto","isStream","Worker","_","worker","taskIdCounter","tasks","Map","recreateWorkerError","sourceError","error","Error","message","key","value","Object","entries","createWorker","join","__dirname","on","task","get","id","delete","size","unref","undefined","resolve","reject","taskWorker","method","args","transferList","Promise","set","ref","postMessage","hasha","input","options","outputEncoding","encoding","hash","createHash","algorithm","update","buffer","inputEncoding","Array","isArray","forEach","digest","stream","setEncoding","fromStream","TypeError","pipe","read","fromFile","filePath","createReadStream","async","Buffer","from","toString","fromFileSync","readFileSync","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst isStream = require('is-stream');\n\nconst {Worker} = (() => {\n\ttry {\n\t\treturn require('worker_threads');\n\t} catch (_) {\n\t\treturn {};\n\t}\n})();\n\nlet worker; // Lazy\nlet taskIdCounter = 0;\nconst tasks = new Map();\n\nconst recreateWorkerError = sourceError => {\n\tconst error = new Error(sourceError.message);\n\n\tfor (const [key, value] of Object.entries(sourceError)) {\n\t\tif (key !== 'message') {\n\t\t\terror[key] = value;\n\t\t}\n\t}\n\n\treturn error;\n};\n\nconst createWorker = () => {\n\tworker = new Worker(path.join(__dirname, 'thread.js'));\n\n\tworker.on('message', message => {\n\t\tconst task = tasks.get(message.id);\n\t\ttasks.delete(message.id);\n\n\t\tif (tasks.size === 0) {\n\t\t\tworker.unref();\n\t\t}\n\n\t\tif (message.error === undefined) {\n\t\t\ttask.resolve(message.value);\n\t\t} else {\n\t\t\ttask.reject(recreateWorkerError(message.error));\n\t\t}\n\t});\n\n\tworker.on('error', error => {\n\t\t// Any error here is effectively an equivalent of segfault, and have no scope, so we just throw it on callback level\n\t\tthrow error;\n\t});\n};\n\nconst taskWorker = (method, args, transferList) => new Promise((resolve, reject) => {\n\tconst id = taskIdCounter++;\n\ttasks.set(id, {resolve, reject});\n\n\tif (worker === undefined) {\n\t\tcreateWorker();\n\t}\n\n\tworker.ref();\n\tworker.postMessage({id, method, args}, transferList);\n});\n\nconst hasha = (input, options = {}) => {\n\tlet outputEncoding = options.encoding || 'hex';\n\n\tif (outputEncoding === 'buffer') {\n\t\toutputEncoding = undefined;\n\t}\n\n\tconst hash = crypto.createHash(options.algorithm || 'sha512');\n\n\tconst update = buffer => {\n\t\tconst inputEncoding = typeof buffer === 'string' ? 'utf8' : undefined;\n\t\thash.update(buffer, inputEncoding);\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput.forEach(update);\n\t} else {\n\t\tupdate(input);\n\t}\n\n\treturn hash.digest(outputEncoding);\n};\n\nhasha.stream = (options = {}) => {\n\tlet outputEncoding = options.encoding || 'hex';\n\n\tif (outputEncoding === 'buffer') {\n\t\toutputEncoding = undefined;\n\t}\n\n\tconst stream = crypto.createHash(options.algorithm || 'sha512');\n\tstream.setEncoding(outputEncoding);\n\treturn stream;\n};\n\nhasha.fromStream = async (stream, options = {}) => {\n\tif (!isStream(stream)) {\n\t\tthrow new TypeError('Expected a stream');\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t// TODO: Use `stream.pipeline` and `stream.finished` when targeting Node.js 10\n\t\tstream\n\t\t\t.on('error', reject)\n\t\t\t.pipe(hasha.stream(options))\n\t\t\t.on('error', reject)\n\t\t\t.on('finish', function () {\n\t\t\t\tresolve(this.read());\n\t\t\t});\n\t});\n};\n\nif (Worker === undefined) {\n\thasha.fromFile = async (filePath, options) => hasha.fromStream(fs.createReadStream(filePath), options);\n\thasha.async = async (input, options) => hasha(input, options);\n} else {\n\thasha.fromFile = async (filePath, {algorithm = 'sha512', encoding = 'hex'} = {}) => {\n\t\tconst hash = await taskWorker('hashFile', [algorithm, filePath]);\n\n\t\tif (encoding === 'buffer') {\n\t\t\treturn Buffer.from(hash);\n\t\t}\n\n\t\treturn Buffer.from(hash).toString(encoding);\n\t};\n\n\thasha.async = async (input, {algorithm = 'sha512', encoding = 'hex'} = {}) => {\n\t\tif (encoding === 'buffer') {\n\t\t\tencoding = undefined;\n\t\t}\n\n\t\tconst hash = await taskWorker('hash', [algorithm, input]);\n\n\t\tif (encoding === undefined) {\n\t\t\treturn Buffer.from(hash);\n\t\t}\n\n\t\treturn Buffer.from(hash).toString(encoding);\n\t};\n}\n\nhasha.fromFileSync = (filePath, options) => hasha(fs.readFileSync(filePath), options);\n\nmodule.exports = hasha;\n"]},"metadata":{},"sourceType":"script"}