{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fetch_retry_ts_1 = __importDefault(require(\"fetch-retry-ts\"));\n\nconst types_1 = require(\"../types\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst config_1 = require(\"../config\");\n\nconst version_1 = __importDefault(require(\"./version\"));\n\nconst testRetryMultipler = () => parseFloat(process.env.TEST_RETRY_MULTIPLIER || '') || 1;\n\nconst defaultHeaders = {\n  'X-Civic-Client': `${(0, version_1.default)()}`\n};\n\nclass GatekeeperClient {\n  constructor(gatekeeperClientConfig) {\n    this.baseUrl = gatekeeperClientConfig.baseUrl;\n    this.stage = gatekeeperClientConfig.stage;\n    this.queryParams = gatekeeperClientConfig.queryParams;\n    this.fetchImplementation = gatekeeperClientConfig.fetchImplementation || fetch; // By default retry on every 5xx or other Error (e.g. network failure):\n\n    this.defaultRetryParams = {\n      retries: gatekeeperClientConfig.numRetries || (0, config_1.getDefaultApiNumRetries)(this.stage),\n      retryOn: (attempt, retries, error, response) => attempt < retries && (!!error || !response || response.status >= 500),\n      retryDelay: attempt => 2 ** attempt * 1000 * testRetryMultipler()\n    };\n    this.fetchWithRetry = (0, fetch_retry_ts_1.default)(this.fetchImplementation, this.defaultRetryParams);\n  }\n\n  addQueryParams(url) {\n    if (!this.queryParams) return;\n    Object.entries(this.queryParams).forEach(_ref => {\n      let [key, value] = _ref;\n      url.searchParams.append(key, value);\n    });\n  }\n\n  urlForWallet(walletAddress) {\n    const url = new URL(`${this.baseUrl}/${walletAddress}`);\n    this.addQueryParams(url);\n    return url.toString();\n  }\n\n  async getGatekeeperRecordWithPayload(walletAddress) {\n    return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n      method: 'GET',\n      headers: defaultHeaders\n    }).then(async response => ({\n      state: types_1.GatekeeperRecordState[types_1.GatekeeperRecordState[response.status]],\n      payload: await response.json()\n    }));\n  }\n\n  async getGatekeeperStatus(walletAddress) {\n    return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n      method: 'HEAD',\n      headers: defaultHeaders\n    }).then(_ref2 => {\n      let {\n        status\n      } = _ref2;\n      return status;\n    });\n  }\n\n  async requestGatewayTokenFromGatekeeper(_ref3) {\n    let {\n      wallet,\n      payload,\n      proof,\n      ownerSigns\n    } = _ref3;\n    // produce a signature that proves ownership of a wallet\n    logger_1.default.debug('requestGatewayTokenFromGatekeeper request', Object.assign(Object.assign({}, payload), {\n      proof\n    })); // We only pass the wallet public key as part of the request if\n    // it was not passed as part of the presentation.\n\n    const body = Object.assign(Object.assign({}, payload), {\n      proof,\n      address: wallet.publicKey,\n      ownerSigns\n    });\n    logger_1.default.debug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', body);\n    const url = new URL(this.baseUrl);\n    this.addQueryParams(url);\n    return this.fetchWithRetry(url.toString(), {\n      method: 'POST',\n      headers: Object.assign(Object.assign({}, defaultHeaders), {\n        'Content-Type': 'application/json'\n      }),\n      body: JSON.stringify(body)\n    }).then(async resp => {\n      const {\n        status\n      } = resp;\n      const result = await resp.json();\n      return Object.assign(Object.assign({}, result), {\n        status\n      });\n    });\n  }\n  /**\n   * Tries to refresh a token.\n   * If it fails with a 5xx, handleFetchError will retry a number of times.\n   */\n\n\n  async refreshToken(_ref4) {\n    let {\n      wallet,\n      payload,\n      proof,\n      ownerSigns\n    } = _ref4;\n    logger_1.default.debug('refreshToken...', {\n      payload\n    });\n    logger_1.default.debug('Attempting to refresh the Gateway token');\n    const body = Object.assign(Object.assign({}, payload), {\n      proof,\n      request: 'refresh',\n      ownerSigns\n    });\n    return this.fetchWithRetry(this.urlForWallet(wallet.publicKey), {\n      method: 'PATCH',\n      headers: Object.assign(Object.assign({}, defaultHeaders), {\n        'Content-Type': 'application/json'\n      }),\n      body: JSON.stringify(body)\n    }).then(async resp => {\n      const {\n        status\n      } = resp;\n      const result = await resp.json();\n      return Object.assign(Object.assign({}, result), {\n        status\n      });\n    });\n  }\n\n}\n\nexports.default = GatekeeperClient;","map":{"version":3,"sources":["/Users/komalfulwar/Downloads/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/utils/gatekeeperClient.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","fetch_retry_ts_1","require","types_1","logger_1","config_1","version_1","testRetryMultipler","parseFloat","process","env","TEST_RETRY_MULTIPLIER","defaultHeaders","default","GatekeeperClient","constructor","gatekeeperClientConfig","baseUrl","stage","queryParams","fetchImplementation","fetch","defaultRetryParams","retries","numRetries","getDefaultApiNumRetries","retryOn","attempt","error","response","status","retryDelay","fetchWithRetry","addQueryParams","url","entries","forEach","key","searchParams","append","urlForWallet","walletAddress","URL","toString","getGatekeeperRecordWithPayload","method","headers","then","state","GatekeeperRecordState","payload","json","getGatekeeperStatus","requestGatewayTokenFromGatekeeper","wallet","proof","ownerSigns","debug","assign","body","address","publicKey","JSON","stringify","resp","result","refreshToken","request"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fetch_retry_ts_1 = __importDefault(require(\"fetch-retry-ts\"));\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst config_1 = require(\"../config\");\nconst version_1 = __importDefault(require(\"./version\"));\nconst testRetryMultipler = () => parseFloat(process.env.TEST_RETRY_MULTIPLIER || '') || 1;\nconst defaultHeaders = {\n    'X-Civic-Client': `${(0, version_1.default)()}`,\n};\nclass GatekeeperClient {\n    constructor(gatekeeperClientConfig) {\n        this.baseUrl = gatekeeperClientConfig.baseUrl;\n        this.stage = gatekeeperClientConfig.stage;\n        this.queryParams = gatekeeperClientConfig.queryParams;\n        this.fetchImplementation = gatekeeperClientConfig.fetchImplementation || fetch;\n        // By default retry on every 5xx or other Error (e.g. network failure):\n        this.defaultRetryParams = {\n            retries: gatekeeperClientConfig.numRetries || (0, config_1.getDefaultApiNumRetries)(this.stage),\n            retryOn: (attempt, retries, error, response) => attempt < retries && (!!error || !response || response.status >= 500),\n            retryDelay: (attempt) => 2 ** attempt * 1000 * testRetryMultipler(),\n        };\n        this.fetchWithRetry = (0, fetch_retry_ts_1.default)(this.fetchImplementation, this.defaultRetryParams);\n    }\n    addQueryParams(url) {\n        if (!this.queryParams)\n            return;\n        Object.entries(this.queryParams).forEach(([key, value]) => {\n            url.searchParams.append(key, value);\n        });\n    }\n    urlForWallet(walletAddress) {\n        const url = new URL(`${this.baseUrl}/${walletAddress}`);\n        this.addQueryParams(url);\n        return url.toString();\n    }\n    async getGatekeeperRecordWithPayload(walletAddress) {\n        return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n            method: 'GET',\n            headers: defaultHeaders,\n        }).then(async (response) => ({\n            state: types_1.GatekeeperRecordState[types_1.GatekeeperRecordState[response.status]],\n            payload: await response.json(),\n        }));\n    }\n    async getGatekeeperStatus(walletAddress) {\n        return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n            method: 'HEAD',\n            headers: defaultHeaders,\n        }).then(({ status }) => status);\n    }\n    async requestGatewayTokenFromGatekeeper({ wallet, payload, proof, ownerSigns, }) {\n        // produce a signature that proves ownership of a wallet\n        logger_1.default.debug('requestGatewayTokenFromGatekeeper request', Object.assign(Object.assign({}, payload), { proof }));\n        // We only pass the wallet public key as part of the request if\n        // it was not passed as part of the presentation.\n        const body = Object.assign(Object.assign({}, payload), { proof, address: wallet.publicKey, ownerSigns });\n        logger_1.default.debug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', body);\n        const url = new URL(this.baseUrl);\n        this.addQueryParams(url);\n        return this.fetchWithRetry(url.toString(), {\n            method: 'POST',\n            headers: Object.assign(Object.assign({}, defaultHeaders), { 'Content-Type': 'application/json' }),\n            body: JSON.stringify(body),\n        }).then(async (resp) => {\n            const { status } = resp;\n            const result = (await resp.json());\n            return Object.assign(Object.assign({}, result), { status });\n        });\n    }\n    /**\n     * Tries to refresh a token.\n     * If it fails with a 5xx, handleFetchError will retry a number of times.\n     */\n    async refreshToken({ wallet, payload, proof, ownerSigns, }) {\n        logger_1.default.debug('refreshToken...', { payload });\n        logger_1.default.debug('Attempting to refresh the Gateway token');\n        const body = Object.assign(Object.assign({}, payload), { proof, request: 'refresh', ownerSigns });\n        return this.fetchWithRetry(this.urlForWallet(wallet.publicKey), {\n            method: 'PATCH',\n            headers: Object.assign(Object.assign({}, defaultHeaders), { 'Content-Type': 'application/json' }),\n            body: JSON.stringify(body),\n        }).then(async (resp) => {\n            const { status } = resp;\n            const result = (await resp.json());\n            return Object.assign(Object.assign({}, result), { status });\n        });\n    }\n}\nexports.default = GatekeeperClient;\n"]},"metadata":{},"sourceType":"script"}