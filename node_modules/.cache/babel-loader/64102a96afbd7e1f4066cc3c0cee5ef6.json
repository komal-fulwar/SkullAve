{"ast":null,"code":"import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    let variantSizes = idlAccount.type.variants.map(variant => {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n\n      return variant.fields.map(f => {\n        if (!(typeof f === \"object\" && \"name\" in f)) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        }\n\n        return typeSize(idl, f.type);\n      }).reduce((a, b) => a + b);\n    });\n    return Math.max(...variantSizes) + 1;\n  }\n\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n\n  return idlAccount.type.fields.map(f => typeSize(idl, f.type)).reduce((a, b) => a + b, 0);\n} // Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\n\nfunction typeSize(idl, ty) {\n  var _a, _b;\n\n  switch (ty) {\n    case \"bool\":\n      return 1;\n\n    case \"u8\":\n      return 1;\n\n    case \"i8\":\n      return 1;\n\n    case \"i16\":\n      return 2;\n\n    case \"u16\":\n      return 2;\n\n    case \"u32\":\n      return 4;\n\n    case \"i32\":\n      return 4;\n\n    case \"u64\":\n      return 8;\n\n    case \"i64\":\n      return 8;\n\n    case \"u128\":\n      return 16;\n\n    case \"i128\":\n      return 16;\n\n    case \"bytes\":\n      return 1;\n\n    case \"string\":\n      return 1;\n\n    case \"publicKey\":\n      return 32;\n\n    default:\n      if (\"vec\" in ty) {\n        return 1;\n      }\n\n      if (\"option\" in ty) {\n        return 1 + typeSize(idl, ty.option);\n      }\n\n      if (\"defined\" in ty) {\n        const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter(t => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];\n\n        if (filtered.length !== 1) {\n          throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n        }\n\n        let typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      }\n\n      if (\"array\" in ty) {\n        let arrayTy = ty.array[0];\n        let arraySize = ty.array[1];\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n\n      throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n  }\n} // Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\n\n\nexport function sighash(nameSpace, ixName) {\n  let name = snakeCase(ixName);\n  let preimage = `${nameSpace}:${name}`;\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"mappings":"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","names":["snakeCase","sha256","IdlError","accountSize","idl","idlAccount","type","kind","variantSizes","variants","map","variant","fields","undefined","f","Error","typeSize","reduce","a","b","Math","max","ty","option","filtered","types","_a","filter","t","name","defined","_b","length","JSON","stringify","typeDef","arrayTy","array","arraySize","sighash","nameSpace","ixName","preimage","Buffer","from","digest","slice"],"sourceRoot":"","sources":["../../../src/coder/common.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}