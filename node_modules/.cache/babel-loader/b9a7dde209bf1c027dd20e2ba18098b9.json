{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol':\n      return 'symbol';\n\n    case 'Promise':\n      return 'promise';\n    // Set, Map, WeakSet, WeakMap\n\n    case 'WeakMap':\n      return 'weakmap';\n\n    case 'WeakSet':\n      return 'weakset';\n\n    case 'Map':\n      return 'map';\n\n    case 'Set':\n      return 'set';\n    // 8-bit typed arrays\n\n    case 'Int8Array':\n      return 'int8array';\n\n    case 'Uint8Array':\n      return 'uint8array';\n\n    case 'Uint8ClampedArray':\n      return 'uint8clampedarray';\n    // 16-bit typed arrays\n\n    case 'Int16Array':\n      return 'int16array';\n\n    case 'Uint16Array':\n      return 'uint16array';\n    // 32-bit typed arrays\n\n    case 'Int32Array':\n      return 'int32array';\n\n    case 'Uint32Array':\n      return 'uint32array';\n\n    case 'Float32Array':\n      return 'float32array';\n\n    case 'Float64Array':\n      return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  } // Non-plain objects\n\n\n  type = toString.call(val);\n\n  switch (type) {\n    case '[object Object]':\n      return 'object';\n    // iterators\n\n    case '[object Map Iterator]':\n      return 'mapiterator';\n\n    case '[object Set Iterator]':\n      return 'setiterator';\n\n    case '[object String Iterator]':\n      return 'stringiterator';\n\n    case '[object Array Iterator]':\n      return 'arrayiterator';\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n\n  return false;\n}\n/**\r\n * Superstruct ships by default with an unopinionated set of scalar types that\r\n * express all of the data types that are built-in to JavaScript.\r\n */\n\n\nvar Types = {\n  /**\r\n   * Matches any value other than `undefined`.\r\n   *\r\n   * ```js\r\n   * 'anything'\r\n   * true\r\n   * ```\r\n   */\n  any: function any(value) {\n    return value !== undefined;\n  },\n\n  /**\r\n   * Matches an `arguments` object.\r\n   *\r\n   * ```js\r\n   * arguments\r\n   * ```\r\n   */\n  arguments: function _arguments(value) {\n    return kindOf(value) === 'arguments';\n  },\n\n  /**\r\n   * Matches an `Array`.\r\n   *\r\n   * ```js\r\n   * [1, 2, 3]\r\n   * ```\r\n   */\n  array: function array(value) {\n    return kindOf(value) === 'array';\n  },\n\n  /**\r\n   * Matches a boolean.\r\n   *\r\n   * ```js\r\n   * true\r\n   * false\r\n   * ```\r\n   */\n  boolean: function boolean(value) {\n    return kindOf(value) === 'boolean';\n  },\n\n  /**\r\n   * Matches a Node.js `Buffer`.\r\n   *\r\n   * ```js\r\n   * Buffer.from('string')\r\n   * ```\r\n   */\n  buffer: function buffer(value) {\n    return kindOf(value) === 'buffer';\n  },\n\n  /**\r\n   * Matches a **valid** `Date` object.\r\n   *\r\n   * ```js\r\n   * new Date()\r\n   * ```\r\n   *\r\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\r\n   */\n  date: function date(value) {\n    return kindOf(value) === 'date' && !isNaN(value);\n  },\n\n  /**\r\n   * Matches an error object.\r\n   *\r\n   * ```js\r\n   * new Error()\r\n   * ```\r\n   */\n  error: function error(value) {\n    return kindOf(value) === 'error';\n  },\n\n  /**\r\n   * Matches a `Float32Array` object.\r\n   */\n  float32array: function float32array(value) {\n    return kindOf(value) === 'float32array';\n  },\n\n  /**\r\n   * Matches a `Float64Array` object.\r\n   */\n  float64array: function float64array(value) {\n    return kindOf(value) === 'float64array';\n  },\n\n  /**\r\n   * Matches a function.\r\n   *\r\n   * ```js\r\n   * () => {}\r\n   * function () {}\r\n   * ```\r\n   */\n  function: function _function(value) {\n    return kindOf(value) === 'function';\n  },\n\n  /**\r\n   * Matches a generator function.\r\n   *\r\n   * ```js\r\n   * function* () {}\r\n   * ```\r\n   */\n  generatorfunction: function generatorfunction(value) {\n    return kindOf(value) === 'generatorfunction';\n  },\n\n  /**\r\n   * Matches a `Int16Array` object.\r\n   */\n  int16array: function int16array(value) {\n    return kindOf(value) === 'int16array';\n  },\n\n  /**\r\n   * Matches a `Int32Array` object.\r\n   */\n  int32array: function int32array(value) {\n    return kindOf(value) === 'int32array';\n  },\n\n  /**\r\n   * Matches a `Int8Array` object.\r\n   */\n  int8array: function int8array(value) {\n    return kindOf(value) === 'int8array';\n  },\n\n  /**\r\n   * Matches a `Map` object.\r\n   *\r\n   * ```js\r\n   * new Map()\r\n   * ```\r\n   */\n  map: function map(value) {\n    return kindOf(value) === 'map';\n  },\n\n  /**\r\n   * Matches the `null` literal value.\r\n   *\r\n   * ```js\r\n   * null\r\n   * ```\r\n   */\n  null: function _null(value) {\n    return kindOf(value) === 'null';\n  },\n\n  /**\r\n   * Matches a number.\r\n   *\r\n   * ```js\r\n   * 42\r\n   * ```\r\n   */\n  number: function number(value) {\n    return kindOf(value) === 'number';\n  },\n\n  /**\r\n   * Matches a plain object.\r\n   *\r\n   * ```js\r\n   * { key: 'value' }\r\n   * { something: true }\r\n   * ```\r\n   */\n  object: function object(value) {\n    return kindOf(value) === 'object';\n  },\n\n  /**\r\n   * Matches a `Promise` object.\r\n   *\r\n   * ```js\r\n   * Promise.resolve()\r\n   * ```\r\n   */\n  promise: function promise(value) {\n    return kindOf(value) === 'promise';\n  },\n\n  /**\r\n   * Matches a regular expression object.\r\n   *\r\n   * ```js\r\n   * /a-z/g\r\n   * ```\r\n   */\n  regexp: function regexp(value) {\n    return kindOf(value) === 'regexp';\n  },\n\n  /**\r\n   * Matches a `Set` object.\r\n   *\r\n   * ```js\r\n   * new Set()\r\n   * ```\r\n   */\n  set: function set(value) {\n    return kindOf(value) === 'set';\n  },\n\n  /**\r\n   * Matches a string.\r\n   *\r\n   * ```js\r\n   * 'text'\r\n   * ```\r\n   */\n  string: function string(value) {\n    return kindOf(value) === 'string';\n  },\n\n  /**\r\n   * Matches a `Symbol`.\r\n   *\r\n   * ```js\r\n   * Symbol()\r\n   * ```\r\n   */\n  symbol: function symbol(value) {\n    return kindOf(value) === 'symbol';\n  },\n\n  /**\r\n   * Matches a `Uint16Array` object.\r\n   */\n  uint16array: function uint16array(value) {\n    return kindOf(value) === 'uint16array';\n  },\n\n  /**\r\n   * Matches a `Uint32Array` object.\r\n   */\n  uint32array: function uint32array(value) {\n    return kindOf(value) === 'uint32array';\n  },\n\n  /**\r\n   * Matches a `Uint8Array` object.\r\n   */\n  uint8array: function uint8array(value) {\n    return kindOf(value) === 'uint8array';\n  },\n\n  /**\r\n   * Matches a `Uint8ClampedArray` object.\r\n   */\n  uint8clampedarray: function uint8clampedarray(value) {\n    return kindOf(value) === 'uint8clampedarray';\n  },\n\n  /**\r\n   * Matches the `undefined` literal value.\r\n   *\r\n   * ```js\r\n   * undefined\r\n   * ```\r\n   */\n  undefined: function undefined$1(value) {\n    return kindOf(value) === 'undefined';\n  },\n\n  /**\r\n   * Matches a `WeakMap` object.\r\n   *\r\n   * ```js\r\n   * new WeakMap()\r\n   * ```\r\n   */\n  weakmap: function weakmap(value) {\n    return kindOf(value) === 'weakmap';\n  },\n\n  /**\r\n   * Matches a `WeakSet` object.\r\n   *\r\n   * ```js\r\n   * new WeakSet()\r\n   * ```\r\n   */\n  weakset: function weakset(value) {\n    return kindOf(value) === 'weakset';\n  }\n};\nvar isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\n\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n/**\r\n * `StructError` objects are thrown (or returned) by Superstruct when its\r\n * validation fails. The error represents the first error encountered during\r\n * validation. But they also have an `error.failures` property that holds\r\n * information for all of the failures encountered.\r\n */\n\n\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inheritsLoose(StructError, _TypeError);\n\n  function StructError(failures) {\n    var _this;\n\n    invariant(failures.length > 0, \"StructError requires being passed a failure, but received: \" + failures);\n    var first = failures[0];\n\n    var path = first.path,\n        value = first.value,\n        type = first.type,\n        branch = first.branch,\n        rest = _objectWithoutPropertiesLoose(first, [\"path\", \"value\", \"type\", \"branch\"]);\n\n    var message = \"Expected a value of type `\" + type + \"`\" + (path.length ? \" for `\" + path.join('.') + \"`\" : '') + \" but received `\" + JSON.stringify(value) + \"`.\";\n    _this = _TypeError.call(this, message) || this;\n    _this.type = type;\n    _this.value = value;\n    Object.assign(_assertThisInitialized(_this), rest);\n    _this.path = path;\n    _this.branch = branch;\n    _this.failures = failures;\n    _this.stack = new Error().stack;\n    _this.__proto__ = StructError.prototype;\n    return _this;\n  }\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n/**\r\n * A symbol to set on `Struct` objects to test them against later.\r\n */\n\n\nvar STRUCT = Symbol('STRUCT');\n/**\r\n * Check if a value is a `Struct` object.\r\n */\n\nvar isStruct = function isStruct(value) {\n  return typeof value === 'function' && value[STRUCT];\n};\n/**\r\n * This abstract `Struct` factory creates a generic struct that validates values\r\n * against a `Validator` function.\r\n */\n\n\nvar createStruct = function createStruct(props) {\n  var struct = props.struct;\n  var Error = struct.Error;\n\n  var Struct = function Struct(value) {\n    return Struct.assert(value);\n  }; // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n\n\n  Object.defineProperty(Struct, STRUCT, {\n    value: true\n  });\n  Struct.kind = props.kind;\n  Struct.type = props.type;\n\n  Struct.default = function () {\n    return typeof props.defaults === 'function' ? props.defaults() : props.defaults;\n  };\n\n  Struct.test = function (value) {\n    var _Struct$check = Struct.check(value, [value], []),\n        failures = _Struct$check[0];\n\n    return !failures;\n  };\n\n  Struct.assert = function (value) {\n    var _Struct$check2 = Struct.check(value, [value], []),\n        failures = _Struct$check2[0],\n        result = _Struct$check2[1];\n\n    if (failures) {\n      throw new Error(failures);\n    } else {\n      return result;\n    }\n  };\n\n  Struct.validate = function (value) {\n    var _Struct$check3 = Struct.check(value, [value], []),\n        failures = _Struct$check3[0],\n        result = _Struct$check3[1];\n\n    if (failures) {\n      return [new Error(failures)];\n    } else {\n      return [undefined, result];\n    }\n  };\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var failures = [Struct.fail({\n      value: value,\n      branch: branch,\n      path: path\n    })];\n    return [failures];\n  };\n\n  Struct.fail = function (obj) {\n    return _objectSpread2(_objectSpread2({}, obj), {}, {\n      type: 'type' in obj ? obj.type : Struct.type\n    });\n  };\n\n  return Struct;\n};\n\nvar createArray = function createArray(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 1, \"Array structs must be defined as an array with one element, but you passed: \" + schema);\n  var Element = struct(schema[0], undefined);\n  var Struct = createStruct({\n    kind: 'array',\n    type: Element.type + \"[]\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = [];\n    var failures = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n\n      var _Element$check = Element.check(v, branch.concat(v), path.concat(i)),\n          efs = _Element$check[0],\n          er = _Element$check[1];\n\n      if (efs) {\n        failures.push.apply(failures, efs);\n        continue;\n      }\n\n      result[i] = er;\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createDynamic = function createDynamic(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Dynamic structs must be defined as a function, but you passed: \" + schema);\n  var Dynamic = createStruct({\n    kind: 'dynamic',\n    type: \"dynamic<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Dynamic.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Dynamic.default();\n    }\n\n    var Struct = schema(value, branch, path);\n    return Struct.check(value, branch, path);\n  };\n\n  return Dynamic;\n};\n\nvar createEnum = function createEnum(schema, defaults, struct) {\n  invariant(Array.isArray(schema), \"Enum structs must be defined as an array, but you passed: \" + schema);\n\n  var validator = function validator(value) {\n    return schema.includes(value);\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'enum';\n  Struct.type = schema.map(function (s) {\n    return typeof s === 'string' ? \"\\\"\" + s + \"\\\"\" : \"\" + s;\n  }).join(' | ');\n  return Struct;\n};\n\nvar createFunction = function createFunction(schema, defaults, struct) {\n  var Struct = createStruct({\n    kind: 'function',\n    type: \"function<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var result = schema(value, branch, path);\n\n    if (result === true) {\n      return [undefined, value];\n    }\n\n    var failures = [];\n\n    if (result === false) {\n      failures.push(Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      }));\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (var _iterator = _createForOfIteratorHelperLoose(result), _step; !(_step = _iterator()).done;) {\n        var r = _step.value;\n        failures.push(Struct.fail(_objectSpread2({\n          value: value,\n          branch: branch,\n          path: path\n        }, r)));\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail(_objectSpread2({\n        value: value,\n        branch: branch,\n        path: path\n      }, result)));\n    } else {\n      invariant(false, \"Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: \" + result);\n    }\n\n    return [failures];\n  };\n\n  return Struct;\n};\n\nvar createInstance = function createInstance(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Instance structs must be defined as a function, but you passed: \" + schema);\n\n  var validator = function validator(value) {\n    return value instanceof schema;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'instance';\n  Struct.type = \"instance<\" + schema.name + \">\";\n  return Struct;\n};\n\nvar createInterface = function createInterface(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Interface structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'interface',\n    type: \"interface<{\" + Object.keys(schema).join() + \"}>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var failures = [];\n\n    for (var k in Props) {\n      var Prop = Props[k];\n      var v = value[k];\n\n      var _Prop$check = Prop.check(v, branch.concat(v), path.concat(k)),\n          pfs = _Prop$check[0];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value];\n  };\n\n  return Struct;\n};\n\nvar createIntersection = function createIntersection(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length !== 0, \"Intersection structs must be defined as a non-empty array, but you passed: \" + schema);\n  var Structs = schema.map(function (sch) {\n    return struct(sch);\n  });\n  var type = Structs.map(function (s) {\n    return s.type;\n  }).join(' & ');\n  var Struct = createStruct({\n    kind: 'intersection',\n    type: type,\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var result = value;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(Structs), _step; !(_step = _iterator()).done;) {\n      var _struct = _step.value;\n\n      var _struct$check = _struct.check(value, branch, path),\n          fs = _struct$check[0],\n          v = _struct$check[1];\n\n      if (fs) {\n        return [[Struct.fail({\n          value: value,\n          branch: branch,\n          path: path\n        })]];\n      } else {\n        result = v;\n      }\n    }\n\n    return [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createLazy = function createLazy(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Lazy structs must be defined as a function, but you passed: \" + schema);\n  var Lazy = createStruct({\n    kind: 'lazy',\n    type: \"lazy<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Lazy.check = function () {\n    Object.assign(Lazy, schema());\n    return Lazy.check.apply(Lazy, arguments);\n  };\n\n  return Lazy;\n};\n\nvar createSize = function createSize(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 2 && schema.every(function (n) {\n    return typeof n === 'number';\n  }), \"Size structs must be defined as an array with two number elements, but you passed: \" + schema);\n  var min = schema[0],\n      max = schema[1];\n\n  var validator = function validator(value) {\n    return value != null && typeof value.length === 'number' && value.length >= min && value.length <= max;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'size';\n  Struct.type = \"size<\" + min + \",\" + max + \">\";\n  return Struct;\n};\n\nvar createLiteral = function createLiteral(schema, defaults, struct) {\n  var validator = function validator(value) {\n    return value === schema;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'literal';\n  Struct.type = typeof schema === 'string' ? \"\\\"\" + schema + \"\\\"\" : \"\" + schema;\n  return Struct;\n};\n\nvar createObject = function createObject(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Object structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'object',\n    type: \"{\" + Object.keys(schema).join() + \"}\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n    var keys = new Set(Object.keys(Props).concat(Object.keys(value)));\n\n    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n      var k = _step.value;\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      if (!(k in Props)) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: value\n        }));\n        continue;\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createPartial = function createPartial(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Partial structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined']);\n  }\n\n  var Struct = createStruct({\n    kind: 'object',\n    type: \"{\" + Object.keys(schema).join() + \"}\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(value), _step; !(_step = _iterator()).done;) {\n      var k = _step.value;\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      if (!(k in Props)) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: value\n        }));\n        continue;\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createPick = function createPick(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Pick structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'pick',\n    type: \"pick<{\" + Object.keys(schema).join() + \"}>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var k in Props) {\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createRecord = function createRecord(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 2, \"Record structs must be defined as an array with two elements, but you passed: \" + schema);\n  var Key = struct(schema[0]);\n  var Value = struct(schema[1]);\n  var Struct = createStruct({\n    kind: 'record',\n    type: \"record<\" + Key.type + \",\" + Value.type + \">\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    var defs = Struct.default();\n    value = defs ? _objectSpread2(_objectSpread2({}, defs), value) : value;\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var k in value) {\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n\n      var _Key$check = Key.check(k, b, p),\n          kfs = _Key$check[0],\n          kr = _Key$check[1];\n\n      if (kfs) {\n        failures.push.apply(failures, kfs);\n      } else {\n        var _Value$check = Value.check(v, b, p),\n            vfs = _Value$check[0],\n            vr = _Value$check[1];\n\n        if (vfs) {\n          failures.push.apply(failures, vfs);\n        } else {\n          result[kr] = vr;\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createScalar = function createScalar(schema, defaults, struct) {\n  invariant(typeof schema === 'string', \"Scalar structs must be defined as a string, but you passed: \" + schema);\n  var Types = struct.Types;\n  invariant(schema in Types, \"No struct validator function found for type \\\"\" + schema + \"\\\".\");\n  var Struct = struct(Types[schema], defaults);\n  Struct.kind = 'scalar';\n  Struct.type = schema;\n  return Struct;\n};\n\nvar createShorthand = function createShorthand(schema, defaults, struct) {\n  if (isStruct(schema)) {\n    return schema;\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      var _schema = schema,\n          first = _schema[0];\n      return struct.array([first], defaults);\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults);\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults);\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults);\n  }\n\n  if (typeof schema === 'string') {\n    var optional = false;\n    var Struct;\n\n    if (schema.endsWith('?')) {\n      optional = true;\n      schema = schema.slice(0, -1);\n    }\n\n    if (schema.includes('|')) {\n      var scalars = schema.split(/\\s*\\|\\s*/g);\n      Struct = struct.union(scalars, defaults);\n    } else if (schema.includes('&')) {\n      var _scalars = schema.split(/\\s*&\\s*/g);\n\n      Struct = struct.intersection(_scalars, defaults);\n    } else {\n      Struct = struct.scalar(schema, defaults);\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined);\n    }\n\n    return Struct;\n  }\n\n  throw new Error(\"A schema definition must be an object, array, string or function, but you passed: \" + schema);\n};\n\nvar createTuple = function createTuple(schema, defaults, struct) {\n  invariant(Array.isArray(schema), \"Tuple structs must be defined as an array, but you passed: \" + schema);\n  var Elements = schema.map(function (s) {\n    return struct(s);\n  });\n  var Struct = createStruct({\n    kind: 'tuple',\n    type: \"[\" + Elements.map(function (S) {\n      return S.type;\n    }).join() + \"]\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = [];\n    var failures = [];\n    var length = Math.max(value.length, Elements.length);\n\n    for (var i = 0; i < length; i++) {\n      var Element = Elements[i];\n      var v = value[i];\n      var p = path.concat(i);\n      var b = branch.concat(v);\n\n      if (!Element) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: b\n        }));\n      } else {\n        var _Element$check = Element.check(v, b, p),\n            efs = _Element$check[0],\n            er = _Element$check[1];\n\n        if (efs) {\n          failures.push.apply(failures, efs);\n        } else {\n          result[i] = er;\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createUnion = function createUnion(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length !== 0, \"Union structs must be defined as a non-empty array, but you passed: \" + schema);\n  var Structs = schema.map(function (sch) {\n    return struct(sch);\n  });\n  var type = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  var Struct = createStruct({\n    kind: 'union',\n    type: type,\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(Structs), _step; !(_step = _iterator()).done;) {\n      var _struct = _step.value;\n\n      var _struct$check = _struct.check(value, branch, path),\n          fs = _struct$check[0],\n          v = _struct$check[1];\n\n      if (!fs) {\n        return [undefined, v];\n      }\n    }\n\n    return [[Struct.fail({\n      value: value,\n      branch: branch,\n      path: path\n    })]];\n  };\n\n  return Struct;\n};\n/**\r\n * Create a struct singleton with settings that include your own domain-specific\r\n * data `types`, and an optional custom `Error` class.\r\n */\n\n\nvar superstruct = function superstruct(settings) {\n  if (settings === void 0) {\n    settings = {};\n  }\n\n  var struct = function struct(schema, defaults) {\n    return createShorthand(schema, defaults, struct);\n  };\n\n  struct.array = function (schema, defaults) {\n    return createArray(schema, defaults, struct);\n  };\n\n  struct.dynamic = function (schema, defaults) {\n    return createDynamic(schema, defaults, struct);\n  };\n\n  struct.enum = function (schema, defaults) {\n    return createEnum(schema, defaults, struct);\n  };\n\n  struct.function = function (schema, defaults) {\n    return createFunction(schema, defaults, struct);\n  };\n\n  struct.instance = function (schema, defaults) {\n    return createInstance(schema, defaults, struct);\n  };\n\n  struct.interface = function (schema, defaults) {\n    return createInterface(schema, defaults, struct);\n  };\n\n  struct.intersection = function (schema, defaults) {\n    return createIntersection(schema, defaults, struct);\n  };\n\n  struct.lazy = function (schema, defaults) {\n    return createLazy(schema, defaults, struct);\n  };\n\n  struct.literal = function (schema, defaults) {\n    return createLiteral(schema, defaults, struct);\n  };\n\n  struct.object = function (schema, defaults) {\n    return createObject(schema, defaults, struct);\n  };\n\n  struct.optional = function (schema, defaults) {\n    return createUnion([schema, 'undefined'], defaults, struct);\n  };\n\n  struct.partial = function (schema, defaults) {\n    return createPartial(schema, defaults, struct);\n  };\n\n  struct.pick = function (schema, defaults) {\n    return createPick(schema, defaults, struct);\n  };\n\n  struct.record = function (schema, defaults) {\n    return createRecord(schema, defaults, struct);\n  };\n\n  struct.scalar = function (schema, defaults) {\n    return createScalar(schema, defaults, struct);\n  };\n\n  struct.size = function (schema, defaults) {\n    return createSize(schema, defaults, struct);\n  };\n\n  struct.tuple = function (schema, defaults) {\n    return createTuple(schema, defaults, struct);\n  };\n\n  struct.union = function (schema, defaults) {\n    return createUnion(schema, defaults, struct);\n  };\n\n  struct.Error = settings.error || StructError;\n  struct.Types = _objectSpread2(_objectSpread2({}, Types), settings.types);\n  return struct;\n};\n/**\r\n * The singleton instance of Superstruct that is exported by default, configured\r\n * with types for all of the JavaScript built-in data types.\r\n *\r\n * You can use it if you don't need any custom types. However, if you do want to\r\n * define custom types, use the [[superstruct]] factory to configure your own\r\n * [[Superstruct]] instance.\r\n */\n\n\nvar struct = superstruct();\nexport { StructError, Types, isStruct, struct, superstruct };","map":{"version":3,"mappings":"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","names":["toString","Object","prototype","kindOf","val","type","isGeneratorFn","isArray","isBuffer","isArguments","isDate","isError","isRegexp","ctorName","isGeneratorObj","call","slice","toLowerCase","replace","constructor","name","Array","Error","message","stackTraceLimit","Date","toDateString","getDate","setDate","RegExp","flags","ignoreCase","multiline","global","throw","return","next","length","callee","err","indexOf","Types","any","value","undefined","arguments","array","boolean","buffer","date","isNaN","error","float32array","float64array","function","generatorfunction","int16array","int32array","int8array","map","null","number","object","promise","regexp","set","string","symbol","uint16array","uint32array","uint8array","uint8clampedarray","weakmap","weakset","isProduction","process","env","NODE_ENV","prefix","invariant","condition","StructError","_inheritsLoose","failures","first","path","branch","rest","join","JSON","stringify","_this","assign","stack","__proto__","TypeError","STRUCT","Symbol","isStruct","createStruct","props","struct","Struct","assert","defineProperty","kind","default","defaults","test","check","result","validate","fail","obj","createArray","schema","Element","i","v","concat","efs","er","push","createDynamic","Dynamic","createEnum","validator","includes","s","createFunction","r","createInstance","createInterface","Props","key","keys","k","Prop","pfs","createIntersection","Structs","sch","fs","createLazy","Lazy","createSize","every","n","min","max","createLiteral","createObject","d","Set","p","b","pr","createPartial","union","createPick","createRecord","Key","Value","defs","kfs","kr","vfs","vr","createScalar","createShorthand","tuple","optional","endsWith","scalars","split","intersection","scalar","createTuple","Elements","S","Math","createUnion","superstruct","settings","dynamic","enum","instance","interface","lazy","literal","partial","pick","record","size","BuiltinTypes","types"],"sources":["../node_modules/kind-of/index.js","../src/types.ts","../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/struct-error.ts","../src/struct.ts","../src/structs/array.ts","../src/structs/dynamic.ts","../src/structs/enum.ts","../src/structs/function.ts","../src/structs/instance.ts","../src/structs/interface.ts","../src/structs/intersection.ts","../src/structs/lazy.ts","../src/structs/size.ts","../src/structs/literal.ts","../src/structs/object.ts","../src/structs/partial.ts","../src/structs/pick.ts","../src/structs/record.ts","../src/structs/scalar.ts","../src/structs/shorthand.ts","../src/structs/tuple.ts","../src/structs/union.ts","../src/superstruct.ts","../src/index.ts"],"sourcesContent":["var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","import kindOf from 'kind-of'\nimport { Branch, Path, Failure } from './struct-error'\n\n/**\n * Superstruct ships by default with an unopinionated set of scalar types that\n * express all of the data types that are built-in to JavaScript.\n */\n\nexport const Types = {\n  /**\n   * Matches any value other than `undefined`.\n   *\n   * ```js\n   * 'anything'\n   * true\n   * ```\n   */\n\n  any: (value: any) => value !== undefined,\n\n  /**\n   * Matches an `arguments` object.\n   *\n   * ```js\n   * arguments\n   * ```\n   */\n\n  arguments: (value: any) => kindOf(value) === 'arguments',\n\n  /**\n   * Matches an `Array`.\n   *\n   * ```js\n   * [1, 2, 3]\n   * ```\n   */\n\n  array: (value: any) => kindOf(value) === 'array',\n\n  /**\n   * Matches a boolean.\n   *\n   * ```js\n   * true\n   * false\n   * ```\n   */\n\n  boolean: (value: any) => kindOf(value) === 'boolean',\n\n  /**\n   * Matches a Node.js `Buffer`.\n   *\n   * ```js\n   * Buffer.from('string')\n   * ```\n   */\n\n  buffer: (value: any) => kindOf(value) === 'buffer',\n\n  /**\n   * Matches a **valid** `Date` object.\n   *\n   * ```js\n   * new Date()\n   * ```\n   *\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\n   */\n\n  date: (value: any) => kindOf(value) === 'date' && !isNaN(value),\n\n  /**\n   * Matches an error object.\n   *\n   * ```js\n   * new Error()\n   * ```\n   */\n\n  error: (value: any) => kindOf(value) === 'error',\n\n  /**\n   * Matches a `Float32Array` object.\n   */\n\n  float32array: (value: any) => kindOf(value) === 'float32array',\n\n  /**\n   * Matches a `Float64Array` object.\n   */\n\n  float64array: (value: any) => kindOf(value) === 'float64array',\n\n  /**\n   * Matches a function.\n   *\n   * ```js\n   * () => {}\n   * function () {}\n   * ```\n   */\n\n  function: (value: any) => kindOf(value) === 'function',\n\n  /**\n   * Matches a generator function.\n   *\n   * ```js\n   * function* () {}\n   * ```\n   */\n\n  generatorfunction: (value: any) => kindOf(value) === 'generatorfunction',\n\n  /**\n   * Matches a `Int16Array` object.\n   */\n\n  int16array: (value: any) => kindOf(value) === 'int16array',\n\n  /**\n   * Matches a `Int32Array` object.\n   */\n\n  int32array: (value: any) => kindOf(value) === 'int32array',\n\n  /**\n   * Matches a `Int8Array` object.\n   */\n\n  int8array: (value: any) => kindOf(value) === 'int8array',\n\n  /**\n   * Matches a `Map` object.\n   *\n   * ```js\n   * new Map()\n   * ```\n   */\n\n  map: (value: any) => kindOf(value) === 'map',\n\n  /**\n   * Matches the `null` literal value.\n   *\n   * ```js\n   * null\n   * ```\n   */\n\n  null: (value: any) => kindOf(value) === 'null',\n\n  /**\n   * Matches a number.\n   *\n   * ```js\n   * 42\n   * ```\n   */\n\n  number: (value: any) => kindOf(value) === 'number',\n\n  /**\n   * Matches a plain object.\n   *\n   * ```js\n   * { key: 'value' }\n   * { something: true }\n   * ```\n   */\n\n  object: (value: any) => kindOf(value) === 'object',\n\n  /**\n   * Matches a `Promise` object.\n   *\n   * ```js\n   * Promise.resolve()\n   * ```\n   */\n\n  promise: (value: any) => kindOf(value) === 'promise',\n\n  /**\n   * Matches a regular expression object.\n   *\n   * ```js\n   * /a-z/g\n   * ```\n   */\n\n  regexp: (value: any) => kindOf(value) === 'regexp',\n\n  /**\n   * Matches a `Set` object.\n   *\n   * ```js\n   * new Set()\n   * ```\n   */\n\n  set: (value: any) => kindOf(value) === 'set',\n\n  /**\n   * Matches a string.\n   *\n   * ```js\n   * 'text'\n   * ```\n   */\n\n  string: (value: any) => kindOf(value) === 'string',\n\n  /**\n   * Matches a `Symbol`.\n   *\n   * ```js\n   * Symbol()\n   * ```\n   */\n\n  symbol: (value: any) => kindOf(value) === 'symbol',\n\n  /**\n   * Matches a `Uint16Array` object.\n   */\n\n  uint16array: (value: any) => kindOf(value) === 'uint16array',\n\n  /**\n   * Matches a `Uint32Array` object.\n   */\n\n  uint32array: (value: any) => kindOf(value) === 'uint32array',\n\n  /**\n   * Matches a `Uint8Array` object.\n   */\n\n  uint8array: (value: any) => kindOf(value) === 'uint8array',\n\n  /**\n   * Matches a `Uint8ClampedArray` object.\n   */\n\n  uint8clampedarray: (value: any) => kindOf(value) === 'uint8clampedarray',\n\n  /**\n   * Matches the `undefined` literal value.\n   *\n   * ```js\n   * undefined\n   * ```\n   */\n\n  undefined: (value: any) => kindOf(value) === 'undefined',\n\n  /**\n   * Matches a `WeakMap` object.\n   *\n   * ```js\n   * new WeakMap()\n   * ```\n   */\n\n  weakmap: (value: any) => kindOf(value) === 'weakmap',\n\n  /**\n   * Matches a `WeakSet` object.\n   *\n   * ```js\n   * new WeakSet()\n   * ```\n   */\n\n  weakset: (value: any) => kindOf(value) === 'weakset',\n}\n\n/**\n * `Validator` functions allow developers to define their own scalar types for\n * Superstruct to validate against, and return an indication of what is invalid.\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *   }\n * })\n * ```\n */\n\nexport type Validator = (\n  value: any,\n  branch: Branch,\n  path: Path\n) => Partial<Failure>[] | Partial<Failure> | boolean\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","import invariant from 'tiny-invariant'\n\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nexport class StructError extends TypeError {\n  branch: Branch\n  failures: Failure[]\n  path: Path\n  type: string | undefined\n  value: any\n  [key: string]: any\n\n  constructor(failures: Failure[]) {\n    invariant(\n      failures.length > 0,\n      `StructError requires being passed a failure, but received: ${failures}`\n    )\n\n    const [first] = failures\n    const { path, value, type, branch, ...rest } = first\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n\n    super(message)\n    this.type = type\n    this.value = value\n    Object.assign(this, rest)\n    this.path = path\n    this.branch = branch\n    this.failures = failures\n    this.stack = new Error().stack\n    ;(this as any).__proto__ = StructError.prototype\n  }\n}\n\n/**\n * `Path` arrays specify a nested value's location in a root object or array.\n *\n * ```js\n * ['user', 'address', 'city']\n * ['nodes', 1, 'nodes', 0, 'text']\n * ```\n */\n\nexport type Path = Array<number | string>\n\n/**\n * `Branch` arrays contain each value following a path down from the root.\n *\n * ```js\n * [root, ..., parent, value]\n * ```\n */\n\nexport type Branch = Array<any>\n\n/**\n * `Failure` objects represent a specific failure in validation. They are plain\n * objects that can be turned into real `StructError` when needed.\n *\n * ```js\n * {\n *   type: 'number',\n *   value: 'invalid',\n *   path: [1],\n *   branch: [\n *     [1, 'invalid', 2],\n *     'invalid',\n *   ]\n * }\n */\n\nexport type Failure = {\n  /**\n   * The branch of values following a path down from the root.\n   */\n\n  branch: Branch\n\n  /**\n   * The path of indices to retrieve the failing value from the root.\n   */\n\n  path: Path\n\n  /**\n   * The failing value.\n   */\n\n  value: any\n\n  /**\n   * The expected type description of the failing value, or `undefined` if it\n   * didn't have an expected type.\n   */\n\n  type: string | undefined\n\n  /**\n   * Failures can also be augmented with any of your on custom properties.\n   */\n\n  [key: string]: any\n}\n","import { Failure, Branch, Path } from './struct-error'\nimport { Superstruct } from './superstruct'\n\n/**\n * A symbol to set on `Struct` objects to test them against later.\n */\n\nexport const STRUCT = Symbol('STRUCT')\n\n/**\n * Check if a value is a `Struct` object.\n */\n\nexport const isStruct = (value: any): value is Struct => {\n  return typeof value === 'function' && value[STRUCT]\n}\n\n/**\n * This abstract `Struct` factory creates a generic struct that validates values\n * against a `Validator` function.\n */\n\nexport const createStruct = (props: {\n  kind: string\n  type: string\n  defaults: () => any\n  struct: Superstruct\n}): Struct => {\n  const { struct } = props\n  const { Error } = struct\n  const Struct = (value: any): any => Struct.assert(value)\n\n  // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n  Object.defineProperty(Struct, STRUCT, { value: true })\n\n  Struct.kind = props.kind\n  Struct.type = props.type\n\n  Struct.default = () => {\n    return typeof props.defaults === 'function'\n      ? props.defaults()\n      : props.defaults\n  }\n\n  Struct.test = (value: any): boolean => {\n    const [failures] = Struct.check(value, [value], [])\n    return !failures\n  }\n\n  Struct.assert = (value: any): any => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      throw new Error(failures)\n    } else {\n      return result\n    }\n  }\n\n  Struct.validate = (value: any): [Error?, any?] => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      return [new Error(failures)]\n    } else {\n      return [undefined, result]\n    }\n  }\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const failures = [Struct.fail({ value, branch, path })]\n    return [failures]\n  }\n\n  Struct.fail = (obj: {\n    value: any\n    branch: Branch\n    path: Path\n    type?: string\n  }): Failure => {\n    return { ...obj, type: 'type' in obj ? obj.type : Struct.type }\n  }\n\n  return Struct\n}\n\n/**\n * `Struct` validators encapsulate the validation logic for a specific type of\n * data (either custom or built-in). They have a set of methods that allow you\n * to validate input in various ways, while producing detailed errors.\n *\n * They are created by the [[Superstruct]] factory functions. You can call them\n * directly for the simple case, or use one of their validation methods.\n *\n * ```js\n * const Struct = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n *\n * const result = Struct(data) // Throws if invalid!\n *\n * const [error, result] = Struct.validate(data)\n *\n * if (Struct.test(data)) {\n *    // ...\n * }\n * ```\n */\n\nexport interface Struct {\n  /**\n   * All structs are functions that are shorthand for calling [[Struct.assert]].\n   */\n\n  (value: any): any\n\n  /**\n   * The struct's name.\n   *\n   * ```js\n   * 'object'\n   * 'union'\n   * 'email'\n   * ```\n   */\n\n  kind: string\n\n  /**\n   * A string representing the type of the struct. These strings are purely for\n   * user-facing error messages, and aren't canonical. They are similar to the\n   * syntax that TypeScript uses.\n   *\n   * ```js\n   * '{id,name,email}'\n   * 'string | number'\n   * 'email'\n   * ```\n   */\n\n  type: string\n\n  /**\n   * Get the default value for a struct.\n   *\n   * ```js\n   * const defaults = Struct.default()\n   * ```\n   */\n\n  default(): any\n\n  /**\n   * Run the low-level validation function a struct, returning a tuple that\n   * contains either a list of [[Failure]] objects, or a resulting value.\n   *\n   * This method is fairly low-level and not for normal use.\n   *\n   * ```js\n   * const [failures, result] = Struct.check(value, branch, path)\n   * ```\n   */\n\n  check(value: any, branch: Branch, path: Path): [Failure[]?, any?]\n\n  /**\n   * Validate a `value`, returning the resulting value, and throwing an error if\n   * validation fails.\n   *\n   * ```js\n   * try {\n   *   const result = Struct.assert(value)\n   *   // ...\n   * } catch (e) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  assert(value: any): any\n\n  /**\n   * Validate a `value`, returning a boolean indicating whether it's valid.\n   *\n   * Note: Using this method does not give you access to the defaults that may\n   * be associated with a struct, so it doesn't guarantee that the value you\n   * have passes, just that the value with defaults passes.\n   *\n   * ```js\n   * if (Struct.test(value)) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  test(value: any): boolean\n\n  /**\n   * Validate a `value` returning a tuple containing an error if the validation\n   * fails, or the resulting value if it succeeds.\n   *\n   * ```js\n   * const [error, result] = Struct.validate(value)\n   * ```\n   */\n\n  validate(value: any): [Error?, any?]\n\n  /**\n   * Create a low-level [[Failure]] object for the struct.\n   *\n   * ```js\n   * const failure = Struct.fail({ value, branch, path })\n   * ```\n   */\n\n  fail(obj: { value: any; branch: Branch; path: Path; type?: string }): Failure\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createArray = (\n  schema: [any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 1,\n    `Array structs must be defined as an array with one element, but you passed: ${schema}`\n  )\n\n  const Element = struct(schema[0], undefined)\n  const Struct = createStruct({\n    kind: 'array',\n    type: `${Element.type}[]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [efs, er] = Element.check(v, branch.concat(v), path.concat(i))\n\n      if (efs) {\n        failures.push(...efs)\n        continue\n      }\n\n      result[i] = er\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createDynamic = (\n  schema: (value: any, branch: Branch, path: Path) => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Dynamic structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Dynamic = createStruct({\n    kind: 'dynamic',\n    type: `dynamic<>`,\n    defaults,\n    struct,\n  })\n\n  Dynamic.check = (\n    value: any = Dynamic.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const Struct = schema(value, branch, path)\n    return Struct.check(value, branch, path)\n  }\n\n  return Dynamic\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createEnum = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Enum structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => schema.includes(value)\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'enum'\n  Struct.type = schema\n    .map(s => (typeof s === 'string' ? `\"${s}\"` : `${s}`))\n    .join(' | ')\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct, Validator } from '..'\nimport { createStruct } from '../struct'\n\nexport const createFunction = (\n  schema: Validator,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const Struct = createStruct({\n    kind: 'function',\n    type: `function<>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const result = schema(value, branch, path)\n\n    if (result === true) {\n      return [undefined, value]\n    }\n\n    const failures: Failure[] = []\n\n    if (result === false) {\n      failures.push(Struct.fail({ value, branch, path }))\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (const r of result) {\n        failures.push(Struct.fail({ value, branch, path, ...r }))\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail({ value, branch, path, ...result }))\n    } else {\n      invariant(\n        false,\n        `Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: ${result}`\n      )\n    }\n\n    return [failures]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createInstance = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Instance structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => value instanceof schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'instance'\n  Struct.type = `instance<${schema.name}>`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createInterface = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Interface structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'interface',\n    type: `interface<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      const Prop = Props[k]\n      const v = value[k]\n      const [pfs] = Prop.check(v, branch.concat(v), path.concat(k))\n\n      if (pfs) {\n        failures.push(...pfs)\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createIntersection = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Intersection structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' & ')\n  const Struct = createStruct({\n    kind: 'intersection',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    let result: any = value\n\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (fs) {\n        return [[Struct.fail({ value, branch, path })]]\n      } else {\n        result = v\n      }\n    }\n\n    return [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Failure, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createLazy = (\n  schema: () => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Lazy structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Lazy = createStruct({\n    kind: 'lazy',\n    type: `lazy<>`,\n    defaults,\n    struct,\n  })\n\n  Lazy.check = (...args): [Failure[]?, any?] => {\n    Object.assign(Lazy, schema())\n    return Lazy.check(...args)\n  }\n\n  return Lazy\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createSize = (\n  schema: [number, number],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) &&\n      schema.length === 2 &&\n      schema.every(n => typeof n === 'number'),\n    `Size structs must be defined as an array with two number elements, but you passed: ${schema}`\n  )\n\n  const [min, max] = schema\n  const validator = (value: any) =>\n    value != null &&\n    typeof value.length === 'number' &&\n    value.length >= min &&\n    value.length <= max\n\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'size'\n  Struct.type = `size<${min},${max}>`\n  return Struct\n}\n","import { Struct, Superstruct } from '..'\n\nexport const createLiteral = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const validator = (value: any) => value === schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'literal'\n  Struct.type = typeof schema === 'string' ? `\"${schema}\"` : `${schema}`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createObject = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Object structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n    const keys = new Set(Object.keys(Props).concat(Object.keys(value)))\n\n    for (const k of keys) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPartial = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Partial structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined'])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k of value) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPick = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Pick structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'pick',\n    type: `pick<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createRecord = (\n  schema: [any, any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 2,\n    `Record structs must be defined as an array with two elements, but you passed: ${schema}`\n  )\n\n  const Key = struct(schema[0])\n  const Value = struct(schema[1])\n  const Struct = createStruct({\n    kind: 'record',\n    type: `record<${Key.type},${Value.type}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any,\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    const defs = Struct.default()\n    value = defs ? { ...defs, ...value } : value\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (let k in value) {\n      const v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const [kfs, kr] = Key.check(k, b, p)\n\n      if (kfs) {\n        failures.push(...kfs)\n      } else {\n        const [vfs, vr] = Value.check(v, b, p)\n\n        if (vfs) {\n          failures.push(...vfs)\n        } else {\n          result[kr] = vr\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createScalar = (\n  schema: string,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'string',\n    `Scalar structs must be defined as a string, but you passed: ${schema}`\n  )\n\n  const { Types } = struct\n\n  invariant(\n    schema in Types,\n    `No struct validator function found for type \"${schema}\".`\n  )\n\n  const Struct = struct(Types[schema], defaults)\n  Struct.kind = 'scalar'\n  Struct.type = schema\n  return Struct\n}\n","import { isStruct, Struct, Superstruct } from '..'\n\nexport const createShorthand = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  if (isStruct(schema)) {\n    return schema\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      const [first] = schema\n      return struct.array([first], defaults)\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults)\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults)\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults)\n  }\n\n  if (typeof schema === 'string') {\n    let optional = false\n    let Struct\n\n    if (schema.endsWith('?')) {\n      optional = true\n      schema = schema.slice(0, -1)\n    }\n\n    if (schema.includes('|')) {\n      const scalars = schema.split(/\\s*\\|\\s*/g)\n      Struct = struct.union(scalars, defaults)\n    } else if (schema.includes('&')) {\n      const scalars = schema.split(/\\s*&\\s*/g)\n      Struct = struct.intersection(scalars, defaults)\n    } else {\n      Struct = struct.scalar(schema, defaults)\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined)\n    }\n\n    return Struct\n  }\n\n  throw new Error(\n    `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n  )\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createTuple = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Tuple structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const Elements = schema.map(s => struct(s))\n  const Struct = createStruct({\n    kind: 'tuple',\n    type: `[${Elements.map(S => S.type).join()}]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n    const length = Math.max(value.length, Elements.length)\n\n    for (let i = 0; i < length; i++) {\n      const Element = Elements[i]\n      const v = value[i]\n      const p = path.concat(i)\n      const b = branch.concat(v)\n\n      if (!Element) {\n        failures.push(\n          Struct.fail({ type: undefined, value: v, path: p, branch: b })\n        )\n      } else {\n        const [efs, er] = Element.check(v, b, p)\n\n        if (efs) {\n          failures.push(...efs)\n        } else {\n          result[i] = er\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { createStruct } from '../struct'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\n\nexport const createUnion = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Union structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' | ')\n  const Struct = createStruct({\n    kind: 'union',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (!fs) {\n        return [undefined, v]\n      }\n    }\n\n    return [[Struct.fail({ value, branch, path })]]\n  }\n\n  return Struct\n}\n","import { Validator, Types as BuiltinTypes } from './types'\nimport { Branch, Failure, Path, StructError } from './struct-error'\nimport { Struct } from './struct'\nimport {\n  createArray,\n  createDynamic,\n  createEnum,\n  createFunction,\n  createInstance,\n  createInterface,\n  createIntersection,\n  createLazy,\n  createLiteral,\n  createObject,\n  createPartial,\n  createPick,\n  createRecord,\n  createScalar,\n  createShorthand,\n  createSize,\n  createTuple,\n  createUnion,\n} from './structs'\n\n/**\n * `SuperstructSettings` are passed in when creating a `Superstruct` factory.\n */\n\nexport type SuperstructSettings = {\n  types: Record<string, Validator>\n  error: { new (failures: Failure[]): Error }\n}\n\n/**\n * Create a struct singleton with settings that include your own domain-specific\n * data `types`, and an optional custom `Error` class.\n */\n\nexport const superstruct = (\n  settings: Partial<SuperstructSettings> = {}\n): Superstruct => {\n  const struct = (schema: any, defaults?: any): Struct => {\n    return createShorthand(schema, defaults, struct)\n  }\n\n  struct.array = (schema: [any], defaults?: any): Struct => {\n    return createArray(schema, defaults, struct)\n  }\n\n  struct.dynamic = (\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct => {\n    return createDynamic(schema, defaults, struct)\n  }\n\n  struct.enum = (schema: any[], defaults?: any): Struct => {\n    return createEnum(schema, defaults, struct)\n  }\n\n  struct.function = (schema: Validator, defaults?: any): Struct => {\n    return createFunction(schema, defaults, struct)\n  }\n\n  struct.instance = (schema: any, defaults?: any): Struct => {\n    return createInstance(schema, defaults, struct)\n  }\n\n  struct.interface = (schema: any, defaults?: any): Struct => {\n    return createInterface(schema, defaults, struct)\n  }\n\n  struct.intersection = (schema: any[], defaults?: any): Struct => {\n    return createIntersection(schema, defaults, struct)\n  }\n\n  struct.lazy = (schema: () => Struct, defaults?: any): Struct => {\n    return createLazy(schema, defaults, struct)\n  }\n\n  struct.literal = (schema: any, defaults?: any): Struct => {\n    return createLiteral(schema, defaults, struct)\n  }\n\n  struct.object = (schema: {}, defaults?: any): Struct => {\n    return createObject(schema, defaults, struct)\n  }\n\n  struct.optional = (schema: any, defaults?: any): Struct => {\n    return createUnion([schema, 'undefined'], defaults, struct)\n  }\n\n  struct.partial = (schema: {}, defaults?: any): Struct => {\n    return createPartial(schema, defaults, struct)\n  }\n\n  struct.pick = (schema: {}, defaults?: any): Struct => {\n    return createPick(schema, defaults, struct)\n  }\n\n  struct.record = (schema: [any, any], defaults?: any): Struct => {\n    return createRecord(schema, defaults, struct)\n  }\n\n  struct.scalar = (schema: string, defaults?: any): Struct => {\n    return createScalar(schema, defaults, struct)\n  }\n\n  struct.size = (schema: [number, number], defaults?: any): Struct => {\n    return createSize(schema, defaults, struct)\n  }\n\n  struct.tuple = (schema: any[], defaults?: any): Struct => {\n    return createTuple(schema, defaults, struct)\n  }\n\n  struct.union = (schema: any[], defaults?: any): Struct => {\n    return createUnion(schema, defaults, struct)\n  }\n\n  struct.Error = settings.error || StructError\n  struct.Types = { ...BuiltinTypes, ...settings.types }\n  return struct\n}\n\n/**\n * `Superstruct` factories create different kinds of [[Struct]] validators, and\n * encapsulate the user-defined data types.\n *\n * The [[struct]] export is a factory that ships with Superstruct by default,\n * pre-configured with all of the built-in JavaScript data types. It's the\n * easiest way to quickly define structs:\n *\n * ```js\n * import { struct } from 'superstruct'\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n * ```\n *\n * If you need to define custom data types, you can define your own by using\n * the [[superstruct]] export:\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n * import isUrl from 'is-url'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *     url: value => isUrl(value) && value.length < 2048,\n *   }\n * })\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n *   email: 'email',\n *   website: 'url?',\n * })\n * ```\n *\n * This way you can easily define structs that contain types like `'email'`,\n * `'url'`, or whatever else your application may need.\n */\n\nexport interface Superstruct {\n  /**\n   * Structs are defined by passing a schema definition to the struct factory.\n   * The schema definition can be a string, array, object or function. They can\n   * also be composed by nesting structs inside each other.\n   *\n   * The default struct factory allows you to write structs using a shorthand\n   * syntax for the most common casesarrays, objects, scalars, tuples, etc.\n   *\n   * ```js\n   * struct('string') // Scalars\n   * struct(['number']) // Arrays\n   * struct({ name: 'string' }) // Objects\n   * struct(['error', 'string']) // Tuples\n   * struct('number?') // Optional\n   * struct('string & email') // Intersection\n   * struct('number | string') // Union\n   * struct(value => true || false) // Function\n   * struct(Struct) // Pass-through\n   * ```\n   *\n   * Each shorthand is equivalent to a method on the [[Superstruct]] factory:\n   *\n   * ```js\n   * // These are equivalent...\n   * struct(['number'])\n   * struct.array(['number'])\n   *\n   * struct('string & email')\n   * struct.union(['string', 'email'])\n   * ```\n   *\n   * And each one can use your custom types, or even other structs:\n   *\n   * ```js\n   * struct('email')\n   * struct(User)\n   * ```\n   *\n   * The second argument to struct factories is always a `defaults` value. It\n   * can either be the default itself or a function that returns the default.\n   *\n   * ```js\n   * struct('id', uuid.v4)\n   *\n   * struct({\n   *   id: 'number',\n   *   name: 'string',\n   *   is_admin: 'boolean?',\n   * }, {\n   *   is_admin: false,\n   * })\n   * ```\n   */\n\n  (schema: any, defaults?: any): Struct\n\n  /**\n   * Array structs validate that their input is an array with elements that\n   * match a specific struct. You can also pass the `max` or `min` options to\n   * validate the length of the array.\n   *\n   * ```js\n   * const Struct = struct.array(['number'])\n   *\n   * Struct([1, 2, 3])\n   * ```\n   *\n   * They are similar to the `Array` type in TypeScript.\n   */\n\n  array(schema: [any], defaults?: any): Struct\n\n  /**\n   * Dynamic structs are defined by a function that is passed the value being\n   * validated, and they determine which struct to use at runtime.\n   *\n   * ```js\n   * const Struct = struct.dynamic(value => StructA || StructB)\n   * ```\n   *\n   * They are inhernetly less performant that compile-time structs, but they\n   * unlock a set of possibilities that aren't possible at compile time alone.\n   */\n\n  dynamic(\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct\n\n  /**\n   * Enum structs validate that their input is one of a set of values.\n   *\n   * ```js\n   * const Struct = struct.enum(['fruit', 'vegetable', 'meat'])\n   *\n   * Struct('fruit')\n   * ```\n   *\n   * They are similar to the `enum` type in TypeScript.\n   */\n\n  enum(schema: any[], defaults?: any): Struct\n\n  /**\n   * Function structs validate their input against a one-off validator function.\n   *\n   * ```js\n   * const Struct = struct.function(value => typeof value === 'string')\n   *\n   * Struct('a simple string')\n   * ```\n   *\n   * They can't provide as detailed of errors as other struct types, but they do\n   * allow for customization for easy one-off cases.\n   */\n\n  function(schema: Validator, defaults?: any): Struct\n\n  /**\n   * Instance structs validate that their input is an instance of a class.\n   *\n   * ```js\n   * const Struct = struct.instance(MyClass)\n   *\n   * Struct(new MyClass())\n   * ```\n   */\n\n  instance(schema: any, defaults?: any): Struct\n\n  /**\n   * Interface structs validate that their input matches an interface defined as\n   * a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.interface({\n   *   length: 'number',\n   *   indexOf: 'function',\n   * })\n   *\n   * Struct([1, 2, 3])\n   * Struct('abc')\n   * ```\n   *\n   * They are similar to the structural-typing granted by TypeScript.\n   */\n\n  interface(schema: any, defaults?: any): Struct\n\n  /**\n   * Intersection structs validate that their input matches **all** of a set of\n   * different structs.\n   *\n   * ```js\n   * const Struct = struct.intersection('string & email')\n   *\n   * Struct('jane@example.com')\n   * ```\n   *\n   * Note: The structs will be validated in order, so validators on the right\n   * can rely on the validators before them having passed.\n   *\n   * They are similar to the `&` operator in TypeScript.\n   */\n\n  intersection(schema: any[], defaults?: any): Struct\n\n  /**\n   * Lazy structs allow you to initialize a struct lazily, only initializing it\n   * once on the first time it attempts to be validated.\n   *\n   * ```js\n   * const Struct = struct({\n   *   nodes: struct.lazy(() => Struct)\n   * })\n   *\n   * Struct({\n   *   nodes: {\n   *     nodes: { ... }\n   *   }\n   * })\n   * ```\n   *\n   * They are helpful for defining recursive structs.\n   */\n\n  lazy(schema: () => Struct, defaults?: any): Struct\n\n  /**\n   * Literal structs validate their input against a literal value.\n   *\n   * ```js\n   * const Struct = struct.literal(42)\n   *\n   * Struct(42)\n   * ```\n   */\n\n  literal(schema: any, defaults?: any): Struct\n\n  /**\n   * Object structs validate that their input exactly matches an object defined\n   * as a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.object({\n   *   id: 'number',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `?` qualifier in TypeScript.\n   */\n\n  object(schema: {}, defaults?: any): Struct\n\n  /**\n   * Optional structs validate that their input passes a specific struct, or\n   * `undefined`.\n   *\n   * ```js\n   * const Struct = struct.optional('string?')\n   *\n   * Struct('a string of text')\n   * Struct(undefined)\n   * ```\n   *\n   * This is a shorthand for using `struct.union` with `undefined`.\n   */\n\n  optional(schema: any, defaults?: any): Struct\n\n  /**\n   * Partial structs validate that their input partially matches an object\n   * defined as a set of properties with associated types. All of the properties\n   * of the object are optional.\n   *\n   * ```js\n   * const Struct = struct.partial({\n   *   id: 'number'\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `Partial` utility in TypeScript.\n   */\n\n  partial(schema: {}, defaults?: any): Struct\n\n  /**\n   * Pick structs validate that their input exactly matches a subset of an\n   * object defined as a set of properties with associated types. All of the\n   * properties of its schema are required, but the object can have more that it\n   * does not concern itself with.\n   *\n   * ```js\n   * const Struct = struct.pick({\n   *   id: 'string',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'James Smith',\n   *   email: 'james@example.com',\n   * })\n   * ```\n   *\n   * They are similar to the `Pick` utility in TypeScript.\n   */\n\n  pick(schema: {}, defaults?: any): Struct\n\n  /**\n   * Record structs validate that their input is an object with keys that match\n   * one struct and values that match another. The object can have zero or many\n   * properties set on it.\n   *\n   * ```js\n   * const Struct = struct.record('string', 'number')\n   *\n   * Struct({\n   *   a: 1,\n   *   b: 2,\n   * })\n   * ```\n   *\n   * They are similar to the `Record` utility in TypeScript.\n   */\n\n  record(schema: [any, any], defaults?: any): Struct\n\n  /**\n   * Scalar structs validate that their input passes the `Validator` function\n   * defined for a specific type by name. By default Superstruct ships with a\n   * set of built-in scalars. But you can configure it with custom scalars that\n   * match your domain.\n   *\n   * ```js\n   * const Struct = struct.scalar('string')\n   *\n   * Struct('a string of text')\n   * ```\n   */\n\n  scalar(schema: string, defaults?: any): Struct\n\n  /**\n   * Size structs validate their input has a certain length, by checking its\n   * `length` property. This works strings or arrays.\n   *\n   * ```js\n   * const Struct = struct.size([0, 7])\n   *\n   * Struct([1, 2, 3])\n   * Struct('abcdefg')\n   * ```\n   *\n   * They are helpful for defining unions with array structs.\n   */\n\n  size(schema: [number, number], defaults?: any): Struct\n\n  /**\n   * Tuple structs validate that their input exactly matches a tuple of values,\n   * in length and in type.\n   *\n   * ```js\n   * const Struct = struct.tuple(['string', 'boolean'])\n   *\n   * Struct(['one', true])\n   * ```\n   */\n\n  tuple(schema: any[], defaults?: any): Struct\n\n  /**\n   * Union structs validate that their input matches **at least one** of a set\n   * of different structs.\n   *\n   * ```js\n   * const Struct = struct.union(['string', 'number'])\n   *\n   * Struct('a string')\n   * Struct(42)\n   * ```\n   *\n   * They are similar to the `|` operator in TypeScript.\n   */\n\n  union(schema: any[], defaults?: any): Struct\n\n  /**\n   * The class for errors thrown by `Structs`, defaults to [[StructError]].\n   */\n\n  Error: { new (failures: Failure[]): Error }\n\n  /**\n   * The set of data types that the factory knows.\n   */\n\n  Types: Record<string, Validator>\n}\n","import { superstruct } from './superstruct'\n\n/**\n * The singleton instance of Superstruct that is exported by default, configured\n * with types for all of the JavaScript built-in data types.\n *\n * You can use it if you don't need any custom types. However, if you do want to\n * define custom types, use the [[superstruct]] factory to configure your own\n * [[Superstruct]] instance.\n */\n\nconst struct = superstruct()\n\nexport { struct, superstruct }\nexport { Superstruct } from './superstruct'\nexport { StructError, Failure, Path, Branch } from './struct-error'\nexport { Types, Validator } from './types'\nexport { isStruct, Struct } from './struct'\n"]},"metadata":{},"sourceType":"module"}