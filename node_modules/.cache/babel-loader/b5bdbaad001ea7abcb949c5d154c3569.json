{"ast":null,"code":"var debug = require('debug')('assert-args');\n\nvar exists = require('101/exists');\n\nvar isObject = require('101/is-object');\n\nvar not = require('101/not');\n\nvar isOptionalKey = require('./lib/is-optional-key.js');\n\nvar isSpreadKey = require('./lib/is-spread-key.js');\n\nvar validate = require('./lib/validate.js');\n\nvar isRequiredKey = not(isOptionalKey);\nmodule.exports = assertArgs;\n\nfunction assertArgs(args, validation) {\n  if (typeof args !== 'object' || !exists(args.length)) {\n    throw new TypeError('\"args\" must be an array or array-like object (arguments)');\n  }\n\n  if (!isObject(validation)) {\n    // strict object\n    throw new TypeError('\"validation\" must be an object');\n  } // copy args\n\n\n  var argsLeft = Array.prototype.slice.call(args);\n  var firstOptionalErr;\n  var ret = {};\n  var argKeys = Object.keys(validation);\n  var outKey;\n\n  if (argKeys.filter(isSpreadKey).length > 1) {\n    throw new Error('assert-args only supports a single spread argument');\n  }\n\n  argKeys.forEach(function (key, i) {\n    var spreadArgs;\n    var validator = validation[key];\n    var arg = argsLeft[0];\n\n    if (isSpreadKey(key)) {\n      debug('is spread key: ' + key);\n      debug('argKeys.length', argKeys.length);\n      debug('argsLeft.length', argsLeft.length);\n      var requiredKeysLeft = argKeys.slice(i + 1).filter(isRequiredKey);\n      debug('requiredKeysLeft', requiredKeysLeft);\n      spreadArgs = argsLeft.slice(0, argsLeft.length - requiredKeysLeft.length); // copy\n\n      debug('spreadArgs', spreadArgs);\n      debug('spreadArgs.length', spreadArgs.length);\n\n      if (isOptionalKey(key)) {\n        debug('is optional spread key: ' + key);\n        outKey = key.slice(4, -1);\n        ret[outKey] = [];\n        spreadArgs.forEach(function (arg) {\n          if (!exists(arg)) {\n            // non-existant args pass as optional args\n            firstOptionalErr = null; // reset after a pass\n\n            argsLeft.shift(); // pass, remains [...]\n\n            return;\n          }\n\n          try {\n            validate(key.slice(1, -1), arg, validator, true); // optional arg passes validator\n\n            firstOptionalErr = null;\n            ret[outKey].push(arg); // pass\n\n            argsLeft.shift();\n          } catch (err) {\n            debug('spread validate err: ' + err.message);\n            debug('spread validate argsLeft: ' + argsLeft);\n\n            if (firstOptionalErr) {\n              // other optional error already occurred, throw first.\n              throw firstOptionalErr;\n            } else {\n              firstOptionalErr = err;\n            }\n          }\n        });\n      } else {\n        // isSpreadKey && isRequiredKey\n        debug('is required spread key: ' + key);\n        outKey = key.slice(3);\n        ret[outKey] = [];\n\n        if (spreadArgs.length === 0) {\n          // missing trailing required arg, fail\n          throw new TypeError('\"' + key + '\" is required');\n        }\n\n        spreadArgs.forEach(function (arg) {\n          try {\n            validate(key, arg, validator, true); // optional arg passes validator\n\n            firstOptionalErr = null;\n            ret[outKey].push(arg); // pass\n\n            argsLeft.shift();\n          } catch (err) {\n            debug('spread validate err: ' + err.message);\n            debug('spread validate argsLeft: ' + argsLeft);\n            debug('spread validate argKeys: ' + argKeys);\n\n            if (i === argKeys.length - 1) {\n              // spread is last arg.\n              // spread assumes all args passed are used.\n              // there are no args left. and this failed for spread. throw it.\n              if (firstOptionalErr) {\n                if (argsLeft.length - 1 > requiredKeysLeft.length) {\n                  throw firstOptionalErr;\n                } else {\n                  throw err;\n                }\n              } else {\n                throw err;\n              }\n            } else {\n              // leading/middle spread arg\n              if (firstOptionalErr) {\n                // other optional error already occurred, throw first.\n                throw firstOptionalErr;\n              } else {\n                // set optional err\n                firstOptionalErr = err;\n              }\n            }\n          }\n        });\n      }\n\n      return;\n    } else if (isOptionalKey(key)) {\n      debug('is optional key: ' + key);\n      key = key.slice(1, -1);\n\n      if (argsLeft.length === 0) {\n        // missing trailing optional arg, pass\n        ret[key] = undefined;\n        return;\n      } else if (!exists(arg)) {\n        // non-existant args pass as optional args\n        firstOptionalErr = null;\n        ret[key] = argsLeft.shift(); // pass\n\n        return;\n      }\n\n      try {\n        validate(key, arg, validator); // optional arg passes validator\n\n        firstOptionalErr = null;\n        ret[key] = argsLeft.shift();\n        return;\n      } catch (err) {\n        // optional arg failed validator\n        // * set as undefined and pass for now\n        // * save the error in case there are no more required args\n        firstOptionalErr = firstOptionalErr || err;\n        ret[key] = undefined;\n        return;\n      }\n    } else {\n      // isRequiredKey\n      debug('is required key: ' + key);\n\n      if (argsLeft.length === 0) {\n        // missing trailing required arg, fail\n        throw new TypeError('\"' + key + '\" is required');\n      }\n\n      try {\n        validate(key, arg, validator); // required arg passes validator, pass\n\n        firstOptionalErr = null;\n        ret[key] = argsLeft.shift();\n      } catch (err) {\n        if (firstOptionalErr && argsLeft.length > 1) {\n          // optional err was thrown before and this is not the last arg\n          throw firstOptionalErr;\n        }\n\n        throw err;\n      }\n\n      return;\n    }\n  });\n\n  if (firstOptionalErr) {\n    throw firstOptionalErr;\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["/Users/komalfulwar/Documents/GitHub/SkullAve/node_modules/assert-args/index.js"],"names":["debug","require","exists","isObject","not","isOptionalKey","isSpreadKey","validate","isRequiredKey","module","exports","assertArgs","args","validation","length","TypeError","argsLeft","Array","prototype","slice","call","firstOptionalErr","ret","argKeys","Object","keys","outKey","filter","Error","forEach","key","i","spreadArgs","validator","arg","requiredKeysLeft","shift","push","err","message","undefined"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,aAAjB,CAAZ;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,YAAD,CAApB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAIG,GAAG,GAAGH,OAAO,CAAC,SAAD,CAAjB;;AAEA,IAAII,aAAa,GAAGJ,OAAO,CAAC,0BAAD,CAA3B;;AACA,IAAIK,WAAW,GAAGL,OAAO,CAAC,wBAAD,CAAzB;;AACA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,mBAAD,CAAtB;;AAEA,IAAIO,aAAa,GAAGJ,GAAG,CAACC,aAAD,CAAvB;AAEAI,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAEA,SAASA,UAAT,CAAqBC,IAArB,EAA2BC,UAA3B,EAAuC;AACrC,MAAI,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,CAACV,MAAM,CAACU,IAAI,CAACE,MAAN,CAAvC,EAAsD;AACpD,UAAM,IAAIC,SAAJ,CAAc,0DAAd,CAAN;AACD;;AACD,MAAI,CAACZ,QAAQ,CAACU,UAAD,CAAb,EAA2B;AAAE;AAC3B,UAAM,IAAIE,SAAJ,CAAc,gCAAd,CAAN;AACD,GANoC,CAQrC;;;AACA,MAAIC,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BR,IAA3B,CAAf;AACA,MAAIS,gBAAJ;AACA,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYZ,UAAZ,CAAd;AACA,MAAIa,MAAJ;;AAEA,MAAIH,OAAO,CAACI,MAAR,CAAerB,WAAf,EAA4BQ,MAA5B,GAAqC,CAAzC,EAA4C;AAC1C,UAAM,IAAIc,KAAJ,CAAU,oDAAV,CAAN;AACD;;AAEDL,EAAAA,OAAO,CAACM,OAAR,CAAgB,UAAUC,GAAV,EAAeC,CAAf,EAAkB;AAChC,QAAIC,UAAJ;AACA,QAAIC,SAAS,GAAGpB,UAAU,CAACiB,GAAD,CAA1B;AACA,QAAII,GAAG,GAAGlB,QAAQ,CAAC,CAAD,CAAlB;;AAEA,QAAIV,WAAW,CAACwB,GAAD,CAAf,EAAsB;AACpB9B,MAAAA,KAAK,CAAC,oBAAoB8B,GAArB,CAAL;AACA9B,MAAAA,KAAK,CAAC,gBAAD,EAAmBuB,OAAO,CAACT,MAA3B,CAAL;AACAd,MAAAA,KAAK,CAAC,iBAAD,EAAoBgB,QAAQ,CAACF,MAA7B,CAAL;AACA,UAAIqB,gBAAgB,GAAGZ,OAAO,CAACJ,KAAR,CAAcY,CAAC,GAAG,CAAlB,EAAqBJ,MAArB,CAA4BnB,aAA5B,CAAvB;AACAR,MAAAA,KAAK,CAAC,kBAAD,EAAqBmC,gBAArB,CAAL;AACAH,MAAAA,UAAU,GAAGhB,QAAQ,CAACG,KAAT,CAAe,CAAf,EAAkBH,QAAQ,CAACF,MAAT,GAAkBqB,gBAAgB,CAACrB,MAArD,CAAb,CANoB,CAMsD;;AAC1Ed,MAAAA,KAAK,CAAC,YAAD,EAAegC,UAAf,CAAL;AACAhC,MAAAA,KAAK,CAAC,mBAAD,EAAsBgC,UAAU,CAAClB,MAAjC,CAAL;;AAEA,UAAIT,aAAa,CAACyB,GAAD,CAAjB,EAAwB;AACtB9B,QAAAA,KAAK,CAAC,6BAA6B8B,GAA9B,CAAL;AACAJ,QAAAA,MAAM,GAAGI,GAAG,CAACX,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd,CAAT;AACAG,QAAAA,GAAG,CAACI,MAAD,CAAH,GAAc,EAAd;AAEAM,QAAAA,UAAU,CAACH,OAAX,CAAmB,UAAUK,GAAV,EAAe;AAChC,cAAI,CAAChC,MAAM,CAACgC,GAAD,CAAX,EAAkB;AAChB;AACAb,YAAAA,gBAAgB,GAAG,IAAnB,CAFgB,CAEQ;;AACxBL,YAAAA,QAAQ,CAACoB,KAAT,GAHgB,CAGC;;AACjB;AACD;;AACD,cAAI;AACF7B,YAAAA,QAAQ,CAACuB,GAAG,CAACX,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd,CAAD,EAAmBe,GAAnB,EAAwBD,SAAxB,EAAmC,IAAnC,CAAR,CADE,CAEF;;AACAZ,YAAAA,gBAAgB,GAAG,IAAnB;AACAC,YAAAA,GAAG,CAACI,MAAD,CAAH,CAAYW,IAAZ,CAAiBH,GAAjB,EAJE,CAIoB;;AACtBlB,YAAAA,QAAQ,CAACoB,KAAT;AACD,WAND,CAME,OAAOE,GAAP,EAAY;AACZtC,YAAAA,KAAK,CAAC,0BAA0BsC,GAAG,CAACC,OAA/B,CAAL;AACAvC,YAAAA,KAAK,CAAC,+BAA+BgB,QAAhC,CAAL;;AACA,gBAAIK,gBAAJ,EAAsB;AACpB;AACA,oBAAMA,gBAAN;AACD,aAHD,MAGO;AACLA,cAAAA,gBAAgB,GAAGiB,GAAnB;AACD;AACF;AACF,SAvBD;AAwBD,OA7BD,MA6BO;AAAE;AACPtC,QAAAA,KAAK,CAAC,6BAA6B8B,GAA9B,CAAL;AACAJ,QAAAA,MAAM,GAAGI,GAAG,CAACX,KAAJ,CAAU,CAAV,CAAT;AACAG,QAAAA,GAAG,CAACI,MAAD,CAAH,GAAc,EAAd;;AAEA,YAAIM,UAAU,CAAClB,MAAX,KAAsB,CAA1B,EAA6B;AAC3B;AACA,gBAAM,IAAIC,SAAJ,CAAc,MAAMe,GAAN,GAAY,eAA1B,CAAN;AACD;;AACDE,QAAAA,UAAU,CAACH,OAAX,CAAmB,UAAUK,GAAV,EAAe;AAChC,cAAI;AACF3B,YAAAA,QAAQ,CAACuB,GAAD,EAAMI,GAAN,EAAWD,SAAX,EAAsB,IAAtB,CAAR,CADE,CAEF;;AACAZ,YAAAA,gBAAgB,GAAG,IAAnB;AACAC,YAAAA,GAAG,CAACI,MAAD,CAAH,CAAYW,IAAZ,CAAiBH,GAAjB,EAJE,CAIoB;;AACtBlB,YAAAA,QAAQ,CAACoB,KAAT;AACD,WAND,CAME,OAAOE,GAAP,EAAY;AACZtC,YAAAA,KAAK,CAAC,0BAA0BsC,GAAG,CAACC,OAA/B,CAAL;AACAvC,YAAAA,KAAK,CAAC,+BAA+BgB,QAAhC,CAAL;AACAhB,YAAAA,KAAK,CAAC,8BAA8BuB,OAA/B,CAAL;;AAEA,gBAAIQ,CAAC,KAAMR,OAAO,CAACT,MAAR,GAAiB,CAA5B,EAAgC;AAC9B;AACA;AACA;AACA,kBAAIO,gBAAJ,EAAsB;AACpB,oBAAKL,QAAQ,CAACF,MAAT,GAAkB,CAAnB,GAAwBqB,gBAAgB,CAACrB,MAA7C,EAAqD;AACnD,wBAAMO,gBAAN;AACD,iBAFD,MAEO;AACL,wBAAMiB,GAAN;AACD;AACF,eAND,MAMO;AACL,sBAAMA,GAAN;AACD;AACF,aAbD,MAaO;AACL;AACA,kBAAIjB,gBAAJ,EAAsB;AACpB;AACA,sBAAMA,gBAAN;AACD,eAHD,MAGO;AACL;AACAA,gBAAAA,gBAAgB,GAAGiB,GAAnB;AACD;AACF;AACF;AACF,SApCD;AAqCD;;AACD;AACD,KAvFD,MAuFO,IAAIjC,aAAa,CAACyB,GAAD,CAAjB,EAAwB;AAC7B9B,MAAAA,KAAK,CAAC,sBAAsB8B,GAAvB,CAAL;AACAA,MAAAA,GAAG,GAAGA,GAAG,CAACX,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd,CAAN;;AAEA,UAAIH,QAAQ,CAACF,MAAT,KAAoB,CAAxB,EAA2B;AACzB;AACAQ,QAAAA,GAAG,CAACQ,GAAD,CAAH,GAAWU,SAAX;AACA;AACD,OAJD,MAIO,IAAI,CAACtC,MAAM,CAACgC,GAAD,CAAX,EAAkB;AACvB;AACAb,QAAAA,gBAAgB,GAAG,IAAnB;AACAC,QAAAA,GAAG,CAACQ,GAAD,CAAH,GAAWd,QAAQ,CAACoB,KAAT,EAAX,CAHuB,CAGK;;AAC5B;AACD;;AAED,UAAI;AACF7B,QAAAA,QAAQ,CAACuB,GAAD,EAAMI,GAAN,EAAWD,SAAX,CAAR,CADE,CAEF;;AACAZ,QAAAA,gBAAgB,GAAG,IAAnB;AACAC,QAAAA,GAAG,CAACQ,GAAD,CAAH,GAAWd,QAAQ,CAACoB,KAAT,EAAX;AACA;AACD,OAND,CAME,OAAOE,GAAP,EAAY;AACZ;AACA;AACA;AACAjB,QAAAA,gBAAgB,GAAGA,gBAAgB,IAAIiB,GAAvC;AACAhB,QAAAA,GAAG,CAACQ,GAAD,CAAH,GAAWU,SAAX;AACA;AACD;AACF,KA7BM,MA6BA;AAAE;AACPxC,MAAAA,KAAK,CAAC,sBAAsB8B,GAAvB,CAAL;;AACA,UAAId,QAAQ,CAACF,MAAT,KAAoB,CAAxB,EAA2B;AACzB;AACA,cAAM,IAAIC,SAAJ,CAAc,MAAMe,GAAN,GAAY,eAA1B,CAAN;AACD;;AACD,UAAI;AACFvB,QAAAA,QAAQ,CAACuB,GAAD,EAAMI,GAAN,EAAWD,SAAX,CAAR,CADE,CAEF;;AACAZ,QAAAA,gBAAgB,GAAG,IAAnB;AACAC,QAAAA,GAAG,CAACQ,GAAD,CAAH,GAAWd,QAAQ,CAACoB,KAAT,EAAX;AACD,OALD,CAKE,OAAOE,GAAP,EAAY;AACZ,YAAIjB,gBAAgB,IAAIL,QAAQ,CAACF,MAAT,GAAkB,CAA1C,EAA6C;AAC3C;AACA,gBAAMO,gBAAN;AACD;;AACD,cAAMiB,GAAN;AACD;;AACD;AACD;AACF,GA7ID;;AA+IA,MAAIjB,gBAAJ,EAAsB;AACpB,UAAMA,gBAAN;AACD;;AAED,SAAOC,GAAP;AACD","sourcesContent":["var debug = require('debug')('assert-args')\nvar exists = require('101/exists')\nvar isObject = require('101/is-object')\nvar not = require('101/not')\n\nvar isOptionalKey = require('./lib/is-optional-key.js')\nvar isSpreadKey = require('./lib/is-spread-key.js')\nvar validate = require('./lib/validate.js')\n\nvar isRequiredKey = not(isOptionalKey)\n\nmodule.exports = assertArgs\n\nfunction assertArgs (args, validation) {\n  if (typeof args !== 'object' || !exists(args.length)) {\n    throw new TypeError('\"args\" must be an array or array-like object (arguments)')\n  }\n  if (!isObject(validation)) { // strict object\n    throw new TypeError('\"validation\" must be an object')\n  }\n\n  // copy args\n  var argsLeft = Array.prototype.slice.call(args)\n  var firstOptionalErr\n  var ret = {}\n  var argKeys = Object.keys(validation)\n  var outKey\n\n  if (argKeys.filter(isSpreadKey).length > 1) {\n    throw new Error('assert-args only supports a single spread argument')\n  }\n\n  argKeys.forEach(function (key, i) {\n    var spreadArgs\n    var validator = validation[key]\n    var arg = argsLeft[0]\n\n    if (isSpreadKey(key)) {\n      debug('is spread key: ' + key)\n      debug('argKeys.length', argKeys.length)\n      debug('argsLeft.length', argsLeft.length)\n      var requiredKeysLeft = argKeys.slice(i + 1).filter(isRequiredKey)\n      debug('requiredKeysLeft', requiredKeysLeft)\n      spreadArgs = argsLeft.slice(0, argsLeft.length - requiredKeysLeft.length) // copy\n      debug('spreadArgs', spreadArgs)\n      debug('spreadArgs.length', spreadArgs.length)\n\n      if (isOptionalKey(key)) {\n        debug('is optional spread key: ' + key)\n        outKey = key.slice(4, -1)\n        ret[outKey] = []\n\n        spreadArgs.forEach(function (arg) {\n          if (!exists(arg)) {\n            // non-existant args pass as optional args\n            firstOptionalErr = null // reset after a pass\n            argsLeft.shift() // pass, remains [...]\n            return\n          }\n          try {\n            validate(key.slice(1, -1), arg, validator, true)\n            // optional arg passes validator\n            firstOptionalErr = null\n            ret[outKey].push(arg) // pass\n            argsLeft.shift()\n          } catch (err) {\n            debug('spread validate err: ' + err.message)\n            debug('spread validate argsLeft: ' + argsLeft)\n            if (firstOptionalErr) {\n              // other optional error already occurred, throw first.\n              throw firstOptionalErr\n            } else {\n              firstOptionalErr = err\n            }\n          }\n        })\n      } else { // isSpreadKey && isRequiredKey\n        debug('is required spread key: ' + key)\n        outKey = key.slice(3)\n        ret[outKey] = []\n\n        if (spreadArgs.length === 0) {\n          // missing trailing required arg, fail\n          throw new TypeError('\"' + key + '\" is required')\n        }\n        spreadArgs.forEach(function (arg) {\n          try {\n            validate(key, arg, validator, true)\n            // optional arg passes validator\n            firstOptionalErr = null\n            ret[outKey].push(arg) // pass\n            argsLeft.shift()\n          } catch (err) {\n            debug('spread validate err: ' + err.message)\n            debug('spread validate argsLeft: ' + argsLeft)\n            debug('spread validate argKeys: ' + argKeys)\n\n            if (i === (argKeys.length - 1)) {\n              // spread is last arg.\n              // spread assumes all args passed are used.\n              // there are no args left. and this failed for spread. throw it.\n              if (firstOptionalErr) {\n                if ((argsLeft.length - 1) > requiredKeysLeft.length) {\n                  throw firstOptionalErr\n                } else {\n                  throw err\n                }\n              } else {\n                throw err\n              }\n            } else {\n              // leading/middle spread arg\n              if (firstOptionalErr) {\n                // other optional error already occurred, throw first.\n                throw firstOptionalErr\n              } else {\n                // set optional err\n                firstOptionalErr = err\n              }\n            }\n          }\n        })\n      }\n      return\n    } else if (isOptionalKey(key)) {\n      debug('is optional key: ' + key)\n      key = key.slice(1, -1)\n\n      if (argsLeft.length === 0) {\n        // missing trailing optional arg, pass\n        ret[key] = undefined\n        return\n      } else if (!exists(arg)) {\n        // non-existant args pass as optional args\n        firstOptionalErr = null\n        ret[key] = argsLeft.shift() // pass\n        return\n      }\n\n      try {\n        validate(key, arg, validator)\n        // optional arg passes validator\n        firstOptionalErr = null\n        ret[key] = argsLeft.shift()\n        return\n      } catch (err) {\n        // optional arg failed validator\n        // * set as undefined and pass for now\n        // * save the error in case there are no more required args\n        firstOptionalErr = firstOptionalErr || err\n        ret[key] = undefined\n        return\n      }\n    } else { // isRequiredKey\n      debug('is required key: ' + key)\n      if (argsLeft.length === 0) {\n        // missing trailing required arg, fail\n        throw new TypeError('\"' + key + '\" is required')\n      }\n      try {\n        validate(key, arg, validator)\n        // required arg passes validator, pass\n        firstOptionalErr = null\n        ret[key] = argsLeft.shift()\n      } catch (err) {\n        if (firstOptionalErr && argsLeft.length > 1) {\n          // optional err was thrown before and this is not the last arg\n          throw firstOptionalErr\n        }\n        throw err\n      }\n      return\n    }\n  })\n\n  if (firstOptionalErr) {\n    throw firstOptionalErr\n  }\n\n  return ret\n}\n"]},"metadata":{},"sourceType":"script"}