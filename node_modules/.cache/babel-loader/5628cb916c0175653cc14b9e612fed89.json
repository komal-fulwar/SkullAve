{"ast":null,"code":"import _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport nacl from 'tweetnacl';\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport hasha from 'hasha';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport { blob, struct, ns64, u32, offset, u8, seq, nu64 } from 'buffer-layout';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport assert from 'assert';\nimport { parse, format } from 'url';\nimport fetch from 'node-fetch';\nimport jayson from 'jayson/lib/client/browser';\nimport { struct as struct$1 } from 'superstruct';\nimport { Client } from 'rpc-websockets';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\n\nvar toBuffer = function toBuffer(arr) {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n/**\n * A public key\n */\n\n\nvar PublicKey = /*#__PURE__*/function () {\n  /**\n   * Create a new PublicKey object\n   */\n  function PublicKey(value) {\n    _classCallCheck(this, PublicKey);\n\n    _defineProperty(this, \"_bn\", void 0);\n\n    if (typeof value === 'string') {\n      // hexadecimal number\n      if (value.startsWith('0x')) {\n        this._bn = new BN(value.substring(2), 16);\n      } else {\n        // assume base 58 encoding by default\n        var decoded = bs58.decode(value);\n\n        if (decoded.length != 32) {\n          throw new Error(\"Invalid public key input\");\n        }\n\n        this._bn = new BN(decoded);\n      }\n    } else {\n      this._bn = new BN(value);\n    }\n\n    if (this._bn.byteLength() > 32) {\n      throw new Error(\"Invalid public key input\");\n    }\n  }\n  /**\n   * Checks if the provided object is a PublicKey\n   */\n\n\n  _createClass(PublicKey, [{\n    key: \"equals\",\n\n    /**\n     * Checks if two publicKeys are equal\n     */\n    value: function equals(publicKey) {\n      return this._bn.eq(publicKey._bn);\n    }\n    /**\n     * Return the base-58 representation of the public key\n     */\n\n  }, {\n    key: \"toBase58\",\n    value: function toBase58() {\n      return bs58.encode(this.toBuffer());\n    }\n    /**\n     * Return the Buffer representation of the public key\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var b = this._bn.toArrayLike(Buffer);\n\n      if (b.length === 32) {\n        return b;\n      }\n\n      var zeroPad = Buffer.alloc(32);\n      b.copy(zeroPad, 32 - b.length);\n      return zeroPad;\n    }\n    /**\n     * Returns a string representation of the public key\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toBase58();\n    }\n    /**\n     * Derive a public key from another key, a seed, and a programId.\n     */\n\n  }], [{\n    key: \"isPublicKey\",\n    value: function isPublicKey(o) {\n      return o instanceof PublicKey;\n    }\n  }, {\n    key: \"createWithSeed\",\n    value: function createWithSeed(fromPublicKey, seed, programId) {\n      var buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);\n      var hash = hasha(buffer, {\n        algorithm: 'sha256'\n      });\n      return new PublicKey('0x' + hash);\n    }\n  }]);\n\n  return PublicKey;\n}();\n/**\n * An account key pair (public and secret keys).\n */\n\n\nvar Account = /*#__PURE__*/function () {\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  function Account(secretKey) {\n    _classCallCheck(this, Account);\n\n    _defineProperty(this, \"_keypair\", void 0);\n\n    if (secretKey) {\n      this._keypair = nacl.sign.keyPair.fromSecretKey(toBuffer(secretKey));\n    } else {\n      this._keypair = nacl.sign.keyPair();\n    }\n  }\n  /**\n   * The public key for this account\n   */\n\n\n  _createClass(Account, [{\n    key: \"publicKey\",\n    get: function get() {\n      return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n     * The **unencrypted** secret key for this account\n     */\n\n  }, {\n    key: \"secretKey\",\n    get: function get() {\n      return this._keypair.secretKey;\n    }\n  }]);\n\n  return Account;\n}(); // TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @ignore\n */\n\n\nvar NUM_TICKS_PER_SECOND = 10;\n/**\n * @ignore\n */\n\nvar DEFAULT_TICKS_PER_SLOT = 8;\n/**\n * Layout for a public key\n */\n\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return blob(32, property);\n};\n/**\n * Layout for a Rust String type\n */\n\n\nvar rustString = function rustString() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';\n  var rsl = struct([u32('length'), u32('lengthPadding'), blob(offset(u32(), -8), 'chars')], property);\n\n  var _decode = rsl.decode.bind(rsl);\n\n  var _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = function (buffer, offset) {\n    var data = _decode(buffer, offset);\n\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = function (str, buffer, offset) {\n    var data = {\n      chars: Buffer.from(str, 'utf8')\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  rsl.alloc = function (str) {\n    return u32().span + u32().span + Buffer.from(str, 'utf8').length;\n  };\n\n  return rsl;\n};\n/**\n * Layout for an Authorized object\n */\n\n\nvar authorized = function authorized() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';\n  return struct([publicKey('staker'), publicKey('withdrawer')], property);\n};\n/**\n * Layout for a Lockup object\n */\n\n\nvar lockup = function lockup() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';\n  return struct([ns64('unixTimestamp'), ns64('epoch'), publicKey('custodian')], property);\n};\n\nfunction getAlloc(type, fields) {\n  var alloc = 0;\n  type.layout.fields.forEach(function (item) {\n    if (item.span >= 0) {\n      alloc += item.span;\n    } else if (typeof item.alloc === 'function') {\n      alloc += item.alloc(fields[item.property]);\n    }\n  });\n  return alloc;\n}\n\nfunction decodeLength(bytes) {\n  var len = 0;\n  var size = 0;\n\n  for (;;) {\n    var elem = bytes.shift();\n    len |= (elem & 0x7f) << size * 7;\n    size += 1;\n\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n\n  return len;\n}\n\nfunction encodeLength(bytes, len) {\n  var rem_len = len;\n\n  for (;;) {\n    var elem = rem_len & 0x7f;\n    rem_len >>= 7;\n\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n/**\n * Default (empty) signature\n *\n * Signatures are 64 bytes in length\n */\n\n\nvar DEFAULT_SIGNATURE = Buffer.alloc(64).fill(0);\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\n\nvar PACKET_DATA_SIZE = 1280 - 40 - 8;\nvar PUBKEY_LENGTH = 32;\nvar SIGNATURE_LENGTH = 64;\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n *\n * @typedef {Object} TransactionInstructionCtorFields\n * @property {?Array<PublicKey>} keys\n * @property {?PublicKey} programId\n * @property {?Buffer} data\n */\n\n/**\n * Transaction Instruction class\n */\n\nvar TransactionInstruction =\n/**\n * Public keys to include in this transaction\n * Boolean represents whether this pubkey needs to sign the transaction\n */\n\n/**\n * Program Id to execute\n */\n\n/**\n * Program input\n */\nfunction TransactionInstruction(opts) {\n  _classCallCheck(this, TransactionInstruction);\n\n  _defineProperty(this, \"keys\", []);\n\n  _defineProperty(this, \"programId\", void 0);\n\n  _defineProperty(this, \"data\", Buffer.alloc(0));\n\n  opts && Object.assign(this, opts);\n};\n/**\n * @private\n */\n\n/**\n * Transaction class\n */\n\n\nvar Transaction = /*#__PURE__*/function () {\n  _createClass(Transaction, [{\n    key: \"signature\",\n\n    /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */\n\n    /**\n     * The first (payer) Transaction signature\n     */\n    get: function get() {\n      if (this.signatures.length > 0) {\n        return this.signatures[0].signature;\n      }\n\n      return null;\n    }\n    /**\n     * The instructions to atomically execute\n     */\n\n  }]);\n  /**\n   * Construct an empty Transaction\n   */\n\n\n  function Transaction(opts) {\n    _classCallCheck(this, Transaction);\n\n    _defineProperty(this, \"signatures\", []);\n\n    _defineProperty(this, \"instructions\", []);\n\n    _defineProperty(this, \"recentBlockhash\", void 0);\n\n    _defineProperty(this, \"nonceInfo\", void 0);\n\n    opts && Object.assign(this, opts);\n  }\n  /**\n   * Add one or more instructions to this Transaction\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"add\",\n    value: function add() {\n      var _this = this;\n\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n\n      if (items.length === 0) {\n        throw new Error('No instructions');\n      }\n\n      items.forEach(function (item) {\n        if (item instanceof Transaction) {\n          _this.instructions = _this.instructions.concat(item.instructions);\n        } else if (item instanceof TransactionInstruction) {\n          _this.instructions.push(item);\n        } else {\n          _this.instructions.push(new TransactionInstruction(item));\n        }\n      });\n      return this;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_getSignData\",\n    value: function _getSignData() {\n      var _this2 = this;\n\n      var nonceInfo = this.nonceInfo;\n\n      if (nonceInfo && this.instructions[0] != nonceInfo.nonceInstruction) {\n        this.recentBlockhash = nonceInfo.nonce;\n        this.instructions.unshift(nonceInfo.nonceInstruction);\n      }\n\n      var recentBlockhash = this.recentBlockhash;\n\n      if (!recentBlockhash) {\n        throw new Error('Transaction recentBlockhash required');\n      }\n\n      if (this.instructions.length < 1) {\n        throw new Error('No instructions provided');\n      }\n\n      var keys = this.signatures.map(function (_ref) {\n        var publicKey = _ref.publicKey;\n        return publicKey.toString();\n      });\n      var numReadonlySignedAccounts = 0;\n      var numReadonlyUnsignedAccounts = 0;\n      var programIds = [];\n      var allKeys = [];\n      this.instructions.forEach(function (instruction) {\n        instruction.keys.forEach(function (keySignerPair) {\n          allKeys.push(keySignerPair);\n        });\n        var programId = instruction.programId.toString();\n\n        if (!programIds.includes(programId)) {\n          programIds.push(programId);\n        }\n      });\n      allKeys.sort(function (x, y) {\n        var checkSigner = x.isSigner === y.isSigner ? 0 : x.isSigner ? -1 : 1;\n        var checkWritable = x.isWritable === y.isWritable ? 0 : x.isWritable ? -1 : 1;\n        return checkSigner || checkWritable;\n      });\n      allKeys.forEach(function (keySignerPair) {\n        var keyStr = keySignerPair.pubkey.toString();\n\n        if (!keys.includes(keyStr)) {\n          if (keySignerPair.isSigner) {\n            _this2.signatures.push({\n              signature: null,\n              publicKey: keySignerPair.pubkey\n            });\n\n            if (!keySignerPair.isWritable) {\n              numReadonlySignedAccounts += 1;\n            }\n          } else {\n            if (!keySignerPair.isWritable) {\n              numReadonlyUnsignedAccounts += 1;\n            }\n          }\n\n          keys.push(keyStr);\n        }\n      });\n      programIds.forEach(function (programId) {\n        if (!keys.includes(programId)) {\n          keys.push(programId);\n          numReadonlyUnsignedAccounts += 1;\n        }\n      });\n      var keyCount = [];\n      encodeLength(keyCount, keys.length);\n      var instructions = this.instructions.map(function (instruction) {\n        var data = instruction.data,\n            programId = instruction.programId;\n        var keyIndicesCount = [];\n        encodeLength(keyIndicesCount, instruction.keys.length);\n        var dataCount = [];\n        encodeLength(dataCount, instruction.data.length);\n        return {\n          programIdIndex: keys.indexOf(programId.toString()),\n          keyIndicesCount: Buffer.from(keyIndicesCount),\n          keyIndices: Buffer.from(instruction.keys.map(function (keyObj) {\n            return keys.indexOf(keyObj.pubkey.toString());\n          })),\n          dataLength: Buffer.from(dataCount),\n          data: data\n        };\n      });\n      instructions.forEach(function (instruction) {\n        assert(instruction.programIdIndex >= 0);\n        instruction.keyIndices.forEach(function (keyIndex) {\n          return assert(keyIndex >= 0);\n        });\n      });\n      var instructionCount = [];\n      encodeLength(instructionCount, instructions.length);\n      var instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);\n      Buffer.from(instructionCount).copy(instructionBuffer);\n      var instructionBufferLength = instructionCount.length;\n      instructions.forEach(function (instruction) {\n        var instructionLayout = struct([u8('programIdIndex'), blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), seq(u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), blob(instruction.dataLength.length, 'dataLength'), seq(u8('userdatum'), instruction.data.length, 'data')]);\n        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n        instructionBufferLength += length;\n      });\n      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n      var signDataLayout = struct([blob(1, 'numRequiredSignatures'), blob(1, 'numReadonlySignedAccounts'), blob(1, 'numReadonlyUnsignedAccounts'), blob(keyCount.length, 'keyCount'), seq(publicKey('key'), keys.length, 'keys'), publicKey('recentBlockhash')]);\n      var transaction = {\n        numRequiredSignatures: Buffer.from([this.signatures.length]),\n        numReadonlySignedAccounts: Buffer.from([numReadonlySignedAccounts]),\n        numReadonlyUnsignedAccounts: Buffer.from([numReadonlyUnsignedAccounts]),\n        keyCount: Buffer.from(keyCount),\n        keys: keys.map(function (key) {\n          return new PublicKey(key).toBuffer();\n        }),\n        recentBlockhash: Buffer.from(bs58.decode(recentBlockhash))\n      };\n      var signData = Buffer.alloc(2048);\n      var length = signDataLayout.encode(transaction, signData);\n      instructionBuffer.copy(signData, length);\n      signData = signData.slice(0, length + instructionBuffer.length);\n      return signData;\n    }\n    /**\n     * Sign the Transaction with the specified accounts.  Multiple signatures may\n     * be applied to a Transaction. The first signature is considered \"primary\"\n     * and is used when testing for Transaction confirmation.\n     *\n     * Transaction fields should not be modified after the first call to `sign`,\n     * as doing so may invalidate the signature and cause the Transaction to be\n     * rejected.\n     *\n     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      this.signPartial.apply(this, arguments);\n    }\n    /**\n     * Partially sign a Transaction with the specified accounts.  The `Account`\n     * inputs will be used to sign the Transaction immediately, while any\n     * `PublicKey` inputs will be referenced in the signed Transaction but need to\n     * be filled in later by calling `addSigner()` with the matching `Account`.\n     *\n     * All the caveats from the `sign` method apply to `signPartial`\n     */\n\n  }, {\n    key: \"signPartial\",\n    value: function signPartial() {\n      for (var _len2 = arguments.length, partialSigners = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        partialSigners[_key2] = arguments[_key2];\n      }\n\n      if (partialSigners.length === 0) {\n        throw new Error('No signers');\n      }\n\n      var signatures = partialSigners.map(function (accountOrPublicKey) {\n        var publicKey = accountOrPublicKey instanceof Account ? accountOrPublicKey.publicKey : accountOrPublicKey;\n        return {\n          signature: null,\n          publicKey: publicKey\n        };\n      });\n      this.signatures = signatures;\n\n      var signData = this._getSignData();\n\n      partialSigners.forEach(function (accountOrPublicKey, index) {\n        if (accountOrPublicKey instanceof PublicKey) {\n          return;\n        }\n\n        var signature = nacl.sign.detached(signData, accountOrPublicKey.secretKey);\n        assert(signature.length === 64);\n        signatures[index].signature = Buffer.from(signature);\n      });\n    }\n    /**\n     * Fill in a signature for a partially signed Transaction.  The `signer` must\n     * be the corresponding `Account` for a `PublicKey` that was previously provided to\n     * `signPartial`\n     */\n\n  }, {\n    key: \"addSigner\",\n    value: function addSigner(signer) {\n      var index = this.signatures.findIndex(function (sigpair) {\n        return signer.publicKey.equals(sigpair.publicKey);\n      });\n\n      if (index < 0) {\n        throw new Error(\"Unknown signer: \".concat(signer.publicKey.toString()));\n      }\n\n      var signData = this._getSignData();\n\n      var signature = nacl.sign.detached(signData, signer.secretKey);\n      assert(signature.length === 64);\n      this.signatures[index].signature = Buffer.from(signature);\n    }\n    /**\n     * Serialize the Transaction in the wire format.\n     *\n     * The Transaction must have a valid `signature` before invoking this method\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var signatures = this.signatures;\n\n      if (!signatures) {\n        throw new Error('Transaction has not been signed');\n      }\n\n      var signData = this._getSignData();\n\n      var signatureCount = [];\n      encodeLength(signatureCount, signatures.length);\n      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n      var wireTransaction = Buffer.alloc(transactionLength);\n      assert(signatures.length < 256);\n      Buffer.from(signatureCount).copy(wireTransaction, 0);\n      signatures.forEach(function (_ref2, index) {\n        var signature = _ref2.signature;\n\n        if (signature !== null) {\n          assert(signature.length === 64, \"signature has invalid length\");\n          Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n        }\n      });\n      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n      assert(wireTransaction.length <= PACKET_DATA_SIZE, \"Transaction too large: \".concat(wireTransaction.length, \" > \").concat(PACKET_DATA_SIZE));\n      return wireTransaction;\n    }\n    /**\n     * Deprecated method\n     * @private\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].keys.map(function (keyObj) {\n        return keyObj.pubkey;\n      });\n    }\n    /**\n     * Deprecated method\n     * @private\n     */\n\n  }, {\n    key: \"programId\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].programId;\n    }\n    /**\n     * Deprecated method\n     * @private\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].data;\n    }\n    /**\n     * Parse a wire transaction into a Transaction object.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(buffer) {\n      // Slice up wire data\n      var byteArray = _toConsumableArray(buffer);\n\n      var signatureCount = decodeLength(byteArray);\n      var signatures = [];\n\n      for (var i = 0; i < signatureCount; i++) {\n        var signature = byteArray.slice(0, SIGNATURE_LENGTH);\n        byteArray = byteArray.slice(SIGNATURE_LENGTH);\n        signatures.push(bs58.encode(Buffer.from(signature)));\n      }\n\n      var numRequiredSignatures = byteArray.shift(); // byteArray = byteArray.slice(1); // Skip numRequiredSignatures byte\n\n      var numReadonlySignedAccounts = byteArray.shift(); // byteArray = byteArray.slice(1); // Skip numReadonlySignedAccounts byte\n\n      var numReadonlyUnsignedAccounts = byteArray.shift(); // byteArray = byteArray.slice(1); // Skip numReadonlyUnsignedAccounts byte\n\n      var accountCount = decodeLength(byteArray);\n      var accounts = [];\n\n      for (var _i = 0; _i < accountCount; _i++) {\n        var account = byteArray.slice(0, PUBKEY_LENGTH);\n        byteArray = byteArray.slice(PUBKEY_LENGTH);\n        accounts.push(bs58.encode(Buffer.from(account)));\n      }\n\n      var recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);\n      byteArray = byteArray.slice(PUBKEY_LENGTH);\n      var instructionCount = decodeLength(byteArray);\n      var instructions = [];\n\n      for (var _i2 = 0; _i2 < instructionCount; _i2++) {\n        var instruction = {};\n        instruction.programIndex = byteArray.shift();\n\n        var _accountCount = decodeLength(byteArray);\n\n        instruction.accounts = byteArray.slice(0, _accountCount);\n        byteArray = byteArray.slice(_accountCount);\n        var dataLength = decodeLength(byteArray);\n        var data = byteArray.slice(0, dataLength);\n        instruction.data = bs58.encode(Buffer.from(data));\n        byteArray = byteArray.slice(dataLength);\n        instructions.push(instruction);\n      }\n\n      return Transaction._populate(signatures, accounts, instructions, recentBlockhash, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts);\n    }\n    /**\n     * Parse an RPC result into a Transaction object.\n     */\n\n  }, {\n    key: \"fromRpcResult\",\n    value: function fromRpcResult(rpcResult) {\n      var signatures = rpcResult.signatures;\n      var accounts = rpcResult.message.accountKeys;\n      var instructions = rpcResult.message.instructions;\n      var recentBlockhash = rpcResult.message.recentBlockhash;\n      var numRequiredSignatures = rpcResult.message.header.numRequiredSignatures;\n      var numReadonlySignedAccounts = rpcResult.message.header.numReadonlySignedAccounts;\n      var numReadonlyUnsignedAccounts = rpcResult.message.header.numReadonlyUnsignedAccounts;\n      return Transaction._populate(signatures, accounts, instructions, recentBlockhash, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts);\n    }\n    /**\n     * Populate Transaction object\n     * @private\n     */\n\n  }, {\n    key: \"_populate\",\n    value: function _populate(signatures, accounts, instructions, recentBlockhash, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts) {\n      function isWritable(i, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts, numKeys) {\n        return i < numRequiredSignatures - numReadonlySignedAccounts || i >= numRequiredSignatures && i < numKeys - numReadonlyUnsignedAccounts;\n      }\n\n      var transaction = new Transaction();\n      transaction.recentBlockhash = new PublicKey(recentBlockhash).toBase58();\n\n      for (var i = 0; i < signatures.length; i++) {\n        var sigPubkeyPair = {\n          signature: signatures[i] == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(signatures[i]),\n          publicKey: new PublicKey(accounts[i])\n        };\n        transaction.signatures.push(sigPubkeyPair);\n      }\n\n      for (var _i3 = 0; _i3 < instructions.length; _i3++) {\n        var instructionData = {\n          keys: [],\n          programId: new PublicKey(accounts[instructions[_i3].programIndex]),\n          data: bs58.decode(instructions[_i3].data)\n        };\n\n        var _loop = function _loop(j) {\n          var pubkey = new PublicKey(accounts[instructions[_i3].accounts[j]]);\n          instructionData.keys.push({\n            pubkey: pubkey,\n            isSigner: transaction.signatures.some(function (keyObj) {\n              return keyObj.publicKey.toString() === pubkey.toString();\n            }),\n            isWritable: isWritable(j, numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts, accounts.length)\n          });\n        };\n\n        for (var j = 0; j < instructions[_i3].accounts.length; j++) {\n          _loop(j);\n        }\n\n        var instruction = new TransactionInstruction(instructionData);\n        transaction.instructions.push(instruction);\n      }\n\n      return transaction;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nvar SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\nvar SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');\nvar SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');\nvar SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');\nvar SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @private\n */\n\nvar NonceAccountLayout = struct([u32('state'), publicKey('authorizedPubkey'), publicKey('nonce')]);\n/**\n * NonceAccount class\n */\n\nvar NonceAccount = /*#__PURE__*/function () {\n  function NonceAccount() {\n    _classCallCheck(this, NonceAccount);\n\n    _defineProperty(this, \"authorizedPubkey\", void 0);\n\n    _defineProperty(this, \"nonce\", void 0);\n  }\n\n  _createClass(NonceAccount, null, [{\n    key: \"fromAccountData\",\n\n    /**\n     * Deserialize NonceAccount from the account data.\n     *\n     * @param buffer account data\n     * @return NonceAccount\n     */\n    value: function fromAccountData(buffer) {\n      var nonceAccount = NonceAccountLayout.decode(buffer, 0);\n      nonceAccount.authorizedPubkey = new PublicKey(nonceAccount.authorizedPubkey);\n      nonceAccount.nonce = new PublicKey(nonceAccount.nonce).toString();\n      return nonceAccount;\n    }\n  }]);\n\n  return NonceAccount;\n}(); // zzz\n\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n/**\n * @private\n */\n\n\nfunction jsonRpcResultAndContext(resultDescription) {\n  return jsonRpcResult({\n    context: struct$1({\n      slot: 'number'\n    }),\n    value: resultDescription\n  });\n}\n/**\n * @private\n */\n\n\nfunction jsonRpcResult(resultDescription) {\n  var jsonRpcVersion = struct$1.literal('2.0');\n  return struct$1.union([struct$1({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'any'\n  }), struct$1({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'null?',\n    result: resultDescription\n  })]);\n}\n/**\n * The level of commitment desired when querying state\n *   'max':    Query the most recent block which has reached max voter lockout\n *   'recent': Query the most recent block\n *\n * @typedef {'max' | 'recent'} Commitment\n */\n\n/**\n * Network Inflation parameters\n * (see https://docs.solana.com/book/v/master/implemented-proposals/ed_overview)\n *\n * @typedef {Object} Inflation\n * @property {number} foundation\n * @property {number} foundation_term\n * @property {number} initial\n * @property {number} storage\n * @property {number} taper\n * @property {number} terminal\n */\n\n\nvar GetInflationResult = struct$1({\n  foundation: 'number',\n  foundationTerm: 'number',\n  initial: 'number',\n  storage: 'number',\n  taper: 'number',\n  terminal: 'number'\n});\n/**\n * EpochInfo parameters\n * (see https://docs.solana.com/book/v/master/terminology#epoch)\n *\n * @typedef {Object} EpochInfo\n * @property {number} epoch\n * @property {number} slotIndex\n * @property {number} slotsInEpoch\n * @property {number} absoluteSlot\n */\n\nvar GetEpochInfoResult = struct$1({\n  epoch: 'number',\n  slotIndex: 'number',\n  slotsInEpoch: 'number',\n  absoluteSlot: 'number'\n});\n/**\n * EpochSchedule parameters\n * (see https://docs.solana.com/book/v/master/terminology#epoch)\n *\n * @typedef {Object} EpochSchedule\n * @property {number} slots_per_epoch\n * @property {number} leader_schedule_slot_offset\n * @property {boolean} warmup\n * @property {number} first_normal_epoch\n * @property {number} first_normal_slot\n */\n\nvar GetEpochScheduleResult = struct$1({\n  slotsPerEpoch: 'number',\n  leaderScheduleSlotOffset: 'number',\n  warmup: 'boolean',\n  firstNormalEpoch: 'number',\n  firstNormalSlot: 'number'\n});\n/**\n * Signature status for a transaction\n */\n\nvar SignatureStatusResult = struct$1.union([struct$1({\n  Ok: 'null'\n}), struct$1({\n  Err: 'object'\n})]);\n/**\n * Version info for a node\n *\n * @typedef {Object} Version\n * @property {string} solana-core Version of solana-core\n */\n\nvar Version = struct$1({\n  'solana-core': 'string'\n});\n/**\n * A ConfirmedBlock on the ledger\n *\n * @typedef {Object} ConfirmedBlock\n * @property {Blockhash} blockhash Blockhash of this block\n * @property {Blockhash} previousBlockhash Blockhash of this block's parent\n * @property {number} parentSlot Slot index of this block's parent\n * @property {Array<object>} transactions Vector of transactions and status metas\n * @property {Array<object>} rewards Vector of block rewards\n */\n\nfunction createRpcRequest(url) {\n  var server = jayson( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request, callback) {\n      var options, res, text;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = {\n                method: 'POST',\n                body: request,\n                headers: {\n                  'Content-Type': 'application/json'\n                }\n              };\n              _context.prev = 1;\n              _context.next = 4;\n              return fetch(url, options);\n\n            case 4:\n              res = _context.sent;\n              _context.next = 7;\n              return res.text();\n\n            case 7:\n              text = _context.sent;\n              callback(null, text);\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](1);\n              callback(_context.t0);\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 11]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  return function (method, args) {\n    return new Promise(function (resolve, reject) {\n      server.request(method, args, function (err, response) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(response);\n      });\n    });\n  };\n}\n/**\n * Expected JSON RPC response for the \"getInflation\" message\n */\n\n\nvar GetInflationRpcResult = struct$1({\n  jsonrpc: struct$1.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: GetInflationResult\n});\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\n\nvar GetEpochInfoRpcResult = struct$1({\n  jsonrpc: struct$1.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: GetEpochInfoResult\n});\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\n\nvar GetEpochScheduleRpcResult = struct$1({\n  jsonrpc: struct$1.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: GetEpochScheduleResult\n});\n/**\n * Expected JSON RPC response for the \"getBalance\" message\n */\n\nvar GetBalanceAndContextRpcResult = jsonRpcResultAndContext('number?');\n/**\n * Expected JSON RPC response for the \"getVersion\" message\n */\n\nvar GetVersionRpcResult = struct$1({\n  jsonrpc: struct$1.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: Version\n});\n/**\n * @private\n */\n\nvar AccountInfoResult = struct$1({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'string',\n  rentEpoch: 'number?'\n});\n/**\n * Expected JSON RPC response for the \"getAccountInfo\" message\n */\n\nvar GetAccountInfoAndContextRpcResult = jsonRpcResultAndContext(struct$1.union(['null', AccountInfoResult]));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\n\nvar AccountNotificationResult = struct$1({\n  subscription: 'number',\n  result: AccountInfoResult\n});\n/**\n * @private\n */\n\nvar ProgramAccountInfoResult = struct$1({\n  pubkey: 'string',\n  account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\n\nvar ProgramAccountNotificationResult = struct$1({\n  subscription: 'number',\n  result: ProgramAccountInfoResult\n});\n/**\n * @private\n */\n\nvar SlotInfo = struct$1({\n  parent: 'number',\n  slot: 'number',\n  root: 'number'\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\n\nvar SlotNotificationResult = struct$1({\n  subscription: 'number',\n  result: SlotInfo\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\n\nvar SignatureNotificationResult = struct$1({\n  subscription: 'number',\n  result: SignatureStatusResult\n});\n/**\n * Expected JSON RPC response for the \"getProgramAccounts\" message\n */\n\nvar GetProgramAccountsRpcResult = jsonRpcResult(struct$1.array([ProgramAccountInfoResult]));\n/**\n * Expected JSON RPC response for the \"confirmTransaction\" message\n */\n\nvar ConfirmTransactionAndContextRpcResult = jsonRpcResultAndContext('boolean');\n/**\n * Expected JSON RPC response for the \"getSlot\" message\n */\n\nvar GetSlot = jsonRpcResult('number');\n/**\n * Expected JSON RPC response for the \"getSlotLeader\" message\n */\n\nvar GetSlotLeader = jsonRpcResult('string');\n/**\n * Expected JSON RPC response for the \"getClusterNodes\" message\n */\n\nvar GetClusterNodes = jsonRpcResult(struct$1.array([struct$1({\n  pubkey: 'string',\n  gossip: 'string',\n  tpu: struct$1.union(['null', 'string']),\n  rpc: struct$1.union(['null', 'string'])\n})]));\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\n\nvar GetVoteAccounts = jsonRpcResult(struct$1({\n  current: struct$1.array([struct$1({\n    votePubkey: 'string',\n    nodePubkey: 'string',\n    activatedStake: 'number',\n    epochVoteAccount: 'boolean',\n    epochCredits: struct$1.array([struct$1.tuple(['number', 'number', 'number'])]),\n    commission: 'number',\n    lastVote: 'number',\n    rootSlot: 'number?'\n  })]),\n  delinquent: struct$1.array([struct$1({\n    votePubkey: 'string',\n    nodePubkey: 'string',\n    activatedStake: 'number',\n    epochVoteAccount: 'boolean',\n    epochCredits: struct$1.array([struct$1.tuple(['number', 'number', 'number'])]),\n    commission: 'number',\n    lastVote: 'number',\n    rootSlot: 'number?'\n  })])\n}));\n/**\n * Expected JSON RPC response for the \"getSignatureStatus\" message\n */\n\nvar GetSignatureStatusRpcResult = jsonRpcResult(struct$1.union(['null', SignatureStatusResult]));\n/**\n * Expected JSON RPC response for the \"getTransactionCount\" message\n */\n\nvar GetTransactionCountRpcResult = jsonRpcResult('number');\n/**\n * Expected JSON RPC response for the \"getTotalSupply\" message\n */\n\nvar GetTotalSupplyRpcResult = jsonRpcResult('number');\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\n\nvar GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult('number');\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n */\n\nvar GetConfirmedBlockRpcResult = jsonRpcResult(struct$1.union(['null', struct$1({\n  blockhash: 'string',\n  previousBlockhash: 'string',\n  parentSlot: 'number',\n  transactions: struct$1.array([struct$1({\n    transaction: struct$1({\n      signatures: struct$1.array(['string']),\n      message: struct$1({\n        accountKeys: struct$1.array(['string']),\n        header: struct$1({\n          numRequiredSignatures: 'number',\n          numReadonlySignedAccounts: 'number',\n          numReadonlyUnsignedAccounts: 'number'\n        }),\n        instructions: struct$1.array([struct$1.union([struct$1.array(['number']), struct$1({\n          accounts: struct$1.array(['number']),\n          data: 'string',\n          programIdIndex: 'number'\n        })])]),\n        recentBlockhash: 'string'\n      })\n    }),\n    meta: struct$1.union(['null', struct$1({\n      status: struct$1.union(['null', SignatureStatusResult]),\n      fee: 'number',\n      preBalances: struct$1.array(['number']),\n      postBalances: struct$1.array(['number'])\n    })])\n  })]),\n  rewards: struct$1.union(['undefined', struct$1.array([struct$1({\n    pubkey: 'string',\n    lamports: 'number'\n  })])])\n})]));\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n */\n\nvar GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(struct$1({\n  blockhash: 'string',\n  feeCalculator: struct$1({\n    burnPercent: 'number',\n    lamportsPerSignature: 'number',\n    maxLamportsPerSignature: 'number',\n    minLamportsPerSignature: 'number',\n    targetLamportsPerSignature: 'number',\n    targetSignaturesPerSlot: 'number'\n  })\n}));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\n\nvar RequestAirdropRpcResult = jsonRpcResult('string');\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\n\nvar SendTransactionRpcResult = jsonRpcResult('string');\n/**\n * Information describing an account\n *\n * @typedef {Object} AccountInfo\n * @property {number} lamports Number of lamports assigned to the account\n * @property {PublicKey} owner Identifier of the program that owns the account\n * @property {?Buffer} data Optional data assigned to the account\n * @property {boolean} executable `true` if this account's data contains a loaded program\n */\n// This type exists to workaround an esdoc parse error\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\n\nvar Connection = /*#__PURE__*/function () {\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitment optional default commitment level\n   */\n  function Connection(endpoint, commitment) {\n    _classCallCheck(this, Connection);\n\n    _defineProperty(this, \"_rpcRequest\", void 0);\n\n    _defineProperty(this, \"_rpcWebSocket\", void 0);\n\n    _defineProperty(this, \"_rpcWebSocketConnected\", false);\n\n    _defineProperty(this, \"_commitment\", void 0);\n\n    _defineProperty(this, \"_blockhashInfo\", void 0);\n\n    _defineProperty(this, \"_disableBlockhashCaching\", false);\n\n    _defineProperty(this, \"_accountChangeSubscriptions\", {});\n\n    _defineProperty(this, \"_accountChangeSubscriptionCounter\", 0);\n\n    _defineProperty(this, \"_programAccountChangeSubscriptions\", {});\n\n    _defineProperty(this, \"_programAccountChangeSubscriptionCounter\", 0);\n\n    _defineProperty(this, \"_slotSubscriptions\", {});\n\n    _defineProperty(this, \"_slotSubscriptionCounter\", 0);\n\n    _defineProperty(this, \"_signatureSubscriptions\", {});\n\n    _defineProperty(this, \"_signatureSubscriptionCounter\", 0);\n\n    var url = parse(endpoint);\n    this._rpcRequest = createRpcRequest(url.href);\n    this._commitment = commitment;\n    this._blockhashInfo = {\n      recentBlockhash: null,\n      seconds: -1,\n      transactionSignatures: []\n    };\n    url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    url.host = '';\n    url.port = String(Number(url.port) + 1);\n\n    if (url.port === '1') {\n      url.port = url.protocol === 'wss:' ? '8901' : '8900';\n    }\n\n    this._rpcWebSocket = new Client(format(url), {\n      autoconnect: false,\n      max_reconnects: Infinity\n    });\n\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n\n    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));\n\n    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));\n\n    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));\n\n    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));\n  }\n  /**\n   * Fetch the balance for the specified public key, return with context\n   */\n\n\n  _createClass(Connection, [{\n    key: \"getBalanceAndContext\",\n    value: function () {\n      var _getBalanceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(publicKey, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                args = this._argsWithCommitment([publicKey.toBase58()], commitment);\n                _context2.next = 3;\n                return this._rpcRequest('getBalance', args);\n\n              case 3:\n                unsafeRes = _context2.sent;\n                res = GetBalanceAndContextRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context2.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getBalanceAndContext(_x3, _x4) {\n        return _getBalanceAndContext.apply(this, arguments);\n      }\n\n      return getBalanceAndContext;\n    }()\n    /**\n     * Fetch the balance for the specified public key\n     */\n\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(publicKey, commitment) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.getBalanceAndContext(publicKey, commitment).then(function (x) {\n                  return x.value;\n                })[\"catch\"](function (e) {\n                  throw e;\n                });\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getBalance(_x5, _x6) {\n        return _getBalance.apply(this, arguments);\n      }\n\n      return getBalance;\n    }()\n    /**\n     * Fetch all the account info for the specified public key, return with context\n     */\n\n  }, {\n    key: \"getAccountInfoAndContext\",\n    value: function () {\n      var _getAccountInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(publicKey, commitment) {\n        var args, unsafeRes, res, _res$result$value, executable, owner, lamports, data, value;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                args = this._argsWithCommitment([publicKey.toBase58()], commitment);\n                _context4.next = 3;\n                return this._rpcRequest('getAccountInfo', args);\n\n              case 3:\n                unsafeRes = _context4.sent;\n                res = GetAccountInfoAndContextRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n\n                if (res.result.value) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                throw new Error('Invalid request');\n\n              case 10:\n                _res$result$value = res.result.value, executable = _res$result$value.executable, owner = _res$result$value.owner, lamports = _res$result$value.lamports, data = _res$result$value.data;\n                value = {\n                  executable: executable,\n                  owner: new PublicKey(owner),\n                  lamports: lamports,\n                  data: bs58.decode(data)\n                };\n                return _context4.abrupt(\"return\", {\n                  context: {\n                    slot: res.result.context.slot\n                  },\n                  value: value\n                });\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAccountInfoAndContext(_x7, _x8) {\n        return _getAccountInfoAndContext.apply(this, arguments);\n      }\n\n      return getAccountInfoAndContext;\n    }()\n    /**\n     * Fetch all the account info for the specified public key\n     */\n\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(publicKey, commitment) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.getAccountInfoAndContext(publicKey, commitment).then(function (x) {\n                  return x.value;\n                })[\"catch\"](function (e) {\n                  throw e;\n                });\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccountInfo(_x9, _x10) {\n        return _getAccountInfo.apply(this, arguments);\n      }\n\n      return getAccountInfo;\n    }()\n    /**\n     * Fetch all the accounts owned by the specified program id\n     */\n\n  }, {\n    key: \"getProgramAccounts\",\n    value: function () {\n      var _getProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(programId, commitment) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                args = this._argsWithCommitment([programId.toBase58()], commitment);\n                _context6.next = 3;\n                return this._rpcRequest('getProgramAccounts', args);\n\n              case 3:\n                unsafeRes = _context6.sent;\n                res = GetProgramAccountsRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                result = res.result;\n                assert(typeof result !== 'undefined');\n                return _context6.abrupt(\"return\", result.map(function (result) {\n                  return {\n                    pubkey: result.pubkey,\n                    account: {\n                      executable: result.account.executable,\n                      owner: new PublicKey(result.account.owner),\n                      lamports: result.account.lamports,\n                      data: bs58.decode(result.account.data)\n                    }\n                  };\n                }));\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getProgramAccounts(_x11, _x12) {\n        return _getProgramAccounts.apply(this, arguments);\n      }\n\n      return getProgramAccounts;\n    }()\n    /**\n     * Confirm the transaction identified by the specified signature, return with context\n     */\n\n  }, {\n    key: \"confirmTransactionAndContext\",\n    value: function () {\n      var _confirmTransactionAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(signature, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                args = this._argsWithCommitment([signature], commitment);\n                _context7.next = 3;\n                return this._rpcRequest('confirmTransaction', args);\n\n              case 3:\n                unsafeRes = _context7.sent;\n                res = ConfirmTransactionAndContextRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context7.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function confirmTransactionAndContext(_x13, _x14) {\n        return _confirmTransactionAndContext.apply(this, arguments);\n      }\n\n      return confirmTransactionAndContext;\n    }()\n    /**\n     * Confirm the transaction identified by the specified signature\n     */\n\n  }, {\n    key: \"confirmTransaction\",\n    value: function () {\n      var _confirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(signature, commitment) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.confirmTransactionAndContext(signature, commitment).then(function (x) {\n                  return x.value;\n                })[\"catch\"](function (e) {\n                  throw e;\n                });\n\n              case 2:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function confirmTransaction(_x15, _x16) {\n        return _confirmTransaction.apply(this, arguments);\n      }\n\n      return confirmTransaction;\n    }()\n    /**\n     * Return the list of nodes that are currently participating in the cluster\n     */\n\n  }, {\n    key: \"getClusterNodes\",\n    value: function () {\n      var _getClusterNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._rpcRequest('getClusterNodes', []);\n\n              case 2:\n                unsafeRes = _context9.sent;\n                res = GetClusterNodes(unsafeRes);\n\n                if (!res.error) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 6:\n                assert(typeof res.result !== 'undefined');\n                return _context9.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getClusterNodes() {\n        return _getClusterNodes.apply(this, arguments);\n      }\n\n      return getClusterNodes;\n    }()\n    /**\n     * Return the list of nodes that are currently participating in the cluster\n     */\n\n  }, {\n    key: \"getVoteAccounts\",\n    value: function () {\n      var _getVoteAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context10.next = 3;\n                return this._rpcRequest('getVoteAccounts', args);\n\n              case 3:\n                unsafeRes = _context10.sent;\n                res = GetVoteAccounts(unsafeRes); //const res = unsafeRes;\n\n                if (!res.error) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context10.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getVoteAccounts(_x17) {\n        return _getVoteAccounts.apply(this, arguments);\n      }\n\n      return getVoteAccounts;\n    }()\n    /**\n     * Fetch the current slot that the node is processing\n     */\n\n  }, {\n    key: \"getSlot\",\n    value: function () {\n      var _getSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context11.next = 3;\n                return this._rpcRequest('getSlot', args);\n\n              case 3:\n                unsafeRes = _context11.sent;\n                res = GetSlot(unsafeRes);\n\n                if (!res.error) {\n                  _context11.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context11.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSlot(_x18) {\n        return _getSlot.apply(this, arguments);\n      }\n\n      return getSlot;\n    }()\n    /**\n     * Fetch the current slot leader of the cluster\n     */\n\n  }, {\n    key: \"getSlotLeader\",\n    value: function () {\n      var _getSlotLeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context12.next = 3;\n                return this._rpcRequest('getSlotLeader', args);\n\n              case 3:\n                unsafeRes = _context12.sent;\n                res = GetSlotLeader(unsafeRes);\n\n                if (!res.error) {\n                  _context12.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context12.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getSlotLeader(_x19) {\n        return _getSlotLeader.apply(this, arguments);\n      }\n\n      return getSlotLeader;\n    }()\n    /**\n     * Fetch the current status of a signature\n     */\n\n  }, {\n    key: \"getSignatureStatus\",\n    value: function () {\n      var _getSignatureStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(signature, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                args = this._argsWithCommitment([signature], commitment);\n                _context13.next = 3;\n                return this._rpcRequest('getSignatureStatus', args);\n\n              case 3:\n                unsafeRes = _context13.sent;\n                res = GetSignatureStatusRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context13.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context13.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getSignatureStatus(_x20, _x21) {\n        return _getSignatureStatus.apply(this, arguments);\n      }\n\n      return getSignatureStatus;\n    }()\n    /**\n     * Fetch the current transaction count of the cluster\n     */\n\n  }, {\n    key: \"getTransactionCount\",\n    value: function () {\n      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context14.next = 3;\n                return this._rpcRequest('getTransactionCount', args);\n\n              case 3:\n                unsafeRes = _context14.sent;\n                res = GetTransactionCountRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context14.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context14.abrupt(\"return\", Number(res.result));\n\n              case 9:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getTransactionCount(_x22) {\n        return _getTransactionCount.apply(this, arguments);\n      }\n\n      return getTransactionCount;\n    }()\n    /**\n     * Fetch the current total currency supply of the cluster in lamports\n     */\n\n  }, {\n    key: \"getTotalSupply\",\n    value: function () {\n      var _getTotalSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context15.next = 3;\n                return this._rpcRequest('getTotalSupply', args);\n\n              case 3:\n                unsafeRes = _context15.sent;\n                res = GetTotalSupplyRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context15.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context15.abrupt(\"return\", Number(res.result));\n\n              case 9:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getTotalSupply(_x23) {\n        return _getTotalSupply.apply(this, arguments);\n      }\n\n      return getTotalSupply;\n    }()\n    /**\n     * Fetch the cluster Inflation parameters\n     */\n\n  }, {\n    key: \"getInflation\",\n    value: function () {\n      var _getInflation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context16.next = 3;\n                return this._rpcRequest('getInflation', args);\n\n              case 3:\n                unsafeRes = _context16.sent;\n                res = GetInflationRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context16.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context16.abrupt(\"return\", GetInflationResult(res.result));\n\n              case 9:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function getInflation(_x24) {\n        return _getInflation.apply(this, arguments);\n      }\n\n      return getInflation;\n    }()\n    /**\n     * Fetch the Epoch Info parameters\n     */\n\n  }, {\n    key: \"getEpochInfo\",\n    value: function () {\n      var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context17.next = 3;\n                return this._rpcRequest('getEpochInfo', args);\n\n              case 3:\n                unsafeRes = _context17.sent;\n                res = GetEpochInfoRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context17.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context17.abrupt(\"return\", GetEpochInfoResult(res.result));\n\n              case 9:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getEpochInfo(_x25) {\n        return _getEpochInfo.apply(this, arguments);\n      }\n\n      return getEpochInfo;\n    }()\n    /**\n     * Fetch the Epoch Schedule parameters\n     */\n\n  }, {\n    key: \"getEpochSchedule\",\n    value: function () {\n      var _getEpochSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n        var unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this._rpcRequest('getEpochSchedule', []);\n\n              case 2:\n                unsafeRes = _context18.sent;\n                res = GetEpochScheduleRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context18.next = 6;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 6:\n                assert(typeof res.result !== 'undefined');\n                return _context18.abrupt(\"return\", GetEpochScheduleResult(res.result));\n\n              case 8:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function getEpochSchedule() {\n        return _getEpochSchedule.apply(this, arguments);\n      }\n\n      return getEpochSchedule;\n    }()\n    /**\n     * Fetch the minimum balance needed to exempt an account of `dataLength`\n     * size from rent\n     */\n\n  }, {\n    key: \"getMinimumBalanceForRentExemption\",\n    value: function () {\n      var _getMinimumBalanceForRentExemption = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(dataLength, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                args = this._argsWithCommitment([dataLength], commitment);\n                _context19.next = 3;\n                return this._rpcRequest('getMinimumBalanceForRentExemption', args);\n\n              case 3:\n                unsafeRes = _context19.sent;\n                res = GetMinimumBalanceForRentExemptionRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context19.next = 8;\n                  break;\n                }\n\n                console.warn('Unable to fetch minimum balance for rent exemption');\n                return _context19.abrupt(\"return\", 0);\n\n              case 8:\n                assert(typeof res.result !== 'undefined');\n                return _context19.abrupt(\"return\", Number(res.result));\n\n              case 10:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getMinimumBalanceForRentExemption(_x26, _x27) {\n        return _getMinimumBalanceForRentExemption.apply(this, arguments);\n      }\n\n      return getMinimumBalanceForRentExemption;\n    }()\n    /**\n     * Fetch a recent blockhash from the cluster, return with context\n     */\n\n  }, {\n    key: \"getRecentBlockhashAndContext\",\n    value: function () {\n      var _getRecentBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                args = this._argsWithCommitment([], commitment);\n                _context20.next = 3;\n                return this._rpcRequest('getRecentBlockhash', args);\n\n              case 3:\n                unsafeRes = _context20.sent;\n                res = GetRecentBlockhashAndContextRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context20.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context20.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function getRecentBlockhashAndContext(_x28) {\n        return _getRecentBlockhashAndContext.apply(this, arguments);\n      }\n\n      return getRecentBlockhashAndContext;\n    }()\n    /**\n     * Fetch a recent blockhash from the cluster\n     */\n\n  }, {\n    key: \"getRecentBlockhash\",\n    value: function () {\n      var _getRecentBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(commitment) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.getRecentBlockhashAndContext(commitment).then(function (x) {\n                  return x.value;\n                })[\"catch\"](function (e) {\n                  throw e;\n                });\n\n              case 2:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function getRecentBlockhash(_x29) {\n        return _getRecentBlockhash.apply(this, arguments);\n      }\n\n      return getRecentBlockhash;\n    }()\n    /**\n     * Fetch the node version\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function () {\n      var _getVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n        var unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this._rpcRequest('getVersion', []);\n\n              case 2:\n                unsafeRes = _context22.sent;\n                res = GetVersionRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context22.next = 6;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 6:\n                assert(typeof res.result !== 'undefined');\n                return _context22.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function getVersion() {\n        return _getVersion.apply(this, arguments);\n      }\n\n      return getVersion;\n    }()\n    /**\n     * Fetch a list of Transactions and transaction statuses from the cluster\n     * for a confirmed block\n     */\n\n  }, {\n    key: \"getConfirmedBlock\",\n    value: function () {\n      var _getConfirmedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(slot) {\n        var unsafeRes, result;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this._rpcRequest('getConfirmedBlock', [slot]);\n\n              case 2:\n                unsafeRes = _context23.sent;\n                result = GetConfirmedBlockRpcResult(unsafeRes);\n\n                if (!result.error) {\n                  _context23.next = 6;\n                  break;\n                }\n\n                throw new Error(result.error.message);\n\n              case 6:\n                assert(typeof result.result !== 'undefined');\n\n                if (result.result) {\n                  _context23.next = 9;\n                  break;\n                }\n\n                throw new Error('Confirmed block ' + slot + ' not found');\n\n              case 9:\n                return _context23.abrupt(\"return\", {\n                  blockhash: new PublicKey(result.result.blockhash).toString(),\n                  previousBlockhash: new PublicKey(result.result.previousBlockhash).toString(),\n                  parentSlot: result.result.parentSlot,\n                  transactions: result.result.transactions.map(function (result) {\n                    return {\n                      transaction: Transaction.fromRpcResult(result.transaction),\n                      meta: result.meta\n                    };\n                  }),\n                  rewards: result.result.rewards || []\n                });\n\n              case 10:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function getConfirmedBlock(_x30) {\n        return _getConfirmedBlock.apply(this, arguments);\n      }\n\n      return getConfirmedBlock;\n    }()\n    /**\n     * Fetch the contents of a Nonce account from the cluster, return with context\n     */\n\n  }, {\n    key: \"getNonceAndContext\",\n    value: function () {\n      var _getNonceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(nonceAccount, commitment) {\n        var args, unsafeRes, res, value;\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                args = this._argsWithCommitment([nonceAccount.toBase58()], commitment);\n                _context24.next = 3;\n                return this._rpcRequest('getAccountInfo', args);\n\n              case 3:\n                unsafeRes = _context24.sent;\n                res = GetAccountInfoAndContextRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context24.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n\n                if (res.result.value) {\n                  _context24.next = 10;\n                  break;\n                }\n\n                throw new Error('Invalid request');\n\n              case 10:\n                value = NonceAccount.fromAccountData(bs58.decode(res.result.value.data));\n                return _context24.abrupt(\"return\", {\n                  context: {\n                    slot: res.result.context.slot\n                  },\n                  value: value\n                });\n\n              case 12:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function getNonceAndContext(_x31, _x32) {\n        return _getNonceAndContext.apply(this, arguments);\n      }\n\n      return getNonceAndContext;\n    }()\n    /**\n     * Fetch the contents of a Nonce account from the cluster\n     */\n\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(nonceAccount, commitment) {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return this.getNonceAndContext(nonceAccount, commitment).then(function (x) {\n                  return x.value;\n                })[\"catch\"](function (e) {\n                  throw e;\n                });\n\n              case 2:\n                return _context25.abrupt(\"return\", _context25.sent);\n\n              case 3:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function getNonce(_x33, _x34) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n    /**\n     * Request an allocation of lamports to the specified account\n     */\n\n  }, {\n    key: \"requestAirdrop\",\n    value: function () {\n      var _requestAirdrop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(to, amount, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                args = this._argsWithCommitment([to.toBase58(), amount], commitment);\n                _context26.next = 3;\n                return this._rpcRequest('requestAirdrop', args);\n\n              case 3:\n                unsafeRes = _context26.sent;\n                res = RequestAirdropRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context26.next = 7;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 7:\n                assert(typeof res.result !== 'undefined');\n                return _context26.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function requestAirdrop(_x35, _x36, _x37) {\n        return _requestAirdrop.apply(this, arguments);\n      }\n\n      return requestAirdrop;\n    }()\n    /**\n     * Sign and send a transaction\n     */\n\n  }, {\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(transaction) {\n        var _len,\n            signers,\n            _key,\n            seconds,\n            signature,\n            attempts,\n            startTime,\n            _ref2,\n            blockhash,\n            wireTransaction,\n            _args27 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                for (_len = _args27.length, signers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  signers[_key - 1] = _args27[_key];\n                }\n\n                if (!transaction.nonceInfo) {\n                  _context27.next = 5;\n                  break;\n                }\n\n                transaction.sign.apply(transaction, signers);\n                _context27.next = 34;\n                break;\n\n              case 5:\n                // Attempt to use a recent blockhash for up to 30 seconds\n                seconds = new Date().getSeconds();\n\n                if (!(this._blockhashInfo.recentBlockhash != null && this._blockhashInfo.seconds < seconds + 30)) {\n                  _context27.next = 16;\n                  break;\n                }\n\n                transaction.recentBlockhash = this._blockhashInfo.recentBlockhash;\n                transaction.sign.apply(transaction, signers);\n\n                if (transaction.signature) {\n                  _context27.next = 11;\n                  break;\n                }\n\n                throw new Error('!signature');\n\n              case 11:\n                // If the signature of this transaction has not been seen before with the\n                // current recentBlockhash, all done.\n                signature = transaction.signature.toString();\n\n                if (this._blockhashInfo.transactionSignatures.includes(signature)) {\n                  _context27.next = 16;\n                  break;\n                }\n\n                this._blockhashInfo.transactionSignatures.push(signature);\n\n                if (this._disableBlockhashCaching) {\n                  this._blockhashInfo.seconds = -1;\n                }\n\n                return _context27.abrupt(\"break\", 34);\n\n              case 16:\n                // Fetch a new blockhash\n                attempts = 0;\n                startTime = Date.now();\n\n              case 18:\n                _context27.next = 20;\n                return this.getRecentBlockhash();\n\n              case 20:\n                _ref2 = _context27.sent;\n                blockhash = _ref2.blockhash;\n\n                if (!(this._blockhashInfo.recentBlockhash != blockhash)) {\n                  _context27.next = 25;\n                  break;\n                }\n\n                this._blockhashInfo = {\n                  recentBlockhash: blockhash,\n                  seconds: new Date().getSeconds(),\n                  transactionSignatures: []\n                };\n                return _context27.abrupt(\"break\", 32);\n\n              case 25:\n                if (!(attempts === 50)) {\n                  _context27.next = 27;\n                  break;\n                }\n\n                throw new Error(\"Unable to obtain a new blockhash after \".concat(Date.now() - startTime, \"ms\"));\n\n              case 27:\n                _context27.next = 29;\n                return sleep(500 * DEFAULT_TICKS_PER_SLOT / NUM_TICKS_PER_SECOND);\n\n              case 29:\n                ++attempts;\n\n              case 30:\n                _context27.next = 18;\n                break;\n\n              case 32:\n                _context27.next = 5;\n                break;\n\n              case 34:\n                wireTransaction = transaction.serialize();\n                _context27.next = 37;\n                return this.sendRawTransaction(wireTransaction);\n\n              case 37:\n                return _context27.abrupt(\"return\", _context27.sent);\n\n              case 38:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function sendTransaction(_x38) {\n        return _sendTransaction.apply(this, arguments);\n      }\n\n      return sendTransaction;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"validatorExit\",\n    value: function () {\n      var _validatorExit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {\n        var unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this._rpcRequest('validatorExit', []);\n\n              case 2:\n                unsafeRes = _context28.sent;\n                res = jsonRpcResult('boolean')(unsafeRes);\n\n                if (!res.error) {\n                  _context28.next = 6;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 6:\n                assert(typeof res.result !== 'undefined');\n                return _context28.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function validatorExit() {\n        return _validatorExit.apply(this, arguments);\n      }\n\n      return validatorExit;\n    }()\n    /**\n     * Send a transaction that has already been signed and serialized into the\n     * wire format\n     */\n\n  }, {\n    key: \"sendRawTransaction\",\n    value: function () {\n      var _sendRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(rawTransaction) {\n        var encodedTransaction, result;\n        return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                encodedTransaction = bs58.encode(toBuffer(rawTransaction));\n                _context29.next = 3;\n                return this.sendEncodedTransaction(encodedTransaction);\n\n              case 3:\n                result = _context29.sent;\n                return _context29.abrupt(\"return\", result);\n\n              case 5:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n\n      function sendRawTransaction(_x39) {\n        return _sendRawTransaction.apply(this, arguments);\n      }\n\n      return sendRawTransaction;\n    }()\n    /**\n     * Send a transaction that has already been signed, serialized into the\n     * wire format, and encoded as a base58 string\n     */\n\n  }, {\n    key: \"sendEncodedTransaction\",\n    value: function () {\n      var _sendEncodedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(encodedTransaction) {\n        var unsafeRes, res;\n        return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                _context30.next = 2;\n                return this._rpcRequest('sendTransaction', [encodedTransaction]);\n\n              case 2:\n                unsafeRes = _context30.sent;\n                res = SendTransactionRpcResult(unsafeRes);\n\n                if (!res.error) {\n                  _context30.next = 6;\n                  break;\n                }\n\n                throw new Error(res.error.message);\n\n              case 6:\n                assert(typeof res.result !== 'undefined');\n                assert(res.result);\n                return _context30.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n\n      function sendEncodedTransaction(_x40) {\n        return _sendEncodedTransaction.apply(this, arguments);\n      }\n\n      return sendEncodedTransaction;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnOpen\",\n    value: function _wsOnOpen() {\n      this._rpcWebSocketConnected = true;\n\n      this._updateSubscriptions();\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnError\",\n    value: function _wsOnError(err) {\n      console.log('ws error:', err.message);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnClose\",\n    value: function _wsOnClose(code, message) {\n      // 1000 means _rpcWebSocket.close() was called explicitly\n      if (code !== 1000) {\n        console.log('ws close:', code, message);\n      } else {\n        // Only after an explicit close do we need to explicitly connect again\n        this._rpcWebSocketConnected = false;\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_subscribe\",\n    value: function () {\n      var _subscribe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(sub, rpcMethod, rpcArgs) {\n        var id;\n        return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                if (!(sub.subscriptionId == null)) {\n                  _context31.next = 13;\n                  break;\n                }\n\n                sub.subscriptionId = 'subscribing';\n                _context31.prev = 2;\n                _context31.next = 5;\n                return this._rpcWebSocket.call(rpcMethod, rpcArgs);\n\n              case 5:\n                id = _context31.sent;\n\n                if (sub.subscriptionId === 'subscribing') {\n                  // eslint-disable-next-line require-atomic-updates\n                  sub.subscriptionId = id;\n                }\n\n                _context31.next = 13;\n                break;\n\n              case 9:\n                _context31.prev = 9;\n                _context31.t0 = _context31[\"catch\"](2);\n\n                if (sub.subscriptionId === 'subscribing') {\n                  // eslint-disable-next-line require-atomic-updates\n                  sub.subscriptionId = null;\n                }\n\n                console.error(\"\".concat(rpcMethod, \" error for argument\"), rpcArgs, _context31.t0.message);\n\n              case 13:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this, [[2, 9]]);\n      }));\n\n      function _subscribe(_x41, _x42, _x43) {\n        return _subscribe2.apply(this, arguments);\n      }\n\n      return _subscribe;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function () {\n      var _unsubscribe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(sub, rpcMethod) {\n        var subscriptionId, unsubscribeId;\n        return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                subscriptionId = sub.subscriptionId;\n\n                if (!(subscriptionId != null && typeof subscriptionId != 'string')) {\n                  _context32.next = 11;\n                  break;\n                }\n\n                unsubscribeId = subscriptionId;\n                _context32.prev = 3;\n                _context32.next = 6;\n                return this._rpcWebSocket.call(rpcMethod, [unsubscribeId]);\n\n              case 6:\n                _context32.next = 11;\n                break;\n\n              case 8:\n                _context32.prev = 8;\n                _context32.t0 = _context32[\"catch\"](3);\n                console.log(\"\".concat(rpcMethod, \" error:\"), _context32.t0.message);\n\n              case 11:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this, [[3, 8]]);\n      }));\n\n      function _unsubscribe(_x44, _x45) {\n        return _unsubscribe2.apply(this, arguments);\n      }\n\n      return _unsubscribe;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_updateSubscriptions\",\n    value: function _updateSubscriptions() {\n      var accountKeys = Object.keys(this._accountChangeSubscriptions).map(Number);\n      var programKeys = Object.keys(this._programAccountChangeSubscriptions).map(Number);\n      var slotKeys = Object.keys(this._slotSubscriptions).map(Number);\n      var signatureKeys = Object.keys(this._signatureSubscriptions).map(Number);\n\n      if (accountKeys.length === 0 && programKeys.length === 0 && slotKeys.length === 0 && signatureKeys.length === 0) {\n        this._rpcWebSocket.close();\n\n        return;\n      }\n\n      if (!this._rpcWebSocketConnected) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = accountKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var id = _step.value;\n            this._accountChangeSubscriptions[id].subscriptionId = null;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = programKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _id = _step2.value;\n            this._programAccountChangeSubscriptions[_id].subscriptionId = null;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = slotKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _id2 = _step3.value;\n            this._slotSubscriptions[_id2].subscriptionId = null;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = signatureKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _id3 = _step4.value;\n            this._signatureSubscriptions[_id3].subscriptionId = null;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        this._rpcWebSocket.connect();\n\n        return;\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = accountKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _id4 = _step5.value;\n          var sub = this._accountChangeSubscriptions[_id4];\n\n          this._subscribe(sub, 'accountSubscribe', [sub.publicKey]);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = programKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _id5 = _step6.value;\n          var _sub = this._programAccountChangeSubscriptions[_id5];\n\n          this._subscribe(_sub, 'programSubscribe', [_sub.programId]);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n            _iterator6[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = slotKeys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _id6 = _step7.value;\n          var _sub2 = this._slotSubscriptions[_id6];\n\n          this._subscribe(_sub2, 'slotSubscribe', []);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n            _iterator7[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = signatureKeys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var _id7 = _step8.value;\n          var _sub3 = this._signatureSubscriptions[_id7];\n\n          this._subscribe(_sub3, 'signatureSubscribe', [_sub3.signature]);\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n            _iterator8[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnAccountNotification\",\n    value: function _wsOnAccountNotification(notification) {\n      var res = AccountNotificationResult(notification);\n\n      if (res.error) {\n        throw new Error(res.error.message);\n      }\n\n      var keys = Object.keys(this._accountChangeSubscriptions).map(Number);\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = keys[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var id = _step9.value;\n          var sub = this._accountChangeSubscriptions[id];\n\n          if (sub.subscriptionId === res.subscription) {\n            var result = res.result;\n            assert(typeof result !== 'undefined');\n            sub.callback({\n              executable: result.executable,\n              owner: new PublicKey(result.owner),\n              lamports: result.lamports,\n              data: bs58.decode(result.data)\n            });\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n            _iterator9[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    }\n    /**\n     * Register a callback to be invoked whenever the specified account changes\n     *\n     * @param publickey Public key of the account to monitor\n     * @param callback Function to invoke whenever the account is changed\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onAccountChange\",\n    value: function onAccountChange(publicKey, callback) {\n      var id = ++this._accountChangeSubscriptionCounter;\n      this._accountChangeSubscriptions[id] = {\n        publicKey: publicKey.toBase58(),\n        callback: callback,\n        subscriptionId: null\n      };\n\n      this._updateSubscriptions();\n\n      return id;\n    }\n    /**\n     * Deregister an account notification callback\n     *\n     * @param id subscription id to deregister\n     */\n\n  }, {\n    key: \"removeAccountChangeListener\",\n    value: function () {\n      var _removeAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33(id) {\n        var subInfo;\n        return _regeneratorRuntime.wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                if (!this._accountChangeSubscriptions[id]) {\n                  _context33.next = 8;\n                  break;\n                }\n\n                subInfo = this._accountChangeSubscriptions[id];\n                delete this._accountChangeSubscriptions[id];\n                _context33.next = 5;\n                return this._unsubscribe(subInfo, 'accountUnsubscribe');\n\n              case 5:\n                this._updateSubscriptions();\n\n                _context33.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Unknown account change id: \".concat(id));\n\n              case 9:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this);\n      }));\n\n      function removeAccountChangeListener(_x46) {\n        return _removeAccountChangeListener.apply(this, arguments);\n      }\n\n      return removeAccountChangeListener;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnProgramAccountNotification\",\n    value: function _wsOnProgramAccountNotification(notification) {\n      var res = ProgramAccountNotificationResult(notification);\n\n      if (res.error) {\n        throw new Error(res.error.message);\n      }\n\n      var keys = Object.keys(this._programAccountChangeSubscriptions).map(Number);\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = keys[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var id = _step10.value;\n          var sub = this._programAccountChangeSubscriptions[id];\n\n          if (sub.subscriptionId === res.subscription) {\n            var result = res.result;\n            assert(typeof result !== 'undefined');\n            sub.callback({\n              accountId: result.pubkey,\n              accountInfo: {\n                executable: result.account.executable,\n                owner: new PublicKey(result.account.owner),\n                lamports: result.account.lamports,\n                data: bs58.decode(result.account.data)\n              }\n            });\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10[\"return\"] != null) {\n            _iterator10[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n    /**\n     * Register a callback to be invoked whenever accounts owned by the\n     * specified program change\n     *\n     * @param programId Public key of the program to monitor\n     * @param callback Function to invoke whenever the account is changed\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onProgramAccountChange\",\n    value: function onProgramAccountChange(programId, callback) {\n      var id = ++this._programAccountChangeSubscriptionCounter;\n      this._programAccountChangeSubscriptions[id] = {\n        programId: programId.toBase58(),\n        callback: callback,\n        subscriptionId: null\n      };\n\n      this._updateSubscriptions();\n\n      return id;\n    }\n    /**\n     * Deregister an account notification callback\n     *\n     * @param id subscription id to deregister\n     */\n\n  }, {\n    key: \"removeProgramAccountChangeListener\",\n    value: function () {\n      var _removeProgramAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(id) {\n        var subInfo;\n        return _regeneratorRuntime.wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                if (!this._programAccountChangeSubscriptions[id]) {\n                  _context34.next = 8;\n                  break;\n                }\n\n                subInfo = this._programAccountChangeSubscriptions[id];\n                delete this._programAccountChangeSubscriptions[id];\n                _context34.next = 5;\n                return this._unsubscribe(subInfo, 'programUnsubscribe');\n\n              case 5:\n                this._updateSubscriptions();\n\n                _context34.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Unknown program account change id: \".concat(id));\n\n              case 9:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n\n      function removeProgramAccountChangeListener(_x47) {\n        return _removeProgramAccountChangeListener.apply(this, arguments);\n      }\n\n      return removeProgramAccountChangeListener;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnSlotNotification\",\n    value: function _wsOnSlotNotification(notification) {\n      var res = SlotNotificationResult(notification);\n\n      if (res.error) {\n        throw new Error(res.error.message);\n      }\n\n      assert(typeof res.result !== 'undefined');\n      var _res$result = res.result,\n          parent = _res$result.parent,\n          slot = _res$result.slot,\n          root = _res$result.root;\n      var keys = Object.keys(this._slotSubscriptions).map(Number);\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = keys[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var id = _step11.value;\n          var sub = this._slotSubscriptions[id];\n\n          if (sub.subscriptionId === res.subscription) {\n            sub.callback({\n              parent: parent,\n              slot: slot,\n              root: root\n            });\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11[\"return\"] != null) {\n            _iterator11[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n    }\n    /**\n     * Register a callback to be invoked upon slot changes\n     *\n     * @param callback Function to invoke whenever the slot changes\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onSlotChange\",\n    value: function onSlotChange(callback) {\n      var id = ++this._slotSubscriptionCounter;\n      this._slotSubscriptions[id] = {\n        callback: callback,\n        subscriptionId: null\n      };\n\n      this._updateSubscriptions();\n\n      return id;\n    }\n    /**\n     * Deregister a slot notification callback\n     *\n     * @param id subscription id to deregister\n     */\n\n  }, {\n    key: \"removeSlotChangeListener\",\n    value: function () {\n      var _removeSlotChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35(id) {\n        var subInfo;\n        return _regeneratorRuntime.wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                if (!this._slotSubscriptions[id]) {\n                  _context35.next = 8;\n                  break;\n                }\n\n                subInfo = this._slotSubscriptions[id];\n                delete this._slotSubscriptions[id];\n                _context35.next = 5;\n                return this._unsubscribe(subInfo, 'slotUnsubscribe');\n\n              case 5:\n                this._updateSubscriptions();\n\n                _context35.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Unknown slot change id: \".concat(id));\n\n              case 9:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n\n      function removeSlotChangeListener(_x48) {\n        return _removeSlotChangeListener.apply(this, arguments);\n      }\n\n      return removeSlotChangeListener;\n    }()\n  }, {\n    key: \"_argsWithCommitment\",\n    value: function _argsWithCommitment(args, override) {\n      var commitment = override || this._commitment;\n\n      if (commitment) {\n        args.push({\n          commitment: commitment\n        });\n      }\n\n      return args;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_wsOnSignatureNotification\",\n    value: function _wsOnSignatureNotification(notification) {\n      var res = SignatureNotificationResult(notification);\n\n      if (res.error) {\n        throw new Error(res.error.message);\n      }\n\n      assert(typeof res.result !== 'undefined');\n      var keys = Object.keys(this._signatureSubscriptions).map(Number);\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = keys[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var id = _step12.value;\n          var sub = this._signatureSubscriptions[id];\n\n          if (sub.subscriptionId === res.subscription) {\n            // Signatures subscriptions are auto-removed by the RPC service so\n            // no need to explicitly send an unsubscribe message\n            delete this._signatureSubscriptions[id];\n\n            this._updateSubscriptions();\n\n            sub.callback(res.result);\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12[\"return\"] != null) {\n            _iterator12[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n    /**\n     * Register a callback to be invoked upon signature updates\n     *\n     * @param signature Transaction signature string in base 58\n     * @param callback Function to invoke on signature notifications\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onSignature\",\n    value: function onSignature(signature, callback) {\n      var id = ++this._signatureSubscriptionCounter;\n      this._signatureSubscriptions[id] = {\n        signature: signature,\n        callback: callback,\n        subscriptionId: null\n      };\n\n      this._updateSubscriptions();\n\n      return id;\n    }\n    /**\n     * Deregister a signature notification callback\n     *\n     * @param id subscription id to deregister\n     */\n\n  }, {\n    key: \"removeSignatureListener\",\n    value: function () {\n      var _removeSignatureListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(id) {\n        var subInfo;\n        return _regeneratorRuntime.wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                if (!this._signatureSubscriptions[id]) {\n                  _context36.next = 8;\n                  break;\n                }\n\n                subInfo = this._signatureSubscriptions[id];\n                delete this._signatureSubscriptions[id];\n                _context36.next = 5;\n                return this._unsubscribe(subInfo, 'signatureUnsubscribe');\n\n              case 5:\n                this._updateSubscriptions();\n\n                _context36.next = 9;\n                break;\n\n              case 8:\n                throw new Error(\"Unknown signature result id: \".concat(id));\n\n              case 9:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this);\n      }));\n\n      function removeSignatureListener(_x49) {\n        return _removeSignatureListener.apply(this, arguments);\n      }\n\n      return removeSignatureListener;\n    }()\n  }]);\n\n  return Connection;\n}();\n/**\n * Sign, send and confirm a transaction with recent commitment level\n */\n\n\nfunction sendAndConfirmRecentTransaction(_x, _x2) {\n  return _sendAndConfirmRecentTransaction.apply(this, arguments);\n}\n/**\n * Sign, send and confirm a transaction\n */\n\n\nfunction _sendAndConfirmRecentTransaction() {\n  _sendAndConfirmRecentTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, transaction) {\n    var _len,\n        signers,\n        _key,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            for (_len = _args.length, signers = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n              signers[_key - 2] = _args[_key];\n            }\n\n            _context.next = 3;\n            return _sendAndConfirmTransaction(connection, transaction, signers, 'recent');\n\n          case 3:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _sendAndConfirmRecentTransaction.apply(this, arguments);\n}\n\nfunction sendAndConfirmTransaction(_x3, _x4) {\n  return _sendAndConfirmTransaction2.apply(this, arguments);\n}\n\nfunction _sendAndConfirmTransaction2() {\n  _sendAndConfirmTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection, transaction) {\n    var _len2,\n        signers,\n        _key2,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            for (_len2 = _args2.length, signers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n              signers[_key2 - 2] = _args2[_key2];\n            }\n\n            _context2.next = 3;\n            return _sendAndConfirmTransaction(connection, transaction, signers);\n\n          case 3:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _sendAndConfirmTransaction2.apply(this, arguments);\n}\n\nfunction _sendAndConfirmTransaction(_x5, _x6, _x7, _x8) {\n  return _sendAndConfirmTransaction3.apply(this, arguments);\n}\n\nfunction _sendAndConfirmTransaction3() {\n  _sendAndConfirmTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection, transaction, signers, commitment) {\n    var sendRetries, signature, start, status, statusRetries, duration;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            sendRetries = 10;\n\n          case 1:\n            start = Date.now();\n            _context3.next = 4;\n            return connection.sendTransaction.apply(connection, [transaction].concat(_toConsumableArray(signers)));\n\n          case 4:\n            signature = _context3.sent; // Wait up to a couple slots for a confirmation\n\n            status = null;\n            statusRetries = 6;\n\n          case 7:\n            _context3.next = 9;\n            return connection.getSignatureStatus(signature, commitment);\n\n          case 9:\n            status = _context3.sent;\n\n            if (!status) {\n              _context3.next = 12;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 18);\n\n          case 12:\n            if (!(--statusRetries <= 0)) {\n              _context3.next = 14;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 18);\n\n          case 14:\n            _context3.next = 16;\n            return sleep(500 * DEFAULT_TICKS_PER_SLOT / NUM_TICKS_PER_SECOND);\n\n          case 16:\n            _context3.next = 7;\n            break;\n\n          case 18:\n            if (!(status && 'Ok' in status)) {\n              _context3.next = 20;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 29);\n\n          case 20:\n            if (!(--sendRetries <= 0)) {\n              _context3.next = 23;\n              break;\n            }\n\n            duration = (Date.now() - start) / 1000;\n            throw new Error(\"Transaction '\".concat(signature, \"' was not confirmed in \").concat(duration.toFixed(2), \" seconds (\").concat(JSON.stringify(status), \")\"));\n\n          case 23:\n            if (!(status && status.Err && !('AccountInUse' in status.Err))) {\n              _context3.next = 25;\n              break;\n            }\n\n            throw new Error(\"Transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n\n          case 25:\n            _context3.next = 27;\n            return sleep(Math.random() * 100);\n\n          case 27:\n            _context3.next = 1;\n            break;\n\n          case 29:\n            assert(signature !== undefined);\n            return _context3.abrupt(\"return\", signature);\n\n          case 31:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _sendAndConfirmTransaction3.apply(this, arguments);\n}\n/**\n * @typedef {Object} InstructionType\n * @property (index} The Instruction index (from solana upstream program)\n * @property (BufferLayout} The BufferLayout to use to build data\n */\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n */\n\n\nfunction encodeData(type, fields) {\n  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n  var data = Buffer.alloc(allocLength);\n  var layoutFields = Object.assign({\n    instruction: type.index\n  }, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n/**\n * System Instruction class\n */\n\n\nvar SystemInstruction = /*#__PURE__*/function (_TransactionInstructi) {\n  _inherits(SystemInstruction, _TransactionInstructi);\n  /**\n   * Type of SystemInstruction\n   */\n\n\n  function SystemInstruction(opts, type) {\n    var _this;\n\n    _classCallCheck(this, SystemInstruction);\n\n    if (opts && opts.programId && !opts.programId.equals(SystemProgram.programId)) {\n      throw new Error('programId incorrect; not a SystemInstruction');\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SystemInstruction).call(this, opts));\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    if (type) {\n      _this.type = type;\n    }\n\n    return _this;\n  }\n\n  _createClass(SystemInstruction, [{\n    key: \"fromPublicKey\",\n\n    /**\n     * The `from` public key of the instruction;\n     * returns null if SystemInstructionType does not support this field\n     */\n    get: function get() {\n      if (this.type == SystemInstructionLayout.Create || this.type == SystemInstructionLayout.CreateWithSeed || this.type == SystemInstructionLayout.WithdrawNonceAccount || this.type == SystemInstructionLayout.Transfer) {\n        return this.keys[0].pubkey;\n      }\n\n      return null;\n    }\n    /**\n     * The `to` public key of the instruction;\n     * returns null if SystemInstructionType does not support this field\n     */\n\n  }, {\n    key: \"toPublicKey\",\n    get: function get() {\n      if (this.type == SystemInstructionLayout.Create || this.type == SystemInstructionLayout.CreateWithSeed || this.type == SystemInstructionLayout.WithdrawNonceAccount || this.type == SystemInstructionLayout.Transfer) {\n        return this.keys[1].pubkey;\n      }\n\n      return null;\n    }\n    /**\n     * The `amount` or `lamports` of the instruction;\n     * returns null if SystemInstructionType does not support this field\n     */\n\n  }, {\n    key: \"amount\",\n    get: function get() {\n      var data = this.type.layout.decode(this.data);\n\n      if (this.type == SystemInstructionLayout.Create || this.type == SystemInstructionLayout.CreateWithSeed || this.type == SystemInstructionLayout.WithdrawNonceAccount || this.type == SystemInstructionLayout.Transfer) {\n        return data.lamports;\n      }\n\n      return null;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(instruction) {\n      if (!instruction.programId.equals(SystemProgram.programId)) {\n        throw new Error('programId incorrect; not SystemProgram');\n      }\n\n      var instructionTypeLayout = u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n\n      for (var t in SystemInstructionLayout) {\n        if (SystemInstructionLayout[t].index == typeIndex) {\n          type = SystemInstructionLayout[t];\n        }\n      }\n\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a SystemInstruction');\n      }\n\n      return new SystemInstruction({\n        keys: instruction.keys,\n        programId: instruction.programId,\n        data: instruction.data\n      }, type);\n    }\n  }]);\n\n  return SystemInstruction;\n}(TransactionInstruction);\n/**\n * An enumeration of valid SystemInstructionTypes\n */\n\n\nvar SystemInstructionLayout = Object.freeze({\n  Create: {\n    index: 0,\n    layout: struct([u32('instruction'), ns64('lamports'), ns64('space'), publicKey('programId')])\n  },\n  Assign: {\n    index: 1,\n    layout: struct([u32('instruction'), publicKey('programId')])\n  },\n  Transfer: {\n    index: 2,\n    layout: struct([u32('instruction'), ns64('lamports')])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: struct([u32('instruction'), publicKey('base'), rustString('seed'), ns64('lamports'), ns64('space'), publicKey('programId')])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: struct([u32('instruction')])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: struct([u32('instruction'), ns64('lamports')])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: struct([u32('instruction'), publicKey('authorized')])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: struct([u32('instruction'), publicKey('authorized')])\n  }\n});\n/**\n * Factory class for transactions to interact with the System program\n */\n\nvar SystemProgram = /*#__PURE__*/function () {\n  function SystemProgram() {\n    _classCallCheck(this, SystemProgram);\n  }\n\n  _createClass(SystemProgram, null, [{\n    key: \"createAccount\",\n\n    /**\n     * Generate a Transaction that creates a new account\n     */\n    value: function createAccount(from, newAccount, lamports, space, programId) {\n      var type = SystemInstructionLayout.Create;\n      var data = encodeData(type, {\n        lamports: lamports,\n        space: space,\n        programId: programId.toBuffer()\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: from,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: newAccount,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that transfers lamports from one account to another\n     */\n\n  }, {\n    key: \"transfer\",\n    value: function transfer(from, to, lamports) {\n      var type = SystemInstructionLayout.Transfer;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: from,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: to,\n          isSigner: false,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that assigns an account to a program\n     */\n\n  }, {\n    key: \"assign\",\n    value: function assign(from, programId) {\n      var type = SystemInstructionLayout.Assign;\n      var data = encodeData(type, {\n        programId: programId.toBuffer()\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: from,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that creates a new account at\n     *   an address generated with `from`, a seed, and programId\n     */\n\n  }, {\n    key: \"createAccountWithSeed\",\n    value: function createAccountWithSeed(from, newAccount, base, seed, lamports, space, programId) {\n      var type = SystemInstructionLayout.CreateWithSeed;\n      var data = encodeData(type, {\n        base: base.toBuffer(),\n        seed: seed,\n        lamports: lamports,\n        space: space,\n        programId: programId.toBuffer()\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: from,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: newAccount,\n          isSigner: false,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that creates a new Nonce account\n     */\n\n  }, {\n    key: \"createNonceAccount\",\n    value: function createNonceAccount(from, nonceAccount, authorizedPubkey, lamports) {\n      var transaction = SystemProgram.createAccount(from, nonceAccount, lamports, this.nonceSpace, this.programId);\n      var type = SystemInstructionLayout.InitializeNonceAccount;\n      var data = encodeData(type, {\n        authorized: authorizedPubkey.toBuffer()\n      });\n      return transaction.add({\n        keys: [{\n          pubkey: nonceAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate an instruction to advance the nonce in a Nonce account\n     */\n\n  }, {\n    key: \"nonceAdvance\",\n    value: function nonceAdvance(nonceAccount, authorizedPubkey) {\n      var type = SystemInstructionLayout.AdvanceNonceAccount;\n      var data = encodeData(type);\n      var instructionData = {\n        keys: [{\n          pubkey: nonceAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a Transaction that withdraws lamports from a Nonce account\n     */\n\n  }, {\n    key: \"nonceWithdraw\",\n    value: function nonceWithdraw(nonceAccount, authorizedPubkey, to, lamports) {\n      var type = SystemInstructionLayout.WithdrawNonceAccount;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: nonceAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: to,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as the authority\n     * on a Nonce account.\n     */\n\n  }, {\n    key: \"nonceAuthorize\",\n    value: function nonceAuthorize(nonceAccount, authorizedPubkey, newAuthorized) {\n      var type = SystemInstructionLayout.AuthorizeNonceAccount;\n      var data = encodeData(type, {\n        newAuthorized: newAuthorized.toBuffer()\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: nonceAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"programId\",\n\n    /**\n     * Public key that identifies the System program\n     */\n    get: function get() {\n      return new PublicKey('0x000000000000000000000000000000000000000000000000000000000000000');\n    }\n    /**\n     * Max space of a Nonce account\n     */\n\n  }, {\n    key: \"nonceSpace\",\n    get: function get() {\n      return 68;\n    }\n  }]);\n\n  return SystemProgram;\n}();\n/**\n * Program loader interface\n */\n\n\nvar Loader = /*#__PURE__*/function () {\n  function Loader() {\n    _classCallCheck(this, Loader);\n  }\n\n  _createClass(Loader, null, [{\n    key: \"getMinNumSignatures\",\n\n    /**\n     * Minimum number of signatures required to load a program not including\n     * retries\n     *\n     * Can be used to calculate transaction fees\n     */\n    value: function getMinNumSignatures(dataLength) {\n      return Math.ceil(dataLength / Loader.chunkSize);\n    }\n    /**\n     * Loads a generic program\n     *\n     * @param connection The connection to use\n     * @param payer System account that pays to load the program\n     * @param program Account to load the program into\n     * @param programId Public key that identifies the loader\n     * @param data Program octets\n     */\n\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, payer, program, programId, data) {\n        var balanceNeeded, transaction, dataLayout, chunkSize, offset$1, array, transactions, bytes, _data, _transaction, _dataLayout, _data2, _transaction2;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return connection.getMinimumBalanceForRentExemption(data.length);\n\n              case 2:\n                balanceNeeded = _context.sent;\n                transaction = SystemProgram.createAccount(payer.publicKey, program.publicKey, balanceNeeded > 0 ? balanceNeeded : 1, data.length, programId);\n                _context.next = 6;\n                return sendAndConfirmTransaction(connection, transaction, payer, program);\n\n              case 6:\n                dataLayout = struct([u32('instruction'), u32('offset'), u32('bytesLength'), u32('bytesLengthPadding'), seq(u8('byte'), offset(u32(), -8), 'bytes')]);\n                chunkSize = Loader.chunkSize;\n                offset$1 = 0;\n                array = data;\n                transactions = [];\n\n              case 11:\n                if (!(array.length > 0)) {\n                  _context.next = 27;\n                  break;\n                }\n\n                bytes = array.slice(0, chunkSize);\n                _data = Buffer.alloc(chunkSize + 16);\n                dataLayout.encode({\n                  instruction: 0,\n                  // Load instruction\n                  offset: offset$1,\n                  bytes: bytes\n                }, _data);\n                _transaction = new Transaction().add({\n                  keys: [{\n                    pubkey: program.publicKey,\n                    isSigner: true,\n                    isWritable: true\n                  }],\n                  programId: programId,\n                  data: _data\n                });\n                transactions.push(sendAndConfirmTransaction(connection, _transaction, payer, program)); // Delay ~1 tick between write transactions in an attempt to reduce AccountInUse errors\n                // since all the write transactions modify the same program account\n\n                _context.next = 19;\n                return sleep(1000 / NUM_TICKS_PER_SECOND);\n\n              case 19:\n                if (!(transactions.length === 8)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                _context.next = 22;\n                return Promise.all(transactions);\n\n              case 22:\n                transactions = [];\n\n              case 23:\n                offset$1 += chunkSize;\n                array = array.slice(chunkSize);\n                _context.next = 11;\n                break;\n\n              case 27:\n                _context.next = 29;\n                return Promise.all(transactions);\n\n              case 29:\n                _dataLayout = struct([u32('instruction')]);\n                _data2 = Buffer.alloc(_dataLayout.span);\n\n                _dataLayout.encode({\n                  instruction: 1 // Finalize instruction\n\n                }, _data2);\n\n                _transaction2 = new Transaction().add({\n                  keys: [{\n                    pubkey: program.publicKey,\n                    isSigner: true,\n                    isWritable: true\n                  }, {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                  }],\n                  programId: programId,\n                  data: _data2\n                });\n                _context.next = 35;\n                return sendAndConfirmTransaction(connection, _transaction2, payer, program);\n\n              case 35:\n                return _context.abrupt(\"return\", program.publicKey);\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function load(_x, _x2, _x3, _x4, _x5) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"chunkSize\",\n\n    /**\n     * Amount of program data placed in each load Transaction\n     */\n    get: function get() {\n      // Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n      // rest of the Transaction fields\n      //\n      // TODO: replace 300 with a proper constant for the size of the other\n      // Transaction fields\n      return PACKET_DATA_SIZE - 300;\n    }\n  }]);\n\n  return Loader;\n}();\n/**\n * Factory class for transactions to interact with a program loader\n */\n\n\nvar BpfLoader = /*#__PURE__*/function () {\n  function BpfLoader() {\n    _classCallCheck(this, BpfLoader);\n  }\n\n  _createClass(BpfLoader, null, [{\n    key: \"getMinNumSignatures\",\n\n    /**\n     * Minimum number of signatures required to load a program not including\n     * retries\n     *\n     * Can be used to calculate transaction fees\n     */\n    value: function getMinNumSignatures(dataLength) {\n      return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n     * Load a BPF program\n     *\n     * @param connection The connection to use\n     * @param owner User account to load the program into\n     * @param elfBytes The entire ELF containing the BPF program\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(connection, payer, elf) {\n      var program = new Account();\n      return Loader.load(connection, payer, program, BpfLoader.programId, elf);\n    }\n  }, {\n    key: \"programId\",\n\n    /**\n     * Public key that identifies the BpfLoader\n     */\n    get: function get() {\n      return new PublicKey('BPFLoader1111111111111111111111111111111111');\n    }\n  }]);\n\n  return BpfLoader;\n}();\n/**\n * Represents a condition that is met by executing a `applySignature()`\n * transaction\n *\n * @typedef {Object} SignatureCondition\n * @property {string} type Must equal the string 'timestamp'\n * @property {PublicKey} from Public key from which `applySignature()` will be accepted from\n */\n\n/**\n * @private\n */\n\n\nfunction serializePayment(payment) {\n  var toData = payment.to.toBuffer();\n  var data = Buffer.alloc(8 + toData.length);\n  data.writeUInt32LE(payment.amount, 0);\n  toData.copy(data, 8);\n  return data;\n}\n/**\n * @private\n */\n\n\nfunction serializeDate(when) {\n  var data = Buffer.alloc(8 + 20);\n  data.writeUInt32LE(20, 0); // size of timestamp as u64\n\n  function iso(date) {\n    function pad(number) {\n      if (number < 10) {\n        return '0' + number;\n      }\n\n      return number;\n    }\n\n    return date.getUTCFullYear() + '-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate()) + 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + 'Z';\n  }\n\n  data.write(iso(when), 8);\n  return data;\n}\n/**\n * @private\n */\n\n\nfunction serializeCondition(condition) {\n  switch (condition.type) {\n    case 'timestamp':\n      {\n        var date = serializeDate(condition.when);\n        var from = condition.from.toBuffer();\n        var data = Buffer.alloc(4 + date.length + from.length);\n        data.writeUInt32LE(0, 0); // Condition enum = Timestamp\n\n        date.copy(data, 4);\n        from.copy(data, 4 + date.length);\n        return data;\n      }\n\n    case 'signature':\n      {\n        var _from = condition.from.toBuffer();\n\n        var _data = Buffer.alloc(4 + _from.length);\n\n        _data.writeUInt32LE(1, 0); // Condition enum = Signature\n\n\n        _from.copy(_data, 4);\n\n        return _data;\n      }\n\n    default:\n      throw new Error(\"Unknown condition type: \".concat(condition.type));\n  }\n}\n/**\n * Factory class for transactions to interact with the Budget program\n */\n\n\nvar BudgetProgram = /*#__PURE__*/function () {\n  function BudgetProgram() {\n    _classCallCheck(this, BudgetProgram);\n  }\n\n  _createClass(BudgetProgram, null, [{\n    key: \"timestampCondition\",\n\n    /**\n     * Creates a timestamp condition\n     */\n    value: function timestampCondition(from, when) {\n      return {\n        type: 'timestamp',\n        from: from,\n        when: when\n      };\n    }\n    /**\n     * Creates a signature condition\n     */\n\n  }, {\n    key: \"signatureCondition\",\n    value: function signatureCondition(from) {\n      return {\n        type: 'signature',\n        from: from\n      };\n    }\n    /**\n     * Generates a transaction that transfers lamports once any of the conditions are met\n     */\n\n  }, {\n    key: \"pay\",\n    value: function pay(from, program, to, amount) {\n      var data = Buffer.alloc(1024);\n      var pos = 0;\n      data.writeUInt32LE(0, pos); // NewBudget instruction\n\n      pos += 4;\n\n      for (var _len = arguments.length, conditions = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n        conditions[_key - 4] = arguments[_key];\n      }\n\n      switch (conditions.length) {\n        case 0:\n          {\n            data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n\n            pos += 4;\n            {\n              var payment = serializePayment({\n                amount: amount,\n                to: to\n              });\n              payment.copy(data, pos);\n              pos += payment.length;\n            }\n            var trimmedData = data.slice(0, pos);\n            var transaction = SystemProgram.createAccount(from, program, amount, trimmedData.length, this.programId);\n            return transaction.add({\n              keys: [{\n                pubkey: to,\n                isSigner: false,\n                isWritable: true\n              }, {\n                pubkey: program,\n                isSigner: false,\n                isWritable: true\n              }],\n              programId: this.programId,\n              data: trimmedData\n            });\n          }\n\n        case 1:\n          {\n            data.writeUInt32LE(1, pos); // BudgetExpr enum = After\n\n            pos += 4;\n            {\n              var condition = conditions[0];\n              var conditionData = serializeCondition(condition);\n              conditionData.copy(data, pos);\n              pos += conditionData.length;\n              data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n\n              pos += 4;\n              var paymentData = serializePayment({\n                amount: amount,\n                to: to\n              });\n              paymentData.copy(data, pos);\n              pos += paymentData.length;\n            }\n\n            var _trimmedData = data.slice(0, pos);\n\n            var _transaction = SystemProgram.createAccount(from, program, amount, _trimmedData.length, this.programId);\n\n            return _transaction.add({\n              keys: [{\n                pubkey: program,\n                isSigner: false,\n                isWritable: true\n              }],\n              programId: this.programId,\n              data: _trimmedData\n            });\n          }\n\n        case 2:\n          {\n            data.writeUInt32LE(2, pos); // BudgetExpr enum = Or\n\n            pos += 4;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = conditions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _condition = _step.value;\n\n                var _conditionData = serializeCondition(_condition);\n\n                _conditionData.copy(data, pos);\n\n                pos += _conditionData.length;\n                data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n\n                pos += 4;\n\n                var _paymentData = serializePayment({\n                  amount: amount,\n                  to: to\n                });\n\n                _paymentData.copy(data, pos);\n\n                pos += _paymentData.length;\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                  _iterator[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            var _trimmedData2 = data.slice(0, pos);\n\n            var _transaction2 = SystemProgram.createAccount(from, program, amount, _trimmedData2.length, this.programId);\n\n            return _transaction2.add({\n              keys: [{\n                pubkey: program,\n                isSigner: false,\n                isWritable: true\n              }],\n              programId: this.programId,\n              data: _trimmedData2\n            });\n          }\n\n        default:\n          throw new Error(\"A maximum of two conditions are supported: \".concat(conditions.length, \" provided\"));\n      }\n    }\n    /**\n     * Generates a transaction that transfers lamports once both conditions are met\n     */\n\n  }, {\n    key: \"payOnBoth\",\n    value: function payOnBoth(from, program, to, amount, condition1, condition2) {\n      var data = Buffer.alloc(1024);\n      var pos = 0;\n      data.writeUInt32LE(0, pos); // NewBudget instruction\n\n      pos += 4;\n      data.writeUInt32LE(3, pos); // BudgetExpr enum = And\n\n      pos += 4;\n\n      for (var _i = 0, _arr = [condition1, condition2]; _i < _arr.length; _i++) {\n        var condition = _arr[_i];\n        var conditionData = serializeCondition(condition);\n        conditionData.copy(data, pos);\n        pos += conditionData.length;\n      }\n\n      data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n\n      pos += 4;\n      var paymentData = serializePayment({\n        amount: amount,\n        to: to\n      });\n      paymentData.copy(data, pos);\n      pos += paymentData.length;\n      var trimmedData = data.slice(0, pos);\n      var transaction = SystemProgram.createAccount(from, program, amount, trimmedData.length, this.programId);\n      return transaction.add({\n        keys: [{\n          pubkey: program,\n          isSigner: false,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: trimmedData\n      });\n    }\n    /**\n     * Generates a transaction that applies a timestamp, which could enable a\n     * pending payment to proceed.\n     */\n\n  }, {\n    key: \"applyTimestamp\",\n    value: function applyTimestamp(from, program, to, when) {\n      var whenData = serializeDate(when);\n      var data = Buffer.alloc(4 + whenData.length);\n      data.writeUInt32LE(1, 0); // ApplyTimestamp instruction\n\n      whenData.copy(data, 4);\n      return new Transaction().add({\n        keys: [{\n          pubkey: from,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: program,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: to,\n          isSigner: false,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generates a transaction that applies a signature, which could enable a\n     * pending payment to proceed.\n     */\n\n  }, {\n    key: \"applySignature\",\n    value: function applySignature(from, program, to) {\n      var dataLayout = struct([u32('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 2 // ApplySignature instruction\n\n      }, data);\n      return new Transaction().add({\n        keys: [{\n          pubkey: from,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: program,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: to,\n          isSigner: false,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"programId\",\n\n    /**\n     * Public key that identifies the Budget program\n     */\n    get: function get() {\n      return new PublicKey('Budget1111111111111111111111111111111111111');\n    }\n    /**\n     * The amount of space this program requires\n     */\n\n  }, {\n    key: \"space\",\n    get: function get() {\n      return 128;\n    }\n  }]);\n\n  return BudgetProgram;\n}();\n\nvar STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');\n\nvar Authorized =\n/**\n * Create a new Authorized object\n */\nfunction Authorized(staker, withdrawer) {\n  _classCallCheck(this, Authorized);\n\n  _defineProperty(this, \"staker\", void 0);\n\n  _defineProperty(this, \"withdrawer\", void 0);\n\n  this.staker = staker;\n  this.withdrawer = withdrawer;\n};\n\nvar Lockup =\n/**\n * Create a new Lockup object\n */\nfunction Lockup(unixTimestamp, epoch, custodian) {\n  _classCallCheck(this, Lockup);\n\n  _defineProperty(this, \"unixTimestamp\", void 0);\n\n  _defineProperty(this, \"epoch\", void 0);\n\n  _defineProperty(this, \"custodian\", void 0);\n\n  this.unixTimestamp = unixTimestamp;\n  this.epoch = epoch;\n  this.custodian = custodian;\n};\n/**\n * Stake Instruction class\n */\n\n\nvar StakeInstruction = /*#__PURE__*/function (_TransactionInstructi) {\n  _inherits(StakeInstruction, _TransactionInstructi);\n  /**\n   * Type of StakeInstruction\n   */\n\n\n  function StakeInstruction(opts, type) {\n    var _this;\n\n    _classCallCheck(this, StakeInstruction);\n\n    if (opts && opts.programId && !opts.programId.equals(StakeProgram.programId)) {\n      throw new Error('programId incorrect; not a StakeInstruction');\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StakeInstruction).call(this, opts));\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    if (type) {\n      _this.type = type;\n    }\n\n    return _this;\n  }\n\n  _createClass(StakeInstruction, null, [{\n    key: \"from\",\n    value: function from(instruction) {\n      if (!instruction.programId.equals(StakeProgram.programId)) {\n        throw new Error('programId incorrect; not StakeProgram');\n      }\n\n      var instructionTypeLayout = u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n\n      for (var t in StakeInstructionLayout) {\n        if (StakeInstructionLayout[t].index == typeIndex) {\n          type = StakeInstructionLayout[t];\n        }\n      }\n\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a StakeInstruction');\n      }\n\n      return new StakeInstruction({\n        keys: instruction.keys,\n        programId: instruction.programId,\n        data: instruction.data\n      }, type);\n    }\n  }]);\n\n  return StakeInstruction;\n}(TransactionInstruction);\n/**\n * An enumeration of valid StakeInstructionTypes\n */\n\n\nvar StakeInstructionLayout = Object.freeze({\n  Initialize: {\n    index: 0,\n    layout: struct([u32('instruction'), authorized(), lockup()])\n  },\n  Authorize: {\n    index: 1,\n    layout: struct([u32('instruction'), publicKey('newAuthorized'), u32('stakeAuthorizationType')])\n  },\n  DelegateStake: {\n    index: 2,\n    layout: struct([u32('instruction')])\n  },\n  Split: {\n    index: 3,\n    layout: struct([u32('instruction'), ns64('lamports')])\n  },\n  Withdraw: {\n    index: 4,\n    layout: struct([u32('instruction'), ns64('lamports')])\n  },\n  Deactivate: {\n    index: 5,\n    layout: struct([u32('instruction')])\n  }\n});\n/**\n * @typedef {Object} StakeAuthorizationType\n * @property (index} The Stake Authorization index (from solana-stake-program)\n */\n\n/**\n * An enumeration of valid StakeInstructionTypes\n */\n\nvar StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */\n\nvar StakeProgram = /*#__PURE__*/function () {\n  function StakeProgram() {\n    _classCallCheck(this, StakeProgram);\n  }\n\n  _createClass(StakeProgram, null, [{\n    key: \"initialize\",\n\n    /**\n     * Generate an Initialize instruction to add to a Stake Create transaction\n     */\n    value: function initialize(stakeAccount, authorized, lockup) {\n      var type = StakeInstructionLayout.Initialize;\n      var data = encodeData(type, {\n        authorized: {\n          staker: authorized.staker.toBuffer(),\n          withdrawer: authorized.withdrawer.toBuffer()\n        },\n        lockup: {\n          unixTimestamp: lockup.unixTimestamp,\n          epoch: lockup.epoch,\n          custodian: lockup.custodian.toBuffer()\n        }\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: stakeAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a Transaction that creates a new Stake account at\n     *   an address generated with `from`, a seed, and the Stake programId\n     */\n\n  }, {\n    key: \"createAccountWithSeed\",\n    value: function createAccountWithSeed(from, stakeAccount, base, seed, authorized, lockup, lamports) {\n      var transaction = SystemProgram.createAccountWithSeed(from, stakeAccount, base, seed, lamports, this.space, this.programId);\n      return transaction.add(this.initialize(stakeAccount, authorized, lockup));\n    }\n    /**\n     * Generate a Transaction that creates a new Stake account\n     */\n\n  }, {\n    key: \"createAccount\",\n    value: function createAccount(from, stakeAccount, authorized, lockup, lamports) {\n      var transaction = SystemProgram.createAccount(from, stakeAccount, lamports, this.space, this.programId);\n      return transaction.add(this.initialize(stakeAccount, authorized, lockup));\n    }\n    /**\n     * Generate a Transaction that delegates Stake tokens to a validator\n     * Vote PublicKey. This transaction can also be used to redelegate Stake\n     * to a new validator Vote PublicKey.\n     */\n\n  }, {\n    key: \"delegate\",\n    value: function delegate(stakeAccount, authorizedPubkey, votePubkey) {\n      var type = StakeInstructionLayout.DelegateStake;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakeAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: STAKE_CONFIG_ID,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n\n  }, {\n    key: \"authorize\",\n    value: function authorize(stakeAccount, authorizedPubkey, newAuthorized, stakeAuthorizationType) {\n      var type = StakeInstructionLayout.Authorize;\n      var data = encodeData(type, {\n        newAuthorized: newAuthorized.toBuffer(),\n        stakeAuthorizationType: stakeAuthorizationType.index\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakeAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that splits Stake tokens into another stake account\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(stakeAccount, authorizedPubkey, lamports, splitStakePubkey) {\n      var transaction = SystemProgram.createAccount(stakeAccount, splitStakePubkey, 0, this.space, this.programId);\n      transaction.instructions[0].keys[0].isSigner = false;\n      var type = StakeInstructionLayout.Split;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      return transaction.add({\n        keys: [{\n          pubkey: stakeAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: splitStakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that withdraws deactivated Stake tokens.\n     */\n\n  }, {\n    key: \"withdraw\",\n    value: function withdraw(stakeAccount, withdrawerPubkey, to, lamports) {\n      var type = StakeInstructionLayout.Withdraw;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakeAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: to,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: withdrawerPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that deactivates Stake tokens.\n     */\n\n  }, {\n    key: \"deactivate\",\n    value: function deactivate(stakeAccount, authorizedPubkey) {\n      var type = StakeInstructionLayout.Deactivate;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakeAccount,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"programId\",\n\n    /**\n     * Public key that identifies the Stake program\n     */\n    get: function get() {\n      return new PublicKey('Stake11111111111111111111111111111111111111');\n    }\n    /**\n     * Max space of a Stake account\n     */\n\n  }, {\n    key: \"space\",\n    get: function get() {\n      return 4008;\n    }\n  }]);\n\n  return StakeProgram;\n}();\n\nvar VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');\n/**\n * @private\n */\n\nvar InfoString = struct$1({\n  name: 'string',\n  website: 'string?',\n  details: 'string?',\n  keybaseUsername: 'string?'\n});\n/**\n * ValidatorInfo class\n */\n\nvar ValidatorInfo = /*#__PURE__*/function () {\n  /**\n   * validator public key\n   */\n\n  /**\n   * validator information\n   */\n\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  function ValidatorInfo(key, info) {\n    _classCallCheck(this, ValidatorInfo);\n\n    _defineProperty(this, \"key\", void 0);\n\n    _defineProperty(this, \"info\", void 0);\n\n    this.key = key;\n    this.info = info;\n  }\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n\n\n  _createClass(ValidatorInfo, null, [{\n    key: \"fromConfigData\",\n    value: function fromConfigData(buffer) {\n      var PUBKEY_LENGTH = 32;\n\n      var byteArray = _toConsumableArray(buffer);\n\n      var configKeyCount = decodeLength(byteArray);\n      if (configKeyCount !== 2) return null;\n      var configKeys = [];\n\n      for (var i = 0; i < 2; i++) {\n        var publicKey = new PublicKey(byteArray.slice(0, PUBKEY_LENGTH));\n        byteArray = byteArray.slice(PUBKEY_LENGTH);\n        var isSigner = byteArray.slice(0, 1)[0] === 1;\n        byteArray = byteArray.slice(1);\n        configKeys.push({\n          publicKey: publicKey,\n          isSigner: isSigner\n        });\n      }\n\n      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n        if (configKeys[1].isSigner) {\n          var rawInfo = rustString().decode(Buffer.from(byteArray));\n          var info = InfoString(JSON.parse(rawInfo));\n          return new ValidatorInfo(configKeys[1].publicKey, info);\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return ValidatorInfo;\n}();\n\nvar VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @private\n */\n\nvar VoteAccountLayout = struct([publicKey('nodePubkey'), publicKey('authorizedVoterPubkey'), publicKey('authorizedWithdrawerPubkey'), u8('commission'), nu64(), // votes.length\nseq(struct([nu64('slot'), u32('confirmationCount')]), offset(u32(), -8), 'votes'), u8('rootSlotValid'), nu64('rootSlot'), nu64('epoch'), nu64('credits'), nu64('lastEpochCredits'), nu64(), // epochCredits.length\nseq(struct([nu64('epoch'), nu64('credits'), nu64('prevCredits')]), offset(u32(), -8), 'epochCredits')]);\n/**\n * VoteAccount class\n */\n\nvar VoteAccount = /*#__PURE__*/function () {\n  function VoteAccount() {\n    _classCallCheck(this, VoteAccount);\n\n    _defineProperty(this, \"nodePubkey\", void 0);\n\n    _defineProperty(this, \"authorizedVoterPubkey\", void 0);\n\n    _defineProperty(this, \"authorizedWithdrawerPubkey\", void 0);\n\n    _defineProperty(this, \"commission\", void 0);\n\n    _defineProperty(this, \"votes\", void 0);\n\n    _defineProperty(this, \"rootSlot\", void 0);\n\n    _defineProperty(this, \"epoch\", void 0);\n\n    _defineProperty(this, \"credits\", void 0);\n\n    _defineProperty(this, \"lastEpochCredits\", void 0);\n\n    _defineProperty(this, \"epochCredits\", void 0);\n  }\n\n  _createClass(VoteAccount, null, [{\n    key: \"fromAccountData\",\n\n    /**\n     * Deserialize VoteAccount from the account data.\n     *\n     * @param buffer account data\n     * @return VoteAccount\n     */\n    value: function fromAccountData(buffer) {\n      var va = VoteAccountLayout.decode(toBuffer(buffer), 0);\n      va.nodePubkey = new PublicKey(va.nodePubkey);\n      va.authorizedVoterPubkey = new PublicKey(va.authorizedVoterPubkey);\n      va.authorizedWithdrawerPubkey = new PublicKey(va.authorizedWithdrawerPubkey);\n\n      if (!va.rootSlotValid) {\n        va.rootSlot = null;\n      }\n\n      return va;\n    }\n  }]);\n\n  return VoteAccount;\n}();\n/**\n * Sign, send and confirm a raw transaction\n */\n\n\nfunction sendAndConfirmRawTransaction(_x, _x2, _x3) {\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\n\nfunction _sendAndConfirmRawTransaction() {\n  _sendAndConfirmRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, rawTransaction, commitment) {\n    var start, signature, status, statusRetries, duration;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            start = Date.now();\n            _context.next = 3;\n            return connection.sendRawTransaction(rawTransaction);\n\n          case 3:\n            signature = _context.sent; // Wait up to a couple slots for a confirmation\n\n            status = null;\n            statusRetries = 6;\n\n          case 6:\n            _context.next = 8;\n            return connection.getSignatureStatus(signature, commitment);\n\n          case 8:\n            status = _context.sent;\n\n            if (!status) {\n              _context.next = 11;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 18);\n\n          case 11:\n            _context.next = 13;\n            return sleep(500 * DEFAULT_TICKS_PER_SLOT / NUM_TICKS_PER_SECOND);\n\n          case 13:\n            if (!(--statusRetries <= 0)) {\n              _context.next = 16;\n              break;\n            }\n\n            duration = (Date.now() - start) / 1000;\n            throw new Error(\"Raw Transaction '\".concat(signature, \"' was not confirmed in \").concat(duration.toFixed(2), \" seconds (\").concat(JSON.stringify(status), \")\"));\n\n          case 16:\n            _context.next = 6;\n            break;\n\n          case 18:\n            if (!(status && 'Ok' in status)) {\n              _context.next = 20;\n              break;\n            }\n\n            return _context.abrupt(\"return\", signature);\n\n          case 20:\n            throw new Error(\"Raw transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\n\nvar testnetDefaultChannel = \"edge\";\n/**\n * @private\n */\n\nvar endpoint = {\n  http: {\n    edge: 'http://edge.testnet.solana.com:8899',\n    beta: 'http://beta.testnet.solana.com:8899',\n    stable: 'http://testnet.solana.com:8899'\n  },\n  https: {\n    edge: 'https://edge.testnet.solana.com:8443',\n    beta: 'https://beta.testnet.solana.com:8443',\n    stable: 'https://testnet.solana.com:8443'\n  }\n};\n/**\n * Retrieves the RPC endpoint URL for the specified testnet release\n * channel\n */\n\nfunction testnetChannelEndpoint(channel, tls) {\n  var key = tls === false ? 'http' : 'https';\n\n  if (!channel) {\n    return endpoint[key][testnetDefaultChannel];\n  }\n\n  var url = endpoint[key][channel];\n\n  if (!url) {\n    throw new Error(\"Unknown \".concat(key, \" channel: \").concat(channel));\n  }\n\n  return url;\n}\n\nvar LAMPORTS_PER_SOL = 1000000000;\nexport { Account, Authorized, BpfLoader, BudgetProgram, Connection, LAMPORTS_PER_SOL, Loader, Lockup, NonceAccount, PublicKey, STAKE_CONFIG_ID, SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, StakeAuthorizationLayout, StakeInstruction, StakeInstructionLayout, StakeProgram, SystemInstruction, SystemProgram, Transaction, TransactionInstruction, VALIDATOR_INFO_KEY, VOTE_PROGRAM_ID, ValidatorInfo, VoteAccount, sendAndConfirmRawTransaction, sendAndConfirmRecentTransaction, sendAndConfirmTransaction, testnetChannelEndpoint };","map":{"version":3,"mappings":"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","names":["toBuffer","arr","Buffer","Uint8Array","from","buffer","byteOffset","byteLength","PublicKey","value","startsWith","_bn","BN","substring","decoded","bs58","decode","length","Error","publicKey","eq","encode","b","toArrayLike","zeroPad","alloc","copy","toBase58","o","fromPublicKey","seed","programId","concat","hash","hasha","algorithm","Account","secretKey","_keypair","nacl","sign","keyPair","fromSecretKey","NUM_TICKS_PER_SECOND","DEFAULT_TICKS_PER_SLOT","property","BufferLayout","rustString","rsl","_decode","bind","_encode","offset","data","chars","toString","str","span","authorized","lockup","getAlloc","type","fields","layout","forEach","item","decodeLength","bytes","len","size","elem","shift","encodeLength","rem_len","push","DEFAULT_SIGNATURE","fill","PACKET_DATA_SIZE","PUBKEY_LENGTH","SIGNATURE_LENGTH","TransactionInstruction","opts","Object","assign","Transaction","signatures","signature","items","arguments","_this","instructions","nonceInfo","nonceInstruction","recentBlockhash","nonce","unshift","keys","map","numReadonlySignedAccounts","numReadonlyUnsignedAccounts","programIds","allKeys","instruction","keySignerPair","includes","sort","x","y","checkSigner","isSigner","checkWritable","isWritable","keyStr","pubkey","_this2","keyCount","shortvec","keyIndicesCount","dataCount","programIdIndex","indexOf","keyIndices","keyObj","dataLength","invariant","keyIndex","instructionCount","instructionBuffer","instructionBufferLength","instructionLayout","slice","signDataLayout","Layout","transaction","numRequiredSignatures","key","signData","signPartial","apply","partialSigners","accountOrPublicKey","_getSignData","index","detached","signer","findIndex","equals","sigpair","signatureCount","transactionLength","wireTransaction","byteArray","i","accountCount","accounts","account","programIndex","_populate","rpcResult","message","accountKeys","header","numKeys","sigPubkeyPair","instructionData","j","some","SYSVAR_CLOCK_PUBKEY","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","SYSVAR_RENT_PUBKEY","SYSVAR_REWARDS_PUBKEY","SYSVAR_STAKE_HISTORY_PUBKEY","NonceAccountLayout","NonceAccount","nonceAccount","authorizedPubkey","sleep","ms","Promise","setTimeout","resolve","jsonRpcResultAndContext","resultDescription","jsonRpcResult","context","struct","slot","jsonRpcVersion","literal","union","jsonrpc","id","error","result","GetInflationResult","foundation","foundationTerm","initial","storage","taper","terminal","GetEpochInfoResult","epoch","slotIndex","slotsInEpoch","absoluteSlot","GetEpochScheduleResult","slotsPerEpoch","leaderScheduleSlotOffset","warmup","firstNormalEpoch","firstNormalSlot","SignatureStatusResult","Ok","Err","Version","createRpcRequest","url","server","jayson","request","callback","options","method","body","headers","fetch","res","text","args","reject","err","response","GetInflationRpcResult","GetEpochInfoRpcResult","GetEpochScheduleRpcResult","GetBalanceAndContextRpcResult","GetVersionRpcResult","AccountInfoResult","executable","owner","lamports","rentEpoch","GetAccountInfoAndContextRpcResult","AccountNotificationResult","subscription","ProgramAccountInfoResult","ProgramAccountNotificationResult","SlotInfo","parent","root","SlotNotificationResult","SignatureNotificationResult","GetProgramAccountsRpcResult","array","ConfirmTransactionAndContextRpcResult","GetSlot","GetSlotLeader","GetClusterNodes","gossip","tpu","rpc","GetVoteAccounts","current","votePubkey","nodePubkey","activatedStake","epochVoteAccount","epochCredits","tuple","commission","lastVote","rootSlot","delinquent","GetSignatureStatusRpcResult","GetTransactionCountRpcResult","GetTotalSupplyRpcResult","GetMinimumBalanceForRentExemptionRpcResult","GetConfirmedBlockRpcResult","blockhash","previousBlockhash","parentSlot","transactions","meta","status","fee","preBalances","postBalances","rewards","GetRecentBlockhashAndContextRpcResult","feeCalculator","burnPercent","lamportsPerSignature","maxLamportsPerSignature","minLamportsPerSignature","targetLamportsPerSignature","targetSignaturesPerSlot","RequestAirdropRpcResult","SendTransactionRpcResult","Connection","endpoint","commitment","urlParse","_rpcRequest","href","_commitment","_blockhashInfo","seconds","transactionSignatures","protocol","host","port","String","Number","_rpcWebSocket","RpcWebSocketClient","urlFormat","autoconnect","max_reconnects","Infinity","on","_wsOnOpen","_wsOnError","_wsOnClose","_wsOnAccountNotification","_wsOnProgramAccountNotification","_wsOnSlotNotification","_wsOnSignatureNotification","_argsWithCommitment","unsafeRes","assert","getBalanceAndContext","then","e","getAccountInfoAndContext","confirmTransactionAndContext","console","warn","getRecentBlockhashAndContext","fromRpcResult","fromAccountData","getNonceAndContext","to","amount","signers","_args27","Date","getSeconds","_disableBlockhashCaching","attempts","startTime","now","getRecentBlockhash","serialize","sendRawTransaction","rawTransaction","encodedTransaction","sendEncodedTransaction","_rpcWebSocketConnected","_updateSubscriptions","log","code","sub","rpcMethod","rpcArgs","subscriptionId","call","_context31","unsubscribeId","_context32","_accountChangeSubscriptions","programKeys","_programAccountChangeSubscriptions","slotKeys","_slotSubscriptions","signatureKeys","_signatureSubscriptions","close","_step","_step2","_step3","_step4","connect","_step5","_subscribe","_step6","_step7","_step8","notification","_step9","_accountChangeSubscriptionCounter","subInfo","_unsubscribe","_step10","accountId","accountInfo","_programAccountChangeSubscriptionCounter","_step11","_slotSubscriptionCounter","override","_step12","_signatureSubscriptionCounter","sendAndConfirmRecentTransaction","connection","_args","_sendAndConfirmTransaction","sendAndConfirmTransaction","_args2","sendRetries","start","sendTransaction","statusRetries","getSignatureStatus","duration","toFixed","JSON","stringify","Math","random","undefined","encodeData","allocLength","layoutFields","SystemInstruction","SystemProgram","SystemInstructionLayout","Create","CreateWithSeed","WithdrawNonceAccount","Transfer","instructionTypeLayout","typeIndex","t","freeze","Assign","AdvanceNonceAccount","InitializeNonceAccount","AuthorizeNonceAccount","newAccount","space","add","base","createAccount","nonceSpace","newAuthorized","Loader","ceil","chunkSize","payer","program","getMinimumBalanceForRentExemption","balanceNeeded","dataLayout","all","BpfLoader","getMinNumSignatures","elf","load","serializePayment","payment","toData","writeUInt32LE","serializeDate","when","iso","date","pad","number","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","write","serializeCondition","condition","BudgetProgram","pos","conditions","trimmedData","conditionData","paymentData","condition1","condition2","_i","whenData","STAKE_CONFIG_ID","Authorized","staker","withdrawer","Lockup","unixTimestamp","custodian","StakeInstruction","StakeProgram","StakeInstructionLayout","Initialize","Authorize","DelegateStake","Split","Withdraw","Deactivate","StakeAuthorizationLayout","Staker","Withdrawer","stakeAccount","createAccountWithSeed","initialize","stakeAuthorizationType","splitStakePubkey","withdrawerPubkey","VALIDATOR_INFO_KEY","InfoString","name","website","details","keybaseUsername","ValidatorInfo","info","configKeyCount","configKeys","rawInfo","parse","VOTE_PROGRAM_ID","VoteAccountLayout","VoteAccount","va","authorizedVoterPubkey","authorizedWithdrawerPubkey","rootSlotValid","sendAndConfirmRawTransaction","http","edge","beta","stable","https","testnetChannelEndpoint","channel","tls","testnetDefaultChannel","LAMPORTS_PER_SOL"],"sources":["../src/util/to-buffer.js","../src/publickey.js","../src/account.js","../src/timing.js","../src/layout.js","../src/util/shortvec-encoding.js","../src/transaction.js","../src/sysvar.js","../src/nonce-account.js","../src/util/sleep.js","../src/connection.js","../src/util/send-and-confirm-transaction.js","../src/instruction.js","../src/system-program.js","../src/loader.js","../src/bpf-loader.js","../src/budget-program.js","../src/stake-program.js","../src/validator-info.js","../src/vote-account.js","../src/util/send-and-confirm-raw-transaction.js","../src/util/testnet.js","../src/index.js"],"sourcesContent":["// @flow\n\nexport const toBuffer = (arr: Buffer | Uint8Array | Array<number>): Buffer => {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n","// @flow\n\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport hasha from 'hasha';\n\n/**\n * A public key\n */\nexport class PublicKey {\n  _bn: BN;\n\n  /**\n   * Create a new PublicKey object\n   */\n  constructor(value: number | string | Buffer | Uint8Array | Array<number>) {\n    if (typeof value === 'string') {\n      // hexadecimal number\n      if (value.startsWith('0x')) {\n        this._bn = new BN(value.substring(2), 16);\n      } else {\n        // assume base 58 encoding by default\n        const decoded = bs58.decode(value);\n        if (decoded.length != 32) {\n          throw new Error(`Invalid public key input`);\n        }\n        this._bn = new BN(decoded);\n      }\n    } else {\n      this._bn = new BN(value);\n    }\n\n    if (this._bn.byteLength() > 32) {\n      throw new Error(`Invalid public key input`);\n    }\n  }\n\n  /**\n   * Checks if the provided object is a PublicKey\n   */\n  static isPublicKey(o: Object): boolean {\n    return o instanceof PublicKey;\n  }\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(publicKey: PublicKey): boolean {\n    return this._bn.eq(publicKey._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58(): string {\n    return bs58.encode(this.toBuffer());\n  }\n\n  /**\n   * Return the Buffer representation of the public key\n   */\n  toBuffer(): Buffer {\n    const b = this._bn.toArrayLike(Buffer);\n    if (b.length === 32) {\n      return b;\n    }\n\n    const zeroPad = Buffer.alloc(32);\n    b.copy(zeroPad, 32 - b.length);\n    return zeroPad;\n  }\n\n  /**\n   * Returns a string representation of the public key\n   */\n  toString(): string {\n    return this.toBase58();\n  }\n\n  /**\n   * Derive a public key from another key, a seed, and a programId.\n   */\n  static createWithSeed(\n    fromPublicKey: PublicKey,\n    seed: string,\n    programId: PublicKey,\n  ): PublicKey {\n    const buffer = Buffer.concat([\n      fromPublicKey.toBuffer(),\n      Buffer.from(seed),\n      programId.toBuffer(),\n    ]);\n    const hash = hasha(buffer, {algorithm: 'sha256'});\n    return new PublicKey('0x' + hash);\n  }\n}\n","// @flow\nimport nacl from 'tweetnacl';\nimport type {KeyPair} from 'tweetnacl';\n\nimport {toBuffer} from './util/to-buffer';\nimport {PublicKey} from './publickey';\n\n/**\n * An account key pair (public and secret keys).\n */\nexport class Account {\n  _keypair: KeyPair;\n\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  constructor(secretKey?: Buffer | Uint8Array | Array<number>) {\n    if (secretKey) {\n      this._keypair = nacl.sign.keyPair.fromSecretKey(toBuffer(secretKey));\n    } else {\n      this._keypair = nacl.sign.keyPair();\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  get publicKey(): PublicKey {\n    return new PublicKey(this._keypair.publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account\n   */\n  get secretKey(): Buffer {\n    return this._keypair.secretKey;\n  }\n}\n","// @flow\n\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @ignore\n */\nexport const NUM_TICKS_PER_SECOND = 10;\n\n/**\n * @ignore\n */\nexport const DEFAULT_TICKS_PER_SLOT = 8;\n","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string = 'publicKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string') => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  rsl.alloc = str => {\n    return (\n      BufferLayout.u32().span +\n      BufferLayout.u32().span +\n      Buffer.from(str, 'utf8').length\n    );\n  };\n\n  return rsl;\n};\n\n/**\n * Layout for an Authorized object\n */\nexport const authorized = (property: string = 'authorized') => {\n  return BufferLayout.struct(\n    [publicKey('staker'), publicKey('withdrawer')],\n    property,\n  );\n};\n\n/**\n * Layout for a Lockup object\n */\nexport const lockup = (property: string = 'lockup') => {\n  return BufferLayout.struct(\n    [\n      BufferLayout.ns64('unixTimestamp'),\n      BufferLayout.ns64('epoch'),\n      publicKey('custodian'),\n    ],\n    property,\n  );\n};\n\nexport function getAlloc(type: Object, fields: Object): number {\n  let alloc = 0;\n  type.layout.fields.forEach(item => {\n    if (item.span >= 0) {\n      alloc += item.span;\n    } else if (typeof item.alloc === 'function') {\n      alloc += item.alloc(fields[item.property]);\n    }\n  });\n  return alloc;\n}\n","// @flow\n\nexport function decodeLength(bytes: Array<number>): number {\n  let len = 0;\n  let size = 0;\n  for (;;) {\n    let elem = bytes.shift();\n    len |= (elem & 0x7f) << (size * 7);\n    size += 1;\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n  return len;\n}\n\nexport function encodeLength(bytes: Array<number>, len: number) {\n  let rem_len = len;\n  for (;;) {\n    let elem = rem_len & 0x7f;\n    rem_len >>= 7;\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n","// @flow\n\nimport invariant from 'assert';\nimport * as BufferLayout from 'buffer-layout';\nimport nacl from 'tweetnacl';\nimport bs58 from 'bs58';\n\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\nimport {Account} from './account';\nimport * as shortvec from './util/shortvec-encoding';\nimport type {Blockhash} from './blockhash';\n\n/**\n * @typedef {string} TransactionSignature\n */\nexport type TransactionSignature = string;\n\n/**\n * Default (empty) signature\n *\n * Signatures are 64 bytes in length\n */\nconst DEFAULT_SIGNATURE = Buffer.alloc(64).fill(0);\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nexport const PACKET_DATA_SIZE = 1280 - 40 - 8;\n\nconst PUBKEY_LENGTH = 32;\nconst SIGNATURE_LENGTH = 64;\n\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n *\n * @typedef {Object} TransactionInstructionCtorFields\n * @property {?Array<PublicKey>} keys\n * @property {?PublicKey} programId\n * @property {?Buffer} data\n */\nexport type TransactionInstructionCtorFields = {|\n  keys?: Array<{pubkey: PublicKey, isSigner: boolean, isWritable: boolean}>,\n  programId?: PublicKey,\n  data?: Buffer,\n|};\n\n/**\n * Transaction Instruction class\n */\nexport class TransactionInstruction {\n  /**\n   * Public keys to include in this transaction\n   * Boolean represents whether this pubkey needs to sign the transaction\n   */\n  keys: Array<{\n    pubkey: PublicKey,\n    isSigner: boolean,\n    isWritable: boolean,\n  }> = [];\n\n  /**\n   * Program Id to execute\n   */\n  programId: PublicKey;\n\n  /**\n   * Program input\n   */\n  data: Buffer = Buffer.alloc(0);\n\n  constructor(opts?: TransactionInstructionCtorFields) {\n    opts && Object.assign(this, opts);\n  }\n}\n\n/**\n * @private\n */\ntype SignaturePubkeyPair = {|\n  signature: Buffer | null,\n  publicKey: PublicKey,\n|};\n\n/**\n * List of Transaction object fields that may be initialized at construction\n *\n * @typedef {Object} TransactionCtorFields\n * @property (?recentBlockhash} A recent block hash\n * @property (?signatures} One or more signatures\n *\n */\ntype TransactionCtorFields = {|\n  recentBlockhash?: Blockhash | null,\n  nonceInfo?: NonceInformation | null,\n  signatures?: Array<SignaturePubkeyPair>,\n|};\n\n/**\n * NonceInformation to be used to build a Transaction.\n *\n * @typedef {Object} NonceInformation\n * @property {nonce} The current Nonce blockhash\n * @property {nonceInstruction} The AdvanceNonceAccount Instruction\n */\ntype NonceInformation = {|\n  nonce: Blockhash,\n  nonceInstruction: TransactionInstruction,\n|};\n\n/**\n * Transaction class\n */\nexport class Transaction {\n  /**\n   * Signatures for the transaction.  Typically created by invoking the\n   * `sign()` method\n   */\n  signatures: Array<SignaturePubkeyPair> = [];\n\n  /**\n   * The first (payer) Transaction signature\n   */\n  get signature(): Buffer | null {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The instructions to atomically execute\n   */\n  instructions: Array<TransactionInstruction> = [];\n\n  /**\n   * A recent transaction id.  Must be populated by the caller\n   */\n  recentBlockhash: Blockhash | null;\n\n  /**\n   * Optional Nonce information. If populated, transaction will use a durable\n   * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n   */\n  nonceInfo: NonceInformation | null;\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(opts?: TransactionCtorFields) {\n    opts && Object.assign(this, opts);\n  }\n\n  /**\n   * Add one or more instructions to this Transaction\n   */\n  add(\n    ...items: Array<\n      Transaction | TransactionInstruction | TransactionInstructionCtorFields,\n    >\n  ): Transaction {\n    if (items.length === 0) {\n      throw new Error('No instructions');\n    }\n\n    items.forEach(item => {\n      if (item instanceof Transaction) {\n        this.instructions = this.instructions.concat(item.instructions);\n      } else if (item instanceof TransactionInstruction) {\n        this.instructions.push(item);\n      } else {\n        this.instructions.push(new TransactionInstruction(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _getSignData(): Buffer {\n    const {nonceInfo} = this;\n    if (nonceInfo && this.instructions[0] != nonceInfo.nonceInstruction) {\n      this.recentBlockhash = nonceInfo.nonce;\n      this.instructions.unshift(nonceInfo.nonceInstruction);\n    }\n    const {recentBlockhash} = this;\n    if (!recentBlockhash) {\n      throw new Error('Transaction recentBlockhash required');\n    }\n\n    if (this.instructions.length < 1) {\n      throw new Error('No instructions provided');\n    }\n\n    const keys = this.signatures.map(({publicKey}) => publicKey.toString());\n    let numReadonlySignedAccounts = 0;\n    let numReadonlyUnsignedAccounts = 0;\n\n    const programIds = [];\n\n    const allKeys = [];\n    this.instructions.forEach(instruction => {\n      instruction.keys.forEach(keySignerPair => {\n        allKeys.push(keySignerPair);\n      });\n\n      const programId = instruction.programId.toString();\n      if (!programIds.includes(programId)) {\n        programIds.push(programId);\n      }\n    });\n\n    allKeys.sort(function(x, y) {\n      const checkSigner = x.isSigner === y.isSigner ? 0 : x.isSigner ? -1 : 1;\n      const checkWritable =\n        x.isWritable === y.isWritable ? 0 : x.isWritable ? -1 : 1;\n      return checkSigner || checkWritable;\n    });\n\n    allKeys.forEach(keySignerPair => {\n      const keyStr = keySignerPair.pubkey.toString();\n      if (!keys.includes(keyStr)) {\n        if (keySignerPair.isSigner) {\n          this.signatures.push({\n            signature: null,\n            publicKey: keySignerPair.pubkey,\n          });\n          if (!keySignerPair.isWritable) {\n            numReadonlySignedAccounts += 1;\n          }\n        } else {\n          if (!keySignerPair.isWritable) {\n            numReadonlyUnsignedAccounts += 1;\n          }\n        }\n        keys.push(keyStr);\n      }\n    });\n\n    programIds.forEach(programId => {\n      if (!keys.includes(programId)) {\n        keys.push(programId);\n        numReadonlyUnsignedAccounts += 1;\n      }\n    });\n\n    let keyCount = [];\n    shortvec.encodeLength(keyCount, keys.length);\n\n    const instructions = this.instructions.map(instruction => {\n      const {data, programId} = instruction;\n      let keyIndicesCount = [];\n      shortvec.encodeLength(keyIndicesCount, instruction.keys.length);\n      let dataCount = [];\n      shortvec.encodeLength(dataCount, instruction.data.length);\n      return {\n        programIdIndex: keys.indexOf(programId.toString()),\n        keyIndicesCount: Buffer.from(keyIndicesCount),\n        keyIndices: Buffer.from(\n          instruction.keys.map(keyObj =>\n            keys.indexOf(keyObj.pubkey.toString()),\n          ),\n        ),\n        dataLength: Buffer.from(dataCount),\n        data,\n      };\n    });\n\n    instructions.forEach(instruction => {\n      invariant(instruction.programIdIndex >= 0);\n      instruction.keyIndices.forEach(keyIndex => invariant(keyIndex >= 0));\n    });\n\n    let instructionCount = [];\n    shortvec.encodeLength(instructionCount, instructions.length);\n    let instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);\n    Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n\n    instructions.forEach(instruction => {\n      const instructionLayout = BufferLayout.struct([\n        BufferLayout.u8('programIdIndex'),\n\n        BufferLayout.blob(\n          instruction.keyIndicesCount.length,\n          'keyIndicesCount',\n        ),\n        BufferLayout.seq(\n          BufferLayout.u8('keyIndex'),\n          instruction.keyIndices.length,\n          'keyIndices',\n        ),\n        BufferLayout.blob(instruction.dataLength.length, 'dataLength'),\n        BufferLayout.seq(\n          BufferLayout.u8('userdatum'),\n          instruction.data.length,\n          'data',\n        ),\n      ]);\n      const length = instructionLayout.encode(\n        instruction,\n        instructionBuffer,\n        instructionBufferLength,\n      );\n      instructionBufferLength += length;\n    });\n    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n\n    const signDataLayout = BufferLayout.struct([\n      BufferLayout.blob(1, 'numRequiredSignatures'),\n      BufferLayout.blob(1, 'numReadonlySignedAccounts'),\n      BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'),\n      BufferLayout.blob(keyCount.length, 'keyCount'),\n      BufferLayout.seq(Layout.publicKey('key'), keys.length, 'keys'),\n      Layout.publicKey('recentBlockhash'),\n    ]);\n\n    const transaction = {\n      numRequiredSignatures: Buffer.from([this.signatures.length]),\n      numReadonlySignedAccounts: Buffer.from([numReadonlySignedAccounts]),\n      numReadonlyUnsignedAccounts: Buffer.from([numReadonlyUnsignedAccounts]),\n      keyCount: Buffer.from(keyCount),\n      keys: keys.map(key => new PublicKey(key).toBuffer()),\n      recentBlockhash: Buffer.from(bs58.decode(recentBlockhash)),\n    };\n\n    let signData = Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    signData = signData.slice(0, length + instructionBuffer.length);\n\n    return signData;\n  }\n\n  /**\n   * Sign the Transaction with the specified accounts.  Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used when testing for Transaction confirmation.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   */\n  sign(...signers: Array<Account>) {\n    this.signPartial(...signers);\n  }\n\n  /**\n   * Partially sign a Transaction with the specified accounts.  The `Account`\n   * inputs will be used to sign the Transaction immediately, while any\n   * `PublicKey` inputs will be referenced in the signed Transaction but need to\n   * be filled in later by calling `addSigner()` with the matching `Account`.\n   *\n   * All the caveats from the `sign` method apply to `signPartial`\n   */\n  signPartial(...partialSigners: Array<PublicKey | Account>) {\n    if (partialSigners.length === 0) {\n      throw new Error('No signers');\n    }\n    const signatures: Array<SignaturePubkeyPair> = partialSigners.map(\n      accountOrPublicKey => {\n        const publicKey =\n          accountOrPublicKey instanceof Account\n            ? accountOrPublicKey.publicKey\n            : accountOrPublicKey;\n        return {\n          signature: null,\n          publicKey,\n        };\n      },\n    );\n    this.signatures = signatures;\n    const signData = this._getSignData();\n\n    partialSigners.forEach((accountOrPublicKey, index) => {\n      if (accountOrPublicKey instanceof PublicKey) {\n        return;\n      }\n      const signature = nacl.sign.detached(\n        signData,\n        accountOrPublicKey.secretKey,\n      );\n      invariant(signature.length === 64);\n      signatures[index].signature = Buffer.from(signature);\n    });\n  }\n\n  /**\n   * Fill in a signature for a partially signed Transaction.  The `signer` must\n   * be the corresponding `Account` for a `PublicKey` that was previously provided to\n   * `signPartial`\n   */\n  addSigner(signer: Account) {\n    const index = this.signatures.findIndex(sigpair =>\n      signer.publicKey.equals(sigpair.publicKey),\n    );\n    if (index < 0) {\n      throw new Error(`Unknown signer: ${signer.publicKey.toString()}`);\n    }\n\n    const signData = this._getSignData();\n    const signature = nacl.sign.detached(signData, signer.secretKey);\n    invariant(signature.length === 64);\n    this.signatures[index].signature = Buffer.from(signature);\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * The Transaction must have a valid `signature` before invoking this method\n   */\n  serialize(): Buffer {\n    const {signatures} = this;\n    if (!signatures) {\n      throw new Error('Transaction has not been signed');\n    }\n\n    const signData = this._getSignData();\n    const signatureCount = [];\n    shortvec.encodeLength(signatureCount, signatures.length);\n    const transactionLength =\n      signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = Buffer.alloc(transactionLength);\n    invariant(signatures.length < 256);\n    Buffer.from(signatureCount).copy(wireTransaction, 0);\n    signatures.forEach(({signature}, index) => {\n      if (signature !== null) {\n        invariant(signature.length === 64, `signature has invalid length`);\n        Buffer.from(signature).copy(\n          wireTransaction,\n          signatureCount.length + index * 64,\n        );\n      }\n    });\n    signData.copy(\n      wireTransaction,\n      signatureCount.length + signatures.length * 64,\n    );\n    invariant(\n      wireTransaction.length <= PACKET_DATA_SIZE,\n      `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`,\n    );\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get keys(): Array<PublicKey> {\n    invariant(this.instructions.length === 1);\n    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get programId(): PublicKey {\n    invariant(this.instructions.length === 1);\n    return this.instructions[0].programId;\n  }\n\n  /**\n   * Deprecated method\n   * @private\n   */\n  get data(): Buffer {\n    invariant(this.instructions.length === 1);\n    return this.instructions[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   */\n  static from(buffer: Buffer | Uint8Array | Array<number>): Transaction {\n    // Slice up wire data\n    let byteArray = [...buffer];\n\n    const signatureCount = shortvec.decodeLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = byteArray.slice(0, SIGNATURE_LENGTH);\n      byteArray = byteArray.slice(SIGNATURE_LENGTH);\n      signatures.push(bs58.encode(Buffer.from(signature)));\n    }\n\n    const numRequiredSignatures = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numRequiredSignatures byte\n    const numReadonlySignedAccounts = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numReadonlySignedAccounts byte\n    const numReadonlyUnsignedAccounts = byteArray.shift();\n    // byteArray = byteArray.slice(1); // Skip numReadonlyUnsignedAccounts byte\n\n    const accountCount = shortvec.decodeLength(byteArray);\n    let accounts = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = byteArray.slice(0, PUBKEY_LENGTH);\n      byteArray = byteArray.slice(PUBKEY_LENGTH);\n      accounts.push(bs58.encode(Buffer.from(account)));\n    }\n\n    const recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);\n    byteArray = byteArray.slice(PUBKEY_LENGTH);\n\n    const instructionCount = shortvec.decodeLength(byteArray);\n    let instructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      let instruction = {};\n      instruction.programIndex = byteArray.shift();\n      const accountCount = shortvec.decodeLength(byteArray);\n      instruction.accounts = byteArray.slice(0, accountCount);\n      byteArray = byteArray.slice(accountCount);\n      const dataLength = shortvec.decodeLength(byteArray);\n      const data = byteArray.slice(0, dataLength);\n      instruction.data = bs58.encode(Buffer.from(data));\n      byteArray = byteArray.slice(dataLength);\n      instructions.push(instruction);\n    }\n\n    return Transaction._populate(\n      signatures,\n      accounts,\n      instructions,\n      recentBlockhash,\n      numRequiredSignatures,\n      numReadonlySignedAccounts,\n      numReadonlyUnsignedAccounts,\n    );\n  }\n\n  /**\n   * Parse an RPC result into a Transaction object.\n   */\n  static fromRpcResult(rpcResult: any): Transaction {\n    const signatures = rpcResult.signatures;\n    const accounts = rpcResult.message.accountKeys;\n    const instructions = rpcResult.message.instructions;\n    const recentBlockhash = rpcResult.message.recentBlockhash;\n    const numRequiredSignatures =\n      rpcResult.message.header.numRequiredSignatures;\n    const numReadonlySignedAccounts =\n      rpcResult.message.header.numReadonlySignedAccounts;\n    const numReadonlyUnsignedAccounts =\n      rpcResult.message.header.numReadonlyUnsignedAccounts;\n    return Transaction._populate(\n      signatures,\n      accounts,\n      instructions,\n      recentBlockhash,\n      numRequiredSignatures,\n      numReadonlySignedAccounts,\n      numReadonlyUnsignedAccounts,\n    );\n  }\n\n  /**\n   * Populate Transaction object\n   * @private\n   */\n  static _populate(\n    signatures: Array<string>,\n    accounts: Array<string>,\n    instructions: Array<any>,\n    recentBlockhash: Array<number>,\n    numRequiredSignatures: number,\n    numReadonlySignedAccounts: number,\n    numReadonlyUnsignedAccounts: number,\n  ): Transaction {\n    function isWritable(\n      i: number,\n      numRequiredSignatures: number,\n      numReadonlySignedAccounts: number,\n      numReadonlyUnsignedAccounts: number,\n      numKeys: number,\n    ): boolean {\n      return (\n        i < numRequiredSignatures - numReadonlySignedAccounts ||\n        (i >= numRequiredSignatures &&\n          i < numKeys - numReadonlyUnsignedAccounts)\n      );\n    }\n\n    const transaction = new Transaction();\n    transaction.recentBlockhash = new PublicKey(recentBlockhash).toBase58();\n    for (let i = 0; i < signatures.length; i++) {\n      const sigPubkeyPair = {\n        signature:\n          signatures[i] == bs58.encode(DEFAULT_SIGNATURE)\n            ? null\n            : bs58.decode(signatures[i]),\n        publicKey: new PublicKey(accounts[i]),\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    }\n    for (let i = 0; i < instructions.length; i++) {\n      let instructionData = {\n        keys: [],\n        programId: new PublicKey(accounts[instructions[i].programIndex]),\n        data: bs58.decode(instructions[i].data),\n      };\n      for (let j = 0; j < instructions[i].accounts.length; j++) {\n        const pubkey = new PublicKey(accounts[instructions[i].accounts[j]]);\n\n        instructionData.keys.push({\n          pubkey,\n          isSigner: transaction.signatures.some(\n            keyObj => keyObj.publicKey.toString() === pubkey.toString(),\n          ),\n          isWritable: isWritable(\n            j,\n            numRequiredSignatures,\n            numReadonlySignedAccounts,\n            numReadonlyUnsignedAccounts,\n            accounts.length,\n          ),\n        });\n      }\n      let instruction = new TransactionInstruction(instructionData);\n      transaction.instructions.push(instruction);\n    }\n    return transaction;\n  }\n}\n","// @flow\nimport {PublicKey} from './publickey';\n\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey(\n  'SysvarC1ock11111111111111111111111111111111',\n);\n\nexport const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\n  'SysvarRecentB1ockHashes11111111111111111111',\n);\n\nexport const SYSVAR_RENT_PUBKEY = new PublicKey(\n  'SysvarRent111111111111111111111111111111111',\n);\n\nexport const SYSVAR_REWARDS_PUBKEY = new PublicKey(\n  'SysvarRewards111111111111111111111111111111',\n);\n\nexport const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\n  'SysvarStakeHistory1111111111111111111111111',\n);\n","// @flow\nimport * as BufferLayout from 'buffer-layout';\n\nimport type {Blockhash} from './blockhash';\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @private\n */\nconst NonceAccountLayout = BufferLayout.struct([\n  BufferLayout.u32('state'),\n  Layout.publicKey('authorizedPubkey'),\n  Layout.publicKey('nonce'),\n]);\n\n/**\n * NonceAccount class\n */\nexport class NonceAccount {\n  authorizedPubkey: PublicKey;\n  nonce: Blockhash;\n\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n  static fromAccountData(buffer: Buffer): NonceAccount {\n    const nonceAccount = NonceAccountLayout.decode(buffer, 0);\n    nonceAccount.authorizedPubkey = new PublicKey(\n      nonceAccount.authorizedPubkey,\n    );\n    nonceAccount.nonce = new PublicKey(nonceAccount.nonce).toString();\n    return nonceAccount;\n  }\n}\n","// @flow\n\n// zzz\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","// @flow\n\nimport assert from 'assert';\nimport bs58 from 'bs58';\nimport {parse as urlParse, format as urlFormat} from 'url';\nimport fetch from 'node-fetch';\nimport jayson from 'jayson/lib/client/browser';\nimport {struct} from 'superstruct';\nimport {Client as RpcWebSocketClient} from 'rpc-websockets';\n\nimport {NonceAccount} from './nonce-account';\nimport {PublicKey} from './publickey';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SECOND} from './timing';\nimport {Transaction} from './transaction';\nimport {sleep} from './util/sleep';\nimport {toBuffer} from './util/to-buffer';\nimport type {Blockhash} from './blockhash';\nimport type {FeeCalculator} from './fee-calculator';\nimport type {Account} from './account';\nimport type {TransactionSignature} from './transaction';\n\ntype RpcRequest = (methodName: string, args: Array<any>) => any;\n\ntype RpcResponseAndContext<T> = {\n  context: {\n    slot: number,\n  },\n  value: T,\n};\n\n/**\n * @private\n */\nfunction jsonRpcResultAndContext(resultDescription: any) {\n  return jsonRpcResult({\n    context: struct({\n      slot: 'number',\n    }),\n    value: resultDescription,\n  });\n}\n\n/**\n * @private\n */\nfunction jsonRpcResult(resultDescription: any) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'any',\n    }),\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'null?',\n      result: resultDescription,\n    }),\n  ]);\n}\n\n/**\n * The level of commitment desired when querying state\n *   'max':    Query the most recent block which has reached max voter lockout\n *   'recent': Query the most recent block\n *\n * @typedef {'max' | 'recent'} Commitment\n */\nexport type Commitment = 'max' | 'recent';\n\n/**\n * Information describing a cluster node\n *\n * @typedef {Object} ContactInfo\n * @property {string} pubkey Identity public key of the node\n * @property {string} gossip Gossip network address for the node\n * @property {string} tpu TPU network address for the node (null if not available)\n * @property {string|null} rpc JSON RPC network address for the node (null if not available)\n */\ntype ContactInfo = {\n  pubkey: string,\n  gossip: string,\n  tpu: string | null,\n  rpc: string | null,\n};\n\n/**\n * Information describing a vote account\n *\n * @typedef {Object} VoteAccountInfo\n * @property {string} votePubkey Public key of the vote account\n * @property {string} nodePubkey Identity public key of the node voting with this account\n * @property {number} activatedStake The stake, in lamports, delegated to this vote account and activated\n * @property {boolean} epochVoteAccount Whether the vote account is staked for this epoch\n * @property {Array<Array<number>>} epochCredits Recent epoch voting credit history for this voter\n * @property {number} commission A percentage (0-100) of rewards payout owed to the voter\n * @property {number} lastVote Most recent slot voted on by this vote account\n */\ntype VoteAccountInfo = {\n  votePubkey: string,\n  nodePubkey: string,\n  activatedStake: number,\n  epochVoteAccount: boolean,\n  epochCredits: Array<[number, number, number]>,\n  commission: number,\n  lastVote: number,\n};\n\n/**\n * A collection of cluster vote accounts\n *\n * @typedef {Object} VoteAccountStatus\n * @property {Array<VoteAccountInfo>} current Active vote accounts\n * @property {Array<VoteAccountInfo>} delinquent Inactive vote accounts\n */\ntype VoteAccountStatus = {\n  current: Array<VoteAccountInfo>,\n  delinquent: Array<VoteAccountInfo>,\n};\n\n/**\n * Network Inflation parameters\n * (see https://docs.solana.com/book/v/master/implemented-proposals/ed_overview)\n *\n * @typedef {Object} Inflation\n * @property {number} foundation\n * @property {number} foundation_term\n * @property {number} initial\n * @property {number} storage\n * @property {number} taper\n * @property {number} terminal\n */\nconst GetInflationResult = struct({\n  foundation: 'number',\n  foundationTerm: 'number',\n  initial: 'number',\n  storage: 'number',\n  taper: 'number',\n  terminal: 'number',\n});\n\n/**\n * EpochInfo parameters\n * (see https://docs.solana.com/book/v/master/terminology#epoch)\n *\n * @typedef {Object} EpochInfo\n * @property {number} epoch\n * @property {number} slotIndex\n * @property {number} slotsInEpoch\n * @property {number} absoluteSlot\n */\nconst GetEpochInfoResult = struct({\n  epoch: 'number',\n  slotIndex: 'number',\n  slotsInEpoch: 'number',\n  absoluteSlot: 'number',\n});\n\n/**\n * EpochSchedule parameters\n * (see https://docs.solana.com/book/v/master/terminology#epoch)\n *\n * @typedef {Object} EpochSchedule\n * @property {number} slots_per_epoch\n * @property {number} leader_schedule_slot_offset\n * @property {boolean} warmup\n * @property {number} first_normal_epoch\n * @property {number} first_normal_slot\n */\nconst GetEpochScheduleResult = struct({\n  slotsPerEpoch: 'number',\n  leaderScheduleSlotOffset: 'number',\n  warmup: 'boolean',\n  firstNormalEpoch: 'number',\n  firstNormalSlot: 'number',\n});\n\n/**\n * Signature status for a transaction\n */\nconst SignatureStatusResult = struct.union([\n  struct({Ok: 'null'}),\n  struct({Err: 'object'}),\n]);\n\n/**\n * Version info for a node\n *\n * @typedef {Object} Version\n * @property {string} solana-core Version of solana-core\n */\nconst Version = struct({\n  'solana-core': 'string',\n});\n\n/**\n * A ConfirmedBlock on the ledger\n *\n * @typedef {Object} ConfirmedBlock\n * @property {Blockhash} blockhash Blockhash of this block\n * @property {Blockhash} previousBlockhash Blockhash of this block's parent\n * @property {number} parentSlot Slot index of this block's parent\n * @property {Array<object>} transactions Vector of transactions and status metas\n * @property {Array<object>} rewards Vector of block rewards\n */\ntype ConfirmedBlock = {\n  blockhash: Blockhash,\n  previousBlockhash: Blockhash,\n  parentSlot: number,\n  transactions: Array<{\n    transaction: Transaction,\n    meta: {\n      fee: number,\n      preBalances: Array<number>,\n      postBalances: Array<number>,\n      status?: SignatureStatusResult,\n    },\n  }>,\n  rewards: Array<{\n    pubkey: string,\n    lamports: number,\n  }>,\n};\n\nfunction createRpcRequest(url): RpcRequest {\n  const server = jayson(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    try {\n      const res = await fetch(url, options);\n      const text = await res.text();\n      callback(null, text);\n    } catch (err) {\n      callback(err);\n    }\n  });\n\n  return (method, args) => {\n    return new Promise((resolve, reject) => {\n      server.request(method, args, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/**\n * Expected JSON RPC response for the \"getInflation\" message\n */\nconst GetInflationRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: GetInflationResult,\n});\n\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\nconst GetEpochInfoRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: GetEpochInfoResult,\n});\n\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\nconst GetEpochScheduleRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: GetEpochScheduleResult,\n});\n\n/**\n * Expected JSON RPC response for the \"getBalance\" message\n */\nconst GetBalanceAndContextRpcResult = jsonRpcResultAndContext('number?');\n\n/**\n * Expected JSON RPC response for the \"getVersion\" message\n */\nconst GetVersionRpcResult = struct({\n  jsonrpc: struct.literal('2.0'),\n  id: 'string',\n  error: 'any?',\n  result: Version,\n});\n\n/**\n * @private\n */\nconst AccountInfoResult = struct({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'string',\n  rentEpoch: 'number?',\n});\n\n/**\n * Expected JSON RPC response for the \"getAccountInfo\" message\n */\nconst GetAccountInfoAndContextRpcResult = jsonRpcResultAndContext(\n  struct.union(['null', AccountInfoResult]),\n);\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNotificationResult = struct({\n  subscription: 'number',\n  result: AccountInfoResult,\n});\n\n/**\n * @private\n */\nconst ProgramAccountInfoResult = struct({\n  pubkey: 'string',\n  account: AccountInfoResult,\n});\n\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\nconst ProgramAccountNotificationResult = struct({\n  subscription: 'number',\n  result: ProgramAccountInfoResult,\n});\n\n/**\n * @private\n */\nconst SlotInfo = struct({\n  parent: 'number',\n  slot: 'number',\n  root: 'number',\n});\n\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\nconst SlotNotificationResult = struct({\n  subscription: 'number',\n  result: SlotInfo,\n});\n\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\nconst SignatureNotificationResult = struct({\n  subscription: 'number',\n  result: SignatureStatusResult,\n});\n\n/**\n * Expected JSON RPC response for the \"getProgramAccounts\" message\n */\nconst GetProgramAccountsRpcResult = jsonRpcResult(\n  struct.array([ProgramAccountInfoResult]),\n);\n\n/**\n * Expected JSON RPC response for the \"confirmTransaction\" message\n */\nconst ConfirmTransactionAndContextRpcResult = jsonRpcResultAndContext(\n  'boolean',\n);\n\n/**\n * Expected JSON RPC response for the \"getSlot\" message\n */\nconst GetSlot = jsonRpcResult('number');\n\n/**\n * Expected JSON RPC response for the \"getSlotLeader\" message\n */\nconst GetSlotLeader = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"getClusterNodes\" message\n */\nconst GetClusterNodes = jsonRpcResult(\n  struct.array([\n    struct({\n      pubkey: 'string',\n      gossip: 'string',\n      tpu: struct.union(['null', 'string']),\n      rpc: struct.union(['null', 'string']),\n    }),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\nconst GetVoteAccounts = jsonRpcResult(\n  struct({\n    current: struct.array([\n      struct({\n        votePubkey: 'string',\n        nodePubkey: 'string',\n        activatedStake: 'number',\n        epochVoteAccount: 'boolean',\n        epochCredits: struct.array([\n          struct.tuple(['number', 'number', 'number']),\n        ]),\n        commission: 'number',\n        lastVote: 'number',\n        rootSlot: 'number?',\n      }),\n    ]),\n    delinquent: struct.array([\n      struct({\n        votePubkey: 'string',\n        nodePubkey: 'string',\n        activatedStake: 'number',\n        epochVoteAccount: 'boolean',\n        epochCredits: struct.array([\n          struct.tuple(['number', 'number', 'number']),\n        ]),\n        commission: 'number',\n        lastVote: 'number',\n        rootSlot: 'number?',\n      }),\n    ]),\n  }),\n);\n\n/**\n * Expected JSON RPC response for the \"getSignatureStatus\" message\n */\nconst GetSignatureStatusRpcResult = jsonRpcResult(\n  struct.union(['null', SignatureStatusResult]),\n);\n\n/**\n * Expected JSON RPC response for the \"getTransactionCount\" message\n */\nconst GetTransactionCountRpcResult = jsonRpcResult('number');\n\n/**\n * Expected JSON RPC response for the \"getTotalSupply\" message\n */\nconst GetTotalSupplyRpcResult = jsonRpcResult('number');\n\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\nconst GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult('number');\n\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n */\nexport const GetConfirmedBlockRpcResult = jsonRpcResult(\n  struct.union([\n    'null',\n    struct({\n      blockhash: 'string',\n      previousBlockhash: 'string',\n      parentSlot: 'number',\n      transactions: struct.array([\n        struct({\n          transaction: struct({\n            signatures: struct.array(['string']),\n            message: struct({\n              accountKeys: struct.array(['string']),\n              header: struct({\n                numRequiredSignatures: 'number',\n                numReadonlySignedAccounts: 'number',\n                numReadonlyUnsignedAccounts: 'number',\n              }),\n              instructions: struct.array([\n                struct.union([\n                  struct.array(['number']),\n                  struct({\n                    accounts: struct.array(['number']),\n                    data: 'string',\n                    programIdIndex: 'number',\n                  }),\n                ]),\n              ]),\n              recentBlockhash: 'string',\n            }),\n          }),\n          meta: struct.union([\n            'null',\n            struct({\n              status: struct.union(['null', SignatureStatusResult]),\n              fee: 'number',\n              preBalances: struct.array(['number']),\n              postBalances: struct.array(['number']),\n            }),\n          ]),\n        }),\n      ]),\n      rewards: struct.union([\n        'undefined',\n        struct.array([\n          struct({\n            pubkey: 'string',\n            lamports: 'number',\n          }),\n        ]),\n      ]),\n    }),\n  ]),\n);\n\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n */\nconst GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(\n  struct({\n    blockhash: 'string',\n    feeCalculator: struct({\n      burnPercent: 'number',\n      lamportsPerSignature: 'number',\n      maxLamportsPerSignature: 'number',\n      minLamportsPerSignature: 'number',\n      targetLamportsPerSignature: 'number',\n      targetSignaturesPerSlot: 'number',\n    }),\n  }),\n);\n\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\nconst RequestAirdropRpcResult = jsonRpcResult('string');\n\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\nconst SendTransactionRpcResult = jsonRpcResult('string');\n\n/**\n * Information describing an account\n *\n * @typedef {Object} AccountInfo\n * @property {number} lamports Number of lamports assigned to the account\n * @property {PublicKey} owner Identifier of the program that owns the account\n * @property {?Buffer} data Optional data assigned to the account\n * @property {boolean} executable `true` if this account's data contains a loaded program\n */\ntype AccountInfo = {\n  executable: boolean,\n  owner: PublicKey,\n  lamports: number,\n  data: Buffer,\n};\n\n/**\n * Account information identified by pubkey\n *\n * @typedef {Object} KeyedAccountInfo\n * @property {PublicKey} accountId\n * @property {AccountInfo} accountInfo\n */\ntype KeyedAccountInfo = {\n  accountId: PublicKey,\n  accountInfo: AccountInfo,\n};\n\n/**\n * Callback function for account change notifications\n */\nexport type AccountChangeCallback = (accountInfo: AccountInfo) => void;\n\n/**\n * @private\n */\ntype SubscriptionId = 'subscribing' | number;\n\n/**\n * @private\n */\ntype AccountSubscriptionInfo = {\n  publicKey: string, // PublicKey of the account as a base 58 string\n  callback: AccountChangeCallback,\n  subscriptionId: ?SubscriptionId, // null when there's no current server subscription id\n};\n\n/**\n * Callback function for program account change notifications\n */\nexport type ProgramAccountChangeCallback = (\n  keyedAccountInfo: KeyedAccountInfo,\n) => void;\n\n/**\n * @private\n */\ntype ProgramAccountSubscriptionInfo = {\n  programId: string, // PublicKey of the program as a base 58 string\n  callback: ProgramAccountChangeCallback,\n  subscriptionId: ?SubscriptionId, // null when there's no current server subscription id\n};\n\n/**\n * Callback function for slot change notifications\n */\nexport type SlotChangeCallback = (slotInfo: SlotInfo) => void;\n\n/**\n * @private\n */\ntype SlotSubscriptionInfo = {\n  callback: SlotChangeCallback,\n  subscriptionId: ?SubscriptionId, // null when there's no current server subscription id\n};\n\n/**\n * Callback function for signature notifications\n */\nexport type SignatureResultCallback = (\n  signatureResult: SignatureStatusResult,\n) => void;\n\n/**\n * @private\n */\ntype SignatureSubscriptionInfo = {\n  signature: TransactionSignature, // TransactionSignature as a base 58 string\n  callback: SignatureResultCallback,\n  subscriptionId: ?SubscriptionId, // null when there's no current server subscription id\n};\n\n/**\n * Signature status: Success\n *\n * @typedef {Object} SignatureSuccess\n */\nexport type SignatureSuccess = {|\n  Ok: null,\n|};\n\n/**\n * Signature status: TransactionError\n *\n * @typedef {Object} TransactionError\n */\nexport type TransactionError = {|\n  Err: Object,\n|};\n\n/**\n * @ignore\n */\ntype BlockhashAndFeeCalculator = {\n  blockhash: Blockhash,\n  feeCalculator: FeeCalculator,\n}; // This type exists to workaround an esdoc parse error\n\n/**\n * @ignore\n */\ntype PublicKeyAndAccount = {\n  pubkey: PublicKey,\n  account: AccountInfo,\n}; // This type exists to workaround an esdoc parse error\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nexport class Connection {\n  _rpcRequest: RpcRequest;\n  _rpcWebSocket: RpcWebSocketClient;\n  _rpcWebSocketConnected: boolean = false;\n\n  _commitment: ?Commitment;\n  _blockhashInfo: {\n    recentBlockhash: Blockhash | null,\n    seconds: number,\n    transactionSignatures: Array<string>,\n  };\n  _disableBlockhashCaching: boolean = false;\n  _accountChangeSubscriptions: {[number]: AccountSubscriptionInfo} = {};\n  _accountChangeSubscriptionCounter: number = 0;\n  _programAccountChangeSubscriptions: {\n    [number]: ProgramAccountSubscriptionInfo,\n  } = {};\n  _programAccountChangeSubscriptionCounter: number = 0;\n  _slotSubscriptions: {\n    [number]: SlotSubscriptionInfo,\n  } = {};\n  _slotSubscriptionCounter: number = 0;\n  _signatureSubscriptions: {\n    [number]: SignatureSubscriptionInfo,\n  } = {};\n  _signatureSubscriptionCounter: number = 0;\n\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitment optional default commitment level\n   */\n  constructor(endpoint: string, commitment: ?Commitment) {\n    let url = urlParse(endpoint);\n\n    this._rpcRequest = createRpcRequest(url.href);\n    this._commitment = commitment;\n    this._blockhashInfo = {\n      recentBlockhash: null,\n      seconds: -1,\n      transactionSignatures: [],\n    };\n\n    url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    url.host = '';\n    url.port = String(Number(url.port) + 1);\n    if (url.port === '1') {\n      url.port = url.protocol === 'wss:' ? '8901' : '8900';\n    }\n    this._rpcWebSocket = new RpcWebSocketClient(urlFormat(url), {\n      autoconnect: false,\n      max_reconnects: Infinity,\n    });\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSocket.on(\n      'accountNotification',\n      this._wsOnAccountNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'programNotification',\n      this._wsOnProgramAccountNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'slotNotification',\n      this._wsOnSlotNotification.bind(this),\n    );\n    this._rpcWebSocket.on(\n      'signatureNotification',\n      this._wsOnSignatureNotification.bind(this),\n    );\n  }\n\n  /**\n   * Fetch the balance for the specified public key, return with context\n   */\n  async getBalanceAndContext(\n    publicKey: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<RpcResponseAndContext<number>> {\n    const args = this._argsWithCommitment([publicKey.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getBalance', args);\n    const res = GetBalanceAndContextRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the balance for the specified public key\n   */\n  async getBalance(\n    publicKey: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<number> {\n    return await this.getBalanceAndContext(publicKey, commitment)\n      .then(x => x.value)\n      .catch(e => {\n        throw e;\n      });\n  }\n\n  /**\n   * Fetch all the account info for the specified public key, return with context\n   */\n  async getAccountInfoAndContext(\n    publicKey: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<RpcResponseAndContext<AccountInfo>> {\n    const args = this._argsWithCommitment([publicKey.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = GetAccountInfoAndContextRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n\n    if (!res.result.value) {\n      throw new Error('Invalid request');\n    }\n\n    const {executable, owner, lamports, data} = res.result.value;\n    const value = {\n      executable,\n      owner: new PublicKey(owner),\n      lamports,\n      data: bs58.decode(data),\n    };\n\n    return {\n      context: {\n        slot: res.result.context.slot,\n      },\n      value,\n    };\n  }\n\n  /**\n   * Fetch all the account info for the specified public key\n   */\n  async getAccountInfo(\n    publicKey: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<AccountInfo> {\n    return await this.getAccountInfoAndContext(publicKey, commitment)\n      .then(x => x.value)\n      .catch(e => {\n        throw e;\n      });\n  }\n\n  /**\n   * Fetch all the accounts owned by the specified program id\n   */\n  async getProgramAccounts(\n    programId: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<Array<PublicKeyAndAccount>> {\n    const args = this._argsWithCommitment([programId.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const res = GetProgramAccountsRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const {result} = res;\n    assert(typeof result !== 'undefined');\n\n    return result.map(result => {\n      return {\n        pubkey: result.pubkey,\n        account: {\n          executable: result.account.executable,\n          owner: new PublicKey(result.account.owner),\n          lamports: result.account.lamports,\n          data: bs58.decode(result.account.data),\n        },\n      };\n    });\n  }\n\n  /**\n   * Confirm the transaction identified by the specified signature, return with context\n   */\n  async confirmTransactionAndContext(\n    signature: TransactionSignature,\n    commitment: ?Commitment,\n  ): Promise<RpcResponseAndContext<boolean>> {\n    const args = this._argsWithCommitment([signature], commitment);\n    const unsafeRes = await this._rpcRequest('confirmTransaction', args);\n    const res = ConfirmTransactionAndContextRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Confirm the transaction identified by the specified signature\n   */\n  async confirmTransaction(\n    signature: TransactionSignature,\n    commitment: ?Commitment,\n  ): Promise<boolean> {\n    return await this.confirmTransactionAndContext(signature, commitment)\n      .then(x => x.value)\n      .catch(e => {\n        throw e;\n      });\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getClusterNodes(): Promise<Array<ContactInfo>> {\n    const unsafeRes = await this._rpcRequest('getClusterNodes', []);\n\n    const res = GetClusterNodes(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getVoteAccounts(commitment: ?Commitment): Promise<VoteAccountStatus> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);\n    const res = GetVoteAccounts(unsafeRes);\n    //const res = unsafeRes;\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot that the node is processing\n   */\n  async getSlot(commitment: ?Commitment): Promise<number> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getSlot', args);\n    const res = GetSlot(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async getSlotLeader(commitment: ?Commitment): Promise<string> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getSlotLeader', args);\n    const res = GetSlotLeader(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current status of a signature\n   */\n  async getSignatureStatus(\n    signature: TransactionSignature,\n    commitment: ?Commitment,\n  ): Promise<SignatureSuccess | TransactionError | null> {\n    const args = this._argsWithCommitment([signature], commitment);\n    const unsafeRes = await this._rpcRequest('getSignatureStatus', args);\n    const res = GetSignatureStatusRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async getTransactionCount(commitment: ?Commitment): Promise<number> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getTransactionCount', args);\n    const res = GetTransactionCountRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster in lamports\n   */\n  async getTotalSupply(commitment: ?Commitment): Promise<number> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getTotalSupply', args);\n    const res = GetTotalSupplyRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch the cluster Inflation parameters\n   */\n  async getInflation(commitment: ?Commitment): Promise<GetInflationRpcResult> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getInflation', args);\n    const res = GetInflationRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return GetInflationResult(res.result);\n  }\n\n  /**\n   * Fetch the Epoch Info parameters\n   */\n  async getEpochInfo(commitment: ?Commitment): Promise<GetEpochInfoRpcResult> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getEpochInfo', args);\n    const res = GetEpochInfoRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return GetEpochInfoResult(res.result);\n  }\n\n  /**\n   * Fetch the Epoch Schedule parameters\n   */\n  async getEpochSchedule(): Promise<GetEpochScheduleRpcResult> {\n    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);\n    const res = GetEpochScheduleRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return GetEpochScheduleResult(res.result);\n  }\n\n  /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */\n  async getMinimumBalanceForRentExemption(\n    dataLength: number,\n    commitment: ?Commitment,\n  ): Promise<number> {\n    const args = this._argsWithCommitment([dataLength], commitment);\n    const unsafeRes = await this._rpcRequest(\n      'getMinimumBalanceForRentExemption',\n      args,\n    );\n    const res = GetMinimumBalanceForRentExemptionRpcResult(unsafeRes);\n    if (res.error) {\n      console.warn('Unable to fetch minimum balance for rent exemption');\n      return 0;\n    }\n    assert(typeof res.result !== 'undefined');\n    return Number(res.result);\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster, return with context\n   */\n  async getRecentBlockhashAndContext(\n    commitment: ?Commitment,\n  ): Promise<RpcResponseAndContext<BlockhashAndFeeCalculator>> {\n    const args = this._argsWithCommitment([], commitment);\n    const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);\n\n    const res = GetRecentBlockhashAndContextRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster\n   */\n  async getRecentBlockhash(\n    commitment: ?Commitment,\n  ): Promise<BlockhashAndFeeCalculator> {\n    return await this.getRecentBlockhashAndContext(commitment)\n      .then(x => x.value)\n      .catch(e => {\n        throw e;\n      });\n  }\n\n  /**\n   * Fetch the node version\n   */\n  async getVersion(): Promise<Version> {\n    const unsafeRes = await this._rpcRequest('getVersion', []);\n    const res = GetVersionRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block\n   */\n  async getConfirmedBlock(slot: number): Promise<ConfirmedBlock> {\n    const unsafeRes = await this._rpcRequest('getConfirmedBlock', [slot]);\n    const result = GetConfirmedBlockRpcResult(unsafeRes);\n    if (result.error) {\n      throw new Error(result.error.message);\n    }\n    assert(typeof result.result !== 'undefined');\n    if (!result.result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    return {\n      blockhash: new PublicKey(result.result.blockhash).toString(),\n      previousBlockhash: new PublicKey(\n        result.result.previousBlockhash,\n      ).toString(),\n      parentSlot: result.result.parentSlot,\n      transactions: result.result.transactions.map(result => {\n        return {\n          transaction: Transaction.fromRpcResult(result.transaction),\n          meta: result.meta,\n        };\n      }),\n      rewards: result.result.rewards || [],\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */\n  async getNonceAndContext(\n    nonceAccount: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<RpcResponseAndContext<NonceAccount>> {\n    const args = this._argsWithCommitment(\n      [nonceAccount.toBase58()],\n      commitment,\n    );\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = GetAccountInfoAndContextRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    if (!res.result.value) {\n      throw new Error('Invalid request');\n    }\n\n    const value = NonceAccount.fromAccountData(\n      bs58.decode(res.result.value.data),\n    );\n\n    return {\n      context: {\n        slot: res.result.context.slot,\n      },\n      value,\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster\n   */\n  async getNonce(\n    nonceAccount: PublicKey,\n    commitment: ?Commitment,\n  ): Promise<NonceAccount> {\n    return await this.getNonceAndContext(nonceAccount, commitment)\n      .then(x => x.value)\n      .catch(e => {\n        throw e;\n      });\n  }\n\n  /**\n   * Request an allocation of lamports to the specified account\n   */\n  async requestAirdrop(\n    to: PublicKey,\n    amount: number,\n    commitment: ?Commitment,\n  ): Promise<TransactionSignature> {\n    const args = this._argsWithCommitment([to.toBase58(), amount], commitment);\n    const unsafeRes = await this._rpcRequest('requestAirdrop', args);\n    const res = RequestAirdropRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   */\n  async sendTransaction(\n    transaction: Transaction,\n    ...signers: Array<Account>\n  ): Promise<TransactionSignature> {\n    if (transaction.nonceInfo) {\n      transaction.sign(...signers);\n    } else {\n      for (;;) {\n        // Attempt to use a recent blockhash for up to 30 seconds\n        const seconds = new Date().getSeconds();\n        if (\n          this._blockhashInfo.recentBlockhash != null &&\n          this._blockhashInfo.seconds < seconds + 30\n        ) {\n          transaction.recentBlockhash = this._blockhashInfo.recentBlockhash;\n          transaction.sign(...signers);\n          if (!transaction.signature) {\n            throw new Error('!signature'); // should never happen\n          }\n\n          // If the signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done.\n          const signature = transaction.signature.toString();\n          if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n            this._blockhashInfo.transactionSignatures.push(signature);\n            if (this._disableBlockhashCaching) {\n              this._blockhashInfo.seconds = -1;\n            }\n            break;\n          }\n        }\n\n        // Fetch a new blockhash\n        let attempts = 0;\n        const startTime = Date.now();\n        for (;;) {\n          const {blockhash} = await this.getRecentBlockhash();\n\n          if (this._blockhashInfo.recentBlockhash != blockhash) {\n            this._blockhashInfo = {\n              recentBlockhash: blockhash,\n              seconds: new Date().getSeconds(),\n              transactionSignatures: [],\n            };\n            break;\n          }\n          if (attempts === 50) {\n            throw new Error(\n              `Unable to obtain a new blockhash after ${Date.now() -\n                startTime}ms`,\n            );\n          }\n\n          // Sleep for approximately half a slot\n          await sleep((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SECOND);\n\n          ++attempts;\n        }\n      }\n    }\n\n    const wireTransaction = transaction.serialize();\n    return await this.sendRawTransaction(wireTransaction);\n  }\n\n  /**\n   * @private\n   */\n  async validatorExit(): Promise<boolean> {\n    const unsafeRes = await this._rpcRequest('validatorExit', []);\n    const res = jsonRpcResult('boolean')(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    return res.result;\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendRawTransaction(\n    rawTransaction: Buffer | Uint8Array | Array<number>,\n  ): Promise<TransactionSignature> {\n    const encodedTransaction = bs58.encode(toBuffer(rawTransaction));\n    const result = await this.sendEncodedTransaction(encodedTransaction);\n    return result;\n  }\n\n  /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base58 string\n   */\n  async sendEncodedTransaction(\n    encodedTransaction: string,\n  ): Promise<TransactionSignature> {\n    const unsafeRes = await this._rpcRequest('sendTransaction', [\n      encodedTransaction,\n    ]);\n    const res = SendTransactionRpcResult(unsafeRes);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    assert(res.result);\n    return res.result;\n  }\n\n  /**\n   * @private\n   */\n  _wsOnOpen() {\n    this._rpcWebSocketConnected = true;\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @private\n   */\n  _wsOnError(err: Error) {\n    console.log('ws error:', err.message);\n  }\n\n  /**\n   * @private\n   */\n  _wsOnClose(code: number, message: string) {\n    // 1000 means _rpcWebSocket.close() was called explicitly\n    if (code !== 1000) {\n      console.log('ws close:', code, message);\n    } else {\n      // Only after an explicit close do we need to explicitly connect again\n      this._rpcWebSocketConnected = false;\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _subscribe<SubInfo: {subscriptionId: ?SubscriptionId}, RpcArgs>(\n    sub: SubInfo,\n    rpcMethod: string,\n    rpcArgs: RpcArgs,\n  ) {\n    if (sub.subscriptionId == null) {\n      sub.subscriptionId = 'subscribing';\n      try {\n        const id = await this._rpcWebSocket.call(rpcMethod, rpcArgs);\n        if (sub.subscriptionId === 'subscribing') {\n          // eslint-disable-next-line require-atomic-updates\n          sub.subscriptionId = id;\n        }\n      } catch (err) {\n        if (sub.subscriptionId === 'subscribing') {\n          // eslint-disable-next-line require-atomic-updates\n          sub.subscriptionId = null;\n        }\n        console.error(`${rpcMethod} error for argument`, rpcArgs, err.message);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _unsubscribe<SubInfo: {subscriptionId: ?SubscriptionId}>(\n    sub: SubInfo,\n    rpcMethod: string,\n  ) {\n    const subscriptionId = sub.subscriptionId;\n    if (subscriptionId != null && typeof subscriptionId != 'string') {\n      const unsubscribeId: number = subscriptionId;\n      try {\n        await this._rpcWebSocket.call(rpcMethod, [unsubscribeId]);\n      } catch (err) {\n        console.log(`${rpcMethod} error:`, err.message);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateSubscriptions() {\n    const accountKeys = Object.keys(this._accountChangeSubscriptions).map(\n      Number,\n    );\n    const programKeys = Object.keys(\n      this._programAccountChangeSubscriptions,\n    ).map(Number);\n    const slotKeys = Object.keys(this._slotSubscriptions).map(Number);\n    const signatureKeys = Object.keys(this._signatureSubscriptions).map(Number);\n    if (\n      accountKeys.length === 0 &&\n      programKeys.length === 0 &&\n      slotKeys.length === 0 &&\n      signatureKeys.length === 0\n    ) {\n      this._rpcWebSocket.close();\n      return;\n    }\n\n    if (!this._rpcWebSocketConnected) {\n      for (let id of accountKeys) {\n        this._accountChangeSubscriptions[id].subscriptionId = null;\n      }\n      for (let id of programKeys) {\n        this._programAccountChangeSubscriptions[id].subscriptionId = null;\n      }\n      for (let id of slotKeys) {\n        this._slotSubscriptions[id].subscriptionId = null;\n      }\n      for (let id of signatureKeys) {\n        this._signatureSubscriptions[id].subscriptionId = null;\n      }\n      this._rpcWebSocket.connect();\n      return;\n    }\n\n    for (let id of accountKeys) {\n      const sub = this._accountChangeSubscriptions[id];\n      this._subscribe(sub, 'accountSubscribe', [sub.publicKey]);\n    }\n\n    for (let id of programKeys) {\n      const sub = this._programAccountChangeSubscriptions[id];\n      this._subscribe(sub, 'programSubscribe', [sub.programId]);\n    }\n\n    for (let id of slotKeys) {\n      const sub = this._slotSubscriptions[id];\n      this._subscribe(sub, 'slotSubscribe', []);\n    }\n\n    for (let id of signatureKeys) {\n      const sub = this._signatureSubscriptions[id];\n      this._subscribe(sub, 'signatureSubscribe', [sub.signature]);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnAccountNotification(notification: Object) {\n    const res = AccountNotificationResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const keys = Object.keys(this._accountChangeSubscriptions).map(Number);\n    for (let id of keys) {\n      const sub = this._accountChangeSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        const {result} = res;\n        assert(typeof result !== 'undefined');\n\n        sub.callback({\n          executable: result.executable,\n          owner: new PublicKey(result.owner),\n          lamports: result.lamports,\n          data: bs58.decode(result.data),\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publickey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @return subscription id\n   */\n  onAccountChange(\n    publicKey: PublicKey,\n    callback: AccountChangeCallback,\n  ): number {\n    const id = ++this._accountChangeSubscriptionCounter;\n    this._accountChangeSubscriptions[id] = {\n      publicKey: publicKey.toBase58(),\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeAccountChangeListener(id: number): Promise<void> {\n    if (this._accountChangeSubscriptions[id]) {\n      const subInfo = this._accountChangeSubscriptions[id];\n      delete this._accountChangeSubscriptions[id];\n      await this._unsubscribe(subInfo, 'accountUnsubscribe');\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown account change id: ${id}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnProgramAccountNotification(notification: Object) {\n    const res = ProgramAccountNotificationResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n\n    const keys = Object.keys(this._programAccountChangeSubscriptions).map(\n      Number,\n    );\n    for (let id of keys) {\n      const sub = this._programAccountChangeSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        const {result} = res;\n        assert(typeof result !== 'undefined');\n\n        sub.callback({\n          accountId: result.pubkey,\n          accountInfo: {\n            executable: result.account.executable,\n            owner: new PublicKey(result.account.owner),\n            lamports: result.account.lamports,\n            data: bs58.decode(result.account.data),\n          },\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @return subscription id\n   */\n  onProgramAccountChange(\n    programId: PublicKey,\n    callback: ProgramAccountChangeCallback,\n  ): number {\n    const id = ++this._programAccountChangeSubscriptionCounter;\n    this._programAccountChangeSubscriptions[id] = {\n      programId: programId.toBase58(),\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeProgramAccountChangeListener(id: number): Promise<void> {\n    if (this._programAccountChangeSubscriptions[id]) {\n      const subInfo = this._programAccountChangeSubscriptions[id];\n      delete this._programAccountChangeSubscriptions[id];\n      await this._unsubscribe(subInfo, 'programUnsubscribe');\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown program account change id: ${id}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _wsOnSlotNotification(notification: Object) {\n    const res = SlotNotificationResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n    const {parent, slot, root} = res.result;\n\n    const keys = Object.keys(this._slotSubscriptions).map(Number);\n    for (let id of keys) {\n      const sub = this._slotSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        sub.callback({\n          parent,\n          slot,\n          root,\n        });\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */\n  onSlotChange(callback: SlotChangeCallback): number {\n    const id = ++this._slotSubscriptionCounter;\n    this._slotSubscriptions[id] = {\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister a slot notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeSlotChangeListener(id: number): Promise<void> {\n    if (this._slotSubscriptions[id]) {\n      const subInfo = this._slotSubscriptions[id];\n      delete this._slotSubscriptions[id];\n      await this._unsubscribe(subInfo, 'slotUnsubscribe');\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown slot change id: ${id}`);\n    }\n  }\n\n  _argsWithCommitment(args: Array<any>, override: ?Commitment): Array<any> {\n    const commitment = override || this._commitment;\n    if (commitment) {\n      args.push({commitment});\n    }\n    return args;\n  }\n\n  /**\n   * @private\n   */\n  _wsOnSignatureNotification(notification: Object) {\n    const res = SignatureNotificationResult(notification);\n    if (res.error) {\n      throw new Error(res.error.message);\n    }\n    assert(typeof res.result !== 'undefined');\n\n    const keys = Object.keys(this._signatureSubscriptions).map(Number);\n    for (let id of keys) {\n      const sub = this._signatureSubscriptions[id];\n      if (sub.subscriptionId === res.subscription) {\n        // Signatures subscriptions are auto-removed by the RPC service so\n        // no need to explicitly send an unsubscribe message\n        delete this._signatureSubscriptions[id];\n        this._updateSubscriptions();\n        sub.callback(res.result);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @return subscription id\n   */\n  onSignature(\n    signature: TransactionSignature,\n    callback: SignatureResultCallback,\n  ): number {\n    const id = ++this._signatureSubscriptionCounter;\n    this._signatureSubscriptions[id] = {\n      signature,\n      callback,\n      subscriptionId: null,\n    };\n    this._updateSubscriptions();\n    return id;\n  }\n\n  /**\n   * Deregister a signature notification callback\n   *\n   * @param id subscription id to deregister\n   */\n  async removeSignatureListener(id: number): Promise<void> {\n    if (this._signatureSubscriptions[id]) {\n      const subInfo = this._signatureSubscriptions[id];\n      delete this._signatureSubscriptions[id];\n      await this._unsubscribe(subInfo, 'signatureUnsubscribe');\n      this._updateSubscriptions();\n    } else {\n      throw new Error(`Unknown signature result id: ${id}`);\n    }\n  }\n}\n","// @flow\n\nimport invariant from 'assert';\n\nimport {Connection} from '../connection';\nimport type {Commitment} from '../connection';\nimport {Transaction} from '../transaction';\nimport {sleep} from './sleep';\nimport type {Account} from '../account';\nimport type {TransactionSignature} from '../transaction';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SECOND} from '../timing';\n\n/**\n * Sign, send and confirm a transaction with recent commitment level\n */\nexport async function sendAndConfirmRecentTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<Account>\n): Promise<TransactionSignature> {\n  return await _sendAndConfirmTransaction(\n    connection,\n    transaction,\n    signers,\n    'recent',\n  );\n}\n\n/**\n * Sign, send and confirm a transaction\n */\nexport async function sendAndConfirmTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<Account>\n): Promise<TransactionSignature> {\n  return await _sendAndConfirmTransaction(connection, transaction, signers);\n}\n\nasync function _sendAndConfirmTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  signers: Array<Account>,\n  commitment: ?Commitment,\n): Promise<TransactionSignature> {\n  let sendRetries = 10;\n  let signature;\n  for (;;) {\n    const start = Date.now();\n    signature = await connection.sendTransaction(transaction, ...signers);\n\n    // Wait up to a couple slots for a confirmation\n    let status = null;\n    let statusRetries = 6;\n    for (;;) {\n      status = await connection.getSignatureStatus(signature, commitment);\n      if (status) {\n        break;\n      }\n\n      if (--statusRetries <= 0) {\n        break;\n      }\n      // Sleep for approximately half a slot\n      await sleep((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SECOND);\n    }\n\n    if (status && 'Ok' in status) {\n      break;\n    }\n    if (--sendRetries <= 0) {\n      const duration = (Date.now() - start) / 1000;\n      throw new Error(\n        `Transaction '${signature}' was not confirmed in ${duration.toFixed(\n          2,\n        )} seconds (${JSON.stringify(status)})`,\n      );\n    }\n\n    if (status && status.Err && !('AccountInUse' in status.Err)) {\n      throw new Error(\n        `Transaction ${signature} failed (${JSON.stringify(status)})`,\n      );\n    }\n\n    // Retry in 0..100ms to try to avoid another AccountInUse collision\n    await sleep(Math.random() * 100);\n  }\n\n  invariant(signature !== undefined);\n  return signature;\n}\n","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport * as Layout from './layout';\n\n/**\n * @typedef {Object} InstructionType\n * @property (index} The Instruction index (from solana upstream program)\n * @property (BufferLayout} The BufferLayout to use to build data\n */\nexport type InstructionType = {|\n  index: number,\n  layout: typeof BufferLayout,\n|};\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n */\nexport function encodeData(type: InstructionType, fields: Object): Buffer {\n  const allocLength =\n    type.layout.span >= 0 ? type.layout.span : Layout.getAlloc(type, fields);\n  const data = Buffer.alloc(allocLength);\n  const layoutFields = Object.assign({instruction: type.index}, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {encodeData} from './instruction';\nimport type {InstructionType} from './instruction';\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\nimport {SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY} from './sysvar';\nimport {Transaction, TransactionInstruction} from './transaction';\nimport type {TransactionInstructionCtorFields} from './transaction';\n\n/**\n * System Instruction class\n */\nexport class SystemInstruction extends TransactionInstruction {\n  /**\n   * Type of SystemInstruction\n   */\n  type: InstructionType;\n\n  constructor(opts?: TransactionInstructionCtorFields, type?: InstructionType) {\n    if (\n      opts &&\n      opts.programId &&\n      !opts.programId.equals(SystemProgram.programId)\n    ) {\n      throw new Error('programId incorrect; not a SystemInstruction');\n    }\n    super(opts);\n    if (type) {\n      this.type = type;\n    }\n  }\n\n  static from(instruction: TransactionInstruction): SystemInstruction {\n    if (!instruction.programId.equals(SystemProgram.programId)) {\n      throw new Error('programId incorrect; not SystemProgram');\n    }\n\n    const instructionTypeLayout = BufferLayout.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const t in SystemInstructionLayout) {\n      if (SystemInstructionLayout[t].index == typeIndex) {\n        type = SystemInstructionLayout[t];\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a SystemInstruction');\n    }\n    return new SystemInstruction(\n      {\n        keys: instruction.keys,\n        programId: instruction.programId,\n        data: instruction.data,\n      },\n      type,\n    );\n  }\n\n  /**\n   * The `from` public key of the instruction;\n   * returns null if SystemInstructionType does not support this field\n   */\n  get fromPublicKey(): PublicKey | null {\n    if (\n      this.type == SystemInstructionLayout.Create ||\n      this.type == SystemInstructionLayout.CreateWithSeed ||\n      this.type == SystemInstructionLayout.WithdrawNonceAccount ||\n      this.type == SystemInstructionLayout.Transfer\n    ) {\n      return this.keys[0].pubkey;\n    }\n    return null;\n  }\n\n  /**\n   * The `to` public key of the instruction;\n   * returns null if SystemInstructionType does not support this field\n   */\n  get toPublicKey(): PublicKey | null {\n    if (\n      this.type == SystemInstructionLayout.Create ||\n      this.type == SystemInstructionLayout.CreateWithSeed ||\n      this.type == SystemInstructionLayout.WithdrawNonceAccount ||\n      this.type == SystemInstructionLayout.Transfer\n    ) {\n      return this.keys[1].pubkey;\n    }\n    return null;\n  }\n\n  /**\n   * The `amount` or `lamports` of the instruction;\n   * returns null if SystemInstructionType does not support this field\n   */\n  get amount(): number | null {\n    const data = this.type.layout.decode(this.data);\n    if (\n      this.type == SystemInstructionLayout.Create ||\n      this.type == SystemInstructionLayout.CreateWithSeed ||\n      this.type == SystemInstructionLayout.WithdrawNonceAccount ||\n      this.type == SystemInstructionLayout.Transfer\n    ) {\n      return data.lamports;\n    }\n    return null;\n  }\n}\n\n/**\n * An enumeration of valid SystemInstructionTypes\n */\nconst SystemInstructionLayout = Object.freeze({\n  Create: {\n    index: 0,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n      BufferLayout.ns64('space'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  Assign: {\n    index: 1,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  Transfer: {\n    index: 2,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('base'),\n      Layout.rustString('seed'),\n      BufferLayout.ns64('lamports'),\n      BufferLayout.ns64('space'),\n      Layout.publicKey('programId'),\n    ]),\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')]),\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('authorized'),\n    ]),\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('authorized'),\n    ]),\n  },\n});\n\n/**\n * Factory class for transactions to interact with the System program\n */\nexport class SystemProgram {\n  /**\n   * Public key that identifies the System program\n   */\n  static get programId(): PublicKey {\n    return new PublicKey(\n      '0x000000000000000000000000000000000000000000000000000000000000000',\n    );\n  }\n\n  /**\n   * Max space of a Nonce account\n   */\n  static get nonceSpace(): number {\n    return 68;\n  }\n\n  /**\n   * Generate a Transaction that creates a new account\n   */\n  static createAccount(\n    from: PublicKey,\n    newAccount: PublicKey,\n    lamports: number,\n    space: number,\n    programId: PublicKey,\n  ): Transaction {\n    const type = SystemInstructionLayout.Create;\n    const data = encodeData(type, {\n      lamports,\n      space,\n      programId: programId.toBuffer(),\n    });\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isWritable: true},\n        {pubkey: newAccount, isSigner: true, isWritable: true},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that transfers lamports from one account to another\n   */\n  static transfer(\n    from: PublicKey,\n    to: PublicKey,\n    lamports: number,\n  ): Transaction {\n    const type = SystemInstructionLayout.Transfer;\n    const data = encodeData(type, {lamports});\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isWritable: true},\n        {pubkey: to, isSigner: false, isWritable: true},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that assigns an account to a program\n   */\n  static assign(from: PublicKey, programId: PublicKey): Transaction {\n    const type = SystemInstructionLayout.Assign;\n    const data = encodeData(type, {programId: programId.toBuffer()});\n\n    return new Transaction().add({\n      keys: [{pubkey: from, isSigner: true, isWritable: true}],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */\n  static createAccountWithSeed(\n    from: PublicKey,\n    newAccount: PublicKey,\n    base: PublicKey,\n    seed: string,\n    lamports: number,\n    space: number,\n    programId: PublicKey,\n  ): Transaction {\n    const type = SystemInstructionLayout.CreateWithSeed;\n    const data = encodeData(type, {\n      base: base.toBuffer(),\n      seed,\n      lamports,\n      space,\n      programId: programId.toBuffer(),\n    });\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isWritable: true},\n        {pubkey: newAccount, isSigner: false, isWritable: true},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that creates a new Nonce account\n   */\n  static createNonceAccount(\n    from: PublicKey,\n    nonceAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n    lamports: number,\n  ): Transaction {\n    let transaction = SystemProgram.createAccount(\n      from,\n      nonceAccount,\n      lamports,\n      this.nonceSpace,\n      this.programId,\n    );\n\n    const type = SystemInstructionLayout.InitializeNonceAccount;\n    const data = encodeData(type, {\n      authorized: authorizedPubkey.toBuffer(),\n    });\n\n    return transaction.add({\n      keys: [\n        {pubkey: nonceAccount, isSigner: false, isWritable: true},\n        {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */\n  static nonceAdvance(\n    nonceAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n  ): TransactionInstruction {\n    const type = SystemInstructionLayout.AdvanceNonceAccount;\n    const data = encodeData(type);\n    const instructionData = {\n      keys: [\n        {pubkey: nonceAccount, isSigner: false, isWritable: true},\n        {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a Transaction that withdraws lamports from a Nonce account\n   */\n  static nonceWithdraw(\n    nonceAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n    to: PublicKey,\n    lamports: number,\n  ): Transaction {\n    const type = SystemInstructionLayout.WithdrawNonceAccount;\n    const data = encodeData(type, {lamports});\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: nonceAccount, isSigner: false, isWritable: true},\n        {pubkey: to, isSigner: false, isWritable: true},\n        {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */\n  static nonceAuthorize(\n    nonceAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n    newAuthorized: PublicKey,\n  ): Transaction {\n    const type = SystemInstructionLayout.AuthorizeNonceAccount;\n    const data = encodeData(type, {\n      newAuthorized: newAuthorized.toBuffer(),\n    });\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: nonceAccount, isSigner: false, isWritable: true},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n}\n","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {Account} from './account';\nimport {PublicKey} from './publickey';\nimport {NUM_TICKS_PER_SECOND} from './timing';\nimport {Transaction, PACKET_DATA_SIZE} from './transaction';\nimport {SYSVAR_RENT_PUBKEY} from './sysvar';\nimport {sendAndConfirmTransaction} from './util/send-and-confirm-transaction';\nimport {sleep} from './util/sleep';\nimport type {Connection} from './connection';\nimport {SystemProgram} from './system-program';\n\n/**\n * Program loader interface\n */\nexport class Loader {\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n  static get chunkSize(): number {\n    // Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n    // rest of the Transaction fields\n    //\n    // TODO: replace 300 with a proper constant for the size of the other\n    // Transaction fields\n    return PACKET_DATA_SIZE - 300;\n  }\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength: number): number {\n    return Math.ceil(dataLength / Loader.chunkSize);\n  }\n\n  /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   */\n  static async load(\n    connection: Connection,\n    payer: Account,\n    program: Account,\n    programId: PublicKey,\n    data: Buffer | Uint8Array | Array<number>,\n  ): Promise<PublicKey> {\n    {\n      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(\n        data.length,\n      );\n      const transaction = SystemProgram.createAccount(\n        payer.publicKey,\n        program.publicKey,\n        balanceNeeded > 0 ? balanceNeeded : 1,\n        data.length,\n        programId,\n      );\n      await sendAndConfirmTransaction(connection, transaction, payer, program);\n    }\n\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.u32('offset'),\n      BufferLayout.u32('bytesLength'),\n      BufferLayout.u32('bytesLengthPadding'),\n      BufferLayout.seq(\n        BufferLayout.u8('byte'),\n        BufferLayout.offset(BufferLayout.u32(), -8),\n        'bytes',\n      ),\n    ]);\n\n    const chunkSize = Loader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      const bytes = array.slice(0, chunkSize);\n      const data = Buffer.alloc(chunkSize + 16);\n      dataLayout.encode(\n        {\n          instruction: 0, // Load instruction\n          offset,\n          bytes,\n        },\n        data,\n      );\n\n      const transaction = new Transaction().add({\n        keys: [{pubkey: program.publicKey, isSigner: true, isWritable: true}],\n        programId,\n        data,\n      });\n      transactions.push(\n        sendAndConfirmTransaction(connection, transaction, payer, program),\n      );\n\n      // Delay ~1 tick between write transactions in an attempt to reduce AccountInUse errors\n      // since all the write transactions modify the same program account\n      await sleep(1000 / NUM_TICKS_PER_SECOND);\n\n      // Run up to 8 Loads in parallel to prevent too many parallel transactions from\n      // getting rejected with AccountInUse.\n      //\n      // TODO: 8 was selected empirically and should probably be revisited\n      if (transactions.length === 8) {\n        await Promise.all(transactions);\n        transactions = [];\n      }\n\n      offset += chunkSize;\n      array = array.slice(chunkSize);\n    }\n    await Promise.all(transactions);\n\n    // Finalize the account loaded with program data for execution\n    {\n      const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n      const data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode(\n        {\n          instruction: 1, // Finalize instruction\n        },\n        data,\n      );\n\n      const transaction = new Transaction().add({\n        keys: [\n          {pubkey: program.publicKey, isSigner: true, isWritable: true},\n          {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n        ],\n        programId,\n        data,\n      });\n      await sendAndConfirmTransaction(connection, transaction, payer, program);\n    }\n    return program.publicKey;\n  }\n}\n","// @flow\n\nimport {Account} from './account';\nimport {PublicKey} from './publickey';\nimport {Loader} from './loader';\nimport type {Connection} from './connection';\n\n/**\n * Factory class for transactions to interact with a program loader\n */\nexport class BpfLoader {\n  /**\n   * Public key that identifies the BpfLoader\n   */\n  static get programId(): PublicKey {\n    return new PublicKey('BPFLoader1111111111111111111111111111111111');\n  }\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength: number): number {\n    return Loader.getMinNumSignatures(dataLength);\n  }\n\n  /**\n   * Load a BPF program\n   *\n   * @param connection The connection to use\n   * @param owner User account to load the program into\n   * @param elfBytes The entire ELF containing the BPF program\n   */\n  static load(\n    connection: Connection,\n    payer: Account,\n    elf: Buffer | Uint8Array | Array<number>,\n  ): Promise<PublicKey> {\n    const program = new Account();\n    return Loader.load(connection, payer, program, BpfLoader.programId, elf);\n  }\n}\n","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {Transaction} from './transaction';\nimport {PublicKey} from './publickey';\nimport {SystemProgram} from './system-program';\n\n/**\n * Represents a condition that is met by executing a `applySignature()`\n * transaction\n *\n * @typedef {Object} SignatureCondition\n * @property {string} type Must equal the string 'timestamp'\n * @property {PublicKey} from Public key from which `applySignature()` will be accepted from\n */\nexport type SignatureCondition = {\n  type: 'signature',\n  from: PublicKey,\n};\n\n/**\n * Represents a condition that is met by executing a `applyTimestamp()`\n * transaction\n *\n * @typedef {Object} TimestampCondition\n * @property {string} type Must equal the string 'timestamp'\n * @property {PublicKey} from Public key from which `applyTimestamp()` will be accepted from\n * @property {Date} when The timestamp that was observed\n */\nexport type TimestampCondition = {\n  type: 'timestamp',\n  from: PublicKey,\n  when: Date,\n};\n\n/**\n * Represents a payment to a given public key\n *\n * @typedef {Object} Payment\n * @property {number} amount Number of lamports\n * @property {PublicKey} to Public key of the recipient\n */\nexport type Payment = {\n  amount: number,\n  to: PublicKey,\n};\n\n/**\n * A condition that can unlock a payment\n *\n * @typedef {SignatureCondition|TimestampCondition} BudgetCondition\n */\nexport type BudgetCondition = SignatureCondition | TimestampCondition;\n\n/**\n * @private\n */\nfunction serializePayment(payment: Payment): Buffer {\n  const toData = payment.to.toBuffer();\n  const data = Buffer.alloc(8 + toData.length);\n  data.writeUInt32LE(payment.amount, 0);\n  toData.copy(data, 8);\n  return data;\n}\n\n/**\n * @private\n */\nfunction serializeDate(when: Date): Buffer {\n  const data = Buffer.alloc(8 + 20);\n  data.writeUInt32LE(20, 0); // size of timestamp as u64\n\n  function iso(date) {\n    function pad(number) {\n      if (number < 10) {\n        return '0' + number;\n      }\n      return number;\n    }\n\n    return (\n      date.getUTCFullYear() +\n      '-' +\n      pad(date.getUTCMonth() + 1) +\n      '-' +\n      pad(date.getUTCDate()) +\n      'T' +\n      pad(date.getUTCHours()) +\n      ':' +\n      pad(date.getUTCMinutes()) +\n      ':' +\n      pad(date.getUTCSeconds()) +\n      'Z'\n    );\n  }\n  data.write(iso(when), 8);\n  return data;\n}\n\n/**\n * @private\n */\nfunction serializeCondition(condition: BudgetCondition) {\n  switch (condition.type) {\n    case 'timestamp': {\n      const date = serializeDate(condition.when);\n      const from = condition.from.toBuffer();\n\n      const data = Buffer.alloc(4 + date.length + from.length);\n      data.writeUInt32LE(0, 0); // Condition enum = Timestamp\n      date.copy(data, 4);\n      from.copy(data, 4 + date.length);\n      return data;\n    }\n    case 'signature': {\n      const from = condition.from.toBuffer();\n      const data = Buffer.alloc(4 + from.length);\n      data.writeUInt32LE(1, 0); // Condition enum = Signature\n      from.copy(data, 4);\n      return data;\n    }\n    default:\n      throw new Error(`Unknown condition type: ${condition.type}`);\n  }\n}\n\n/**\n * Factory class for transactions to interact with the Budget program\n */\nexport class BudgetProgram {\n  /**\n   * Public key that identifies the Budget program\n   */\n  static get programId(): PublicKey {\n    return new PublicKey('Budget1111111111111111111111111111111111111');\n  }\n\n  /**\n   * The amount of space this program requires\n   */\n  static get space(): number {\n    return 128;\n  }\n\n  /**\n   * Creates a timestamp condition\n   */\n  static timestampCondition(from: PublicKey, when: Date): TimestampCondition {\n    return {\n      type: 'timestamp',\n      from,\n      when,\n    };\n  }\n\n  /**\n   * Creates a signature condition\n   */\n  static signatureCondition(from: PublicKey): SignatureCondition {\n    return {\n      type: 'signature',\n      from,\n    };\n  }\n\n  /**\n   * Generates a transaction that transfers lamports once any of the conditions are met\n   */\n  static pay(\n    from: PublicKey,\n    program: PublicKey,\n    to: PublicKey,\n    amount: number,\n    ...conditions: Array<BudgetCondition>\n  ): Transaction {\n    const data = Buffer.alloc(1024);\n    let pos = 0;\n    data.writeUInt32LE(0, pos); // NewBudget instruction\n    pos += 4;\n\n    switch (conditions.length) {\n      case 0: {\n        data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n        pos += 4;\n\n        {\n          const payment = serializePayment({amount, to});\n          payment.copy(data, pos);\n          pos += payment.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemProgram.createAccount(\n          from,\n          program,\n          amount,\n          trimmedData.length,\n          this.programId,\n        );\n\n        return transaction.add({\n          keys: [\n            {pubkey: to, isSigner: false, isWritable: true},\n            {pubkey: program, isSigner: false, isWritable: true},\n          ],\n          programId: this.programId,\n          data: trimmedData,\n        });\n      }\n      case 1: {\n        data.writeUInt32LE(1, pos); // BudgetExpr enum = After\n        pos += 4;\n        {\n          const condition = conditions[0];\n\n          const conditionData = serializeCondition(condition);\n          conditionData.copy(data, pos);\n          pos += conditionData.length;\n\n          data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n          pos += 4;\n\n          const paymentData = serializePayment({amount, to});\n          paymentData.copy(data, pos);\n          pos += paymentData.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemProgram.createAccount(\n          from,\n          program,\n          amount,\n          trimmedData.length,\n          this.programId,\n        );\n\n        return transaction.add({\n          keys: [{pubkey: program, isSigner: false, isWritable: true}],\n          programId: this.programId,\n          data: trimmedData,\n        });\n      }\n\n      case 2: {\n        data.writeUInt32LE(2, pos); // BudgetExpr enum = Or\n        pos += 4;\n\n        for (let condition of conditions) {\n          const conditionData = serializeCondition(condition);\n          conditionData.copy(data, pos);\n          pos += conditionData.length;\n\n          data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n          pos += 4;\n\n          const paymentData = serializePayment({amount, to});\n          paymentData.copy(data, pos);\n          pos += paymentData.length;\n        }\n        const trimmedData = data.slice(0, pos);\n\n        const transaction = SystemProgram.createAccount(\n          from,\n          program,\n          amount,\n          trimmedData.length,\n          this.programId,\n        );\n\n        return transaction.add({\n          keys: [{pubkey: program, isSigner: false, isWritable: true}],\n          programId: this.programId,\n          data: trimmedData,\n        });\n      }\n\n      default:\n        throw new Error(\n          `A maximum of two conditions are supported: ${conditions.length} provided`,\n        );\n    }\n  }\n\n  /**\n   * Generates a transaction that transfers lamports once both conditions are met\n   */\n  static payOnBoth(\n    from: PublicKey,\n    program: PublicKey,\n    to: PublicKey,\n    amount: number,\n    condition1: BudgetCondition,\n    condition2: BudgetCondition,\n  ): Transaction {\n    const data = Buffer.alloc(1024);\n    let pos = 0;\n    data.writeUInt32LE(0, pos); // NewBudget instruction\n    pos += 4;\n\n    data.writeUInt32LE(3, pos); // BudgetExpr enum = And\n    pos += 4;\n\n    for (let condition of [condition1, condition2]) {\n      const conditionData = serializeCondition(condition);\n      conditionData.copy(data, pos);\n      pos += conditionData.length;\n    }\n\n    data.writeUInt32LE(0, pos); // BudgetExpr enum = Pay\n    pos += 4;\n\n    const paymentData = serializePayment({amount, to});\n    paymentData.copy(data, pos);\n    pos += paymentData.length;\n\n    const trimmedData = data.slice(0, pos);\n\n    const transaction = SystemProgram.createAccount(\n      from,\n      program,\n      amount,\n      trimmedData.length,\n      this.programId,\n    );\n\n    return transaction.add({\n      keys: [{pubkey: program, isSigner: false, isWritable: true}],\n      programId: this.programId,\n      data: trimmedData,\n    });\n  }\n\n  /**\n   * Generates a transaction that applies a timestamp, which could enable a\n   * pending payment to proceed.\n   */\n  static applyTimestamp(\n    from: PublicKey,\n    program: PublicKey,\n    to: PublicKey,\n    when: Date,\n  ): Transaction {\n    const whenData = serializeDate(when);\n    const data = Buffer.alloc(4 + whenData.length);\n\n    data.writeUInt32LE(1, 0); // ApplyTimestamp instruction\n    whenData.copy(data, 4);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isWritable: true},\n        {pubkey: program, isSigner: false, isWritable: true},\n        {pubkey: to, isSigner: false, isWritable: true},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generates a transaction that applies a signature, which could enable a\n   * pending payment to proceed.\n   */\n  static applySignature(\n    from: PublicKey,\n    program: PublicKey,\n    to: PublicKey,\n  ): Transaction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // ApplySignature instruction\n      },\n      data,\n    );\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: from, isSigner: true, isWritable: true},\n        {pubkey: program, isSigner: false, isWritable: true},\n        {pubkey: to, isSigner: false, isWritable: true},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n}\n","// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\nimport {encodeData} from './instruction';\nimport type {InstructionType} from './instruction';\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\nimport {SystemProgram} from './system-program';\nimport {\n  SYSVAR_CLOCK_PUBKEY,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_STAKE_HISTORY_PUBKEY,\n} from './sysvar';\nimport {Transaction, TransactionInstruction} from './transaction';\nimport type {TransactionInstructionCtorFields} from './transaction';\n\nexport const STAKE_CONFIG_ID = new PublicKey(\n  'StakeConfig11111111111111111111111111111111',\n);\n\nexport class Authorized {\n  staker: PublicKey;\n  withdrawer: PublicKey;\n\n  /**\n   * Create a new Authorized object\n   */\n  constructor(staker: PublicKey, withdrawer: PublicKey) {\n    this.staker = staker;\n    this.withdrawer = withdrawer;\n  }\n}\n\nexport class Lockup {\n  unixTimestamp: number;\n  epoch: number;\n  custodian: PublicKey;\n\n  /**\n   * Create a new Lockup object\n   */\n  constructor(unixTimestamp: number, epoch: number, custodian: PublicKey) {\n    this.unixTimestamp = unixTimestamp;\n    this.epoch = epoch;\n    this.custodian = custodian;\n  }\n}\n\n/**\n * Stake Instruction class\n */\nexport class StakeInstruction extends TransactionInstruction {\n  /**\n   * Type of StakeInstruction\n   */\n  type: InstructionType;\n\n  constructor(opts?: TransactionInstructionCtorFields, type?: InstructionType) {\n    if (\n      opts &&\n      opts.programId &&\n      !opts.programId.equals(StakeProgram.programId)\n    ) {\n      throw new Error('programId incorrect; not a StakeInstruction');\n    }\n    super(opts);\n    if (type) {\n      this.type = type;\n    }\n  }\n\n  static from(instruction: TransactionInstruction): StakeInstruction {\n    if (!instruction.programId.equals(StakeProgram.programId)) {\n      throw new Error('programId incorrect; not StakeProgram');\n    }\n\n    const instructionTypeLayout = BufferLayout.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const t in StakeInstructionLayout) {\n      if (StakeInstructionLayout[t].index == typeIndex) {\n        type = StakeInstructionLayout[t];\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a StakeInstruction');\n    }\n    return new StakeInstruction(\n      {\n        keys: instruction.keys,\n        programId: instruction.programId,\n        data: instruction.data,\n      },\n      type,\n    );\n  }\n}\n\n/**\n * An enumeration of valid StakeInstructionTypes\n */\nexport const StakeInstructionLayout = Object.freeze({\n  Initialize: {\n    index: 0,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.authorized(),\n      Layout.lockup(),\n    ]),\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      Layout.publicKey('newAuthorized'),\n      BufferLayout.u32('stakeAuthorizationType'),\n    ]),\n  },\n  DelegateStake: {\n    index: 2,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')]),\n  },\n  Split: {\n    index: 3,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  Withdraw: {\n    index: 4,\n    layout: BufferLayout.struct([\n      BufferLayout.u32('instruction'),\n      BufferLayout.ns64('lamports'),\n    ]),\n  },\n  Deactivate: {\n    index: 5,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')]),\n  },\n});\n\n/**\n * @typedef {Object} StakeAuthorizationType\n * @property (index} The Stake Authorization index (from solana-stake-program)\n */\nexport type StakeAuthorizationType = {|\n  index: number,\n|};\n\n/**\n * An enumeration of valid StakeInstructionTypes\n */\nexport const StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0,\n  },\n  Withdrawer: {\n    index: 1,\n  },\n});\n\n/**\n * Factory class for transactions to interact with the Stake program\n */\nexport class StakeProgram {\n  /**\n   * Public key that identifies the Stake program\n   */\n  static get programId(): PublicKey {\n    return new PublicKey('Stake11111111111111111111111111111111111111');\n  }\n\n  /**\n   * Max space of a Stake account\n   */\n  static get space(): number {\n    return 4008;\n  }\n\n  /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */\n  static initialize(\n    stakeAccount: PublicKey,\n    authorized: Authorized,\n    lockup: Lockup,\n  ): TransactionInstruction {\n    const type = StakeInstructionLayout.Initialize;\n    const data = encodeData(type, {\n      authorized: {\n        staker: authorized.staker.toBuffer(),\n        withdrawer: authorized.withdrawer.toBuffer(),\n      },\n      lockup: {\n        unixTimestamp: lockup.unixTimestamp,\n        epoch: lockup.epoch,\n        custodian: lockup.custodian.toBuffer(),\n      },\n    });\n    const instructionData = {\n      keys: [\n        {pubkey: stakeAccount, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */\n  static createAccountWithSeed(\n    from: PublicKey,\n    stakeAccount: PublicKey,\n    base: PublicKey,\n    seed: string,\n    authorized: Authorized,\n    lockup: Lockup,\n    lamports: number,\n  ): Transaction {\n    let transaction = SystemProgram.createAccountWithSeed(\n      from,\n      stakeAccount,\n      base,\n      seed,\n      lamports,\n      this.space,\n      this.programId,\n    );\n\n    return transaction.add(this.initialize(stakeAccount, authorized, lockup));\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account\n   */\n  static createAccount(\n    from: PublicKey,\n    stakeAccount: PublicKey,\n    authorized: Authorized,\n    lockup: Lockup,\n    lamports: number,\n  ): Transaction {\n    let transaction = SystemProgram.createAccount(\n      from,\n      stakeAccount,\n      lamports,\n      this.space,\n      this.programId,\n    );\n\n    return transaction.add(this.initialize(stakeAccount, authorized, lockup));\n  }\n\n  /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */\n  static delegate(\n    stakeAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n    votePubkey: PublicKey,\n  ): Transaction {\n    const type = StakeInstructionLayout.DelegateStake;\n    const data = encodeData(type);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakeAccount, isSigner: false, isWritable: true},\n        {pubkey: votePubkey, isSigner: false, isWritable: false},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: STAKE_CONFIG_ID, isSigner: false, isWritable: false},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorize(\n    stakeAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n    newAuthorized: PublicKey,\n    stakeAuthorizationType: StakeAuthorizationType,\n  ): Transaction {\n    const type = StakeInstructionLayout.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: newAuthorized.toBuffer(),\n      stakeAuthorizationType: stakeAuthorizationType.index,\n    });\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakeAccount, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: true},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */\n  static split(\n    stakeAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n    lamports: number,\n    splitStakePubkey: PublicKey,\n  ): Transaction {\n    let transaction = SystemProgram.createAccount(\n      stakeAccount,\n      splitStakePubkey,\n      0,\n      this.space,\n      this.programId,\n    );\n    transaction.instructions[0].keys[0].isSigner = false;\n    const type = StakeInstructionLayout.Split;\n    const data = encodeData(type, {lamports});\n\n    return transaction.add({\n      keys: [\n        {pubkey: stakeAccount, isSigner: false, isWritable: true},\n        {pubkey: splitStakePubkey, isSigner: false, isWritable: true},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */\n  static withdraw(\n    stakeAccount: PublicKey,\n    withdrawerPubkey: PublicKey,\n    to: PublicKey,\n    lamports: number,\n  ): Transaction {\n    const type = StakeInstructionLayout.Withdraw;\n    const data = encodeData(type, {lamports});\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakeAccount, isSigner: false, isWritable: true},\n        {pubkey: to, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false,\n        },\n        {pubkey: withdrawerPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n\n  /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */\n  static deactivate(\n    stakeAccount: PublicKey,\n    authorizedPubkey: PublicKey,\n  ): Transaction {\n    const type = StakeInstructionLayout.Deactivate;\n    const data = encodeData(type);\n\n    return new Transaction().add({\n      keys: [\n        {pubkey: stakeAccount, isSigner: false, isWritable: true},\n        {pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false},\n        {pubkey: authorizedPubkey, isSigner: true, isWritable: false},\n      ],\n      programId: this.programId,\n      data,\n    });\n  }\n}\n","// @flow\n\nimport {struct} from 'superstruct';\n\nimport * as Layout from './layout';\nimport * as shortvec from './util/shortvec-encoding';\nimport {PublicKey} from './publickey';\n\nexport const VALIDATOR_INFO_KEY = new PublicKey(\n  'Va1idator1nfo111111111111111111111111111111',\n);\n\n/**\n * @private\n */\ntype ConfigKey = {|\n  publicKey: PublicKey,\n  isSigner: boolean,\n|};\n\n/**\n * Info used to identity validators.\n *\n * @typedef {Object} Info\n * @property {string} name validator name\n * @property {?string} website optional, validator website\n * @property {?string} details optional, extra information the validator chose to share\n * @property {?string} keybaseUsername optional, used to identify validators on keybase.io\n */\nexport type Info = {|\n  name: string,\n  website?: string,\n  details?: string,\n  keybaseUsername?: string,\n|};\n\nconst InfoString = struct({\n  name: 'string',\n  website: 'string?',\n  details: 'string?',\n  keybaseUsername: 'string?',\n});\n\n/**\n * ValidatorInfo class\n */\nexport class ValidatorInfo {\n  /**\n   * validator public key\n   */\n  key: PublicKey;\n  /**\n   * validator information\n   */\n  info: Info;\n\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  constructor(key: PublicKey, info: Info) {\n    this.key = key;\n    this.info = info;\n  }\n\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n  static fromConfigData(\n    buffer: Buffer | Uint8Array | Array<number>,\n  ): ValidatorInfo | null {\n    const PUBKEY_LENGTH = 32;\n\n    let byteArray = [...buffer];\n    const configKeyCount = shortvec.decodeLength(byteArray);\n    if (configKeyCount !== 2) return null;\n\n    const configKeys: Array<ConfigKey> = [];\n    for (let i = 0; i < 2; i++) {\n      const publicKey = new PublicKey(byteArray.slice(0, PUBKEY_LENGTH));\n      byteArray = byteArray.slice(PUBKEY_LENGTH);\n      const isSigner = byteArray.slice(0, 1)[0] === 1;\n      byteArray = byteArray.slice(1);\n      configKeys.push({publicKey, isSigner});\n    }\n\n    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n      if (configKeys[1].isSigner) {\n        const rawInfo = Layout.rustString().decode(Buffer.from(byteArray));\n        const info = InfoString(JSON.parse(rawInfo));\n        return new ValidatorInfo(configKeys[1].publicKey, info);\n      }\n    }\n\n    return null;\n  }\n}\n","// @flow\nimport * as BufferLayout from 'buffer-layout';\n\nimport * as Layout from './layout';\nimport {PublicKey} from './publickey';\nimport {toBuffer} from './util/to-buffer';\n\nexport const VOTE_PROGRAM_ID = new PublicKey(\n  'Vote111111111111111111111111111111111111111',\n);\n\nexport type Lockout = {|\n  slot: number,\n  confirmationCount: number,\n|};\n\n/**\n * History of how many credits earned by the end of each epoch\n */\nexport type EpochCredits = {|\n  epoch: number,\n  credits: number,\n  prevCredits: number,\n|};\n\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @private\n */\nconst VoteAccountLayout = BufferLayout.struct([\n  Layout.publicKey('nodePubkey'),\n  Layout.publicKey('authorizedVoterPubkey'),\n  Layout.publicKey('authorizedWithdrawerPubkey'),\n  BufferLayout.u8('commission'),\n  BufferLayout.nu64(), // votes.length\n  BufferLayout.seq(\n    BufferLayout.struct([\n      BufferLayout.nu64('slot'),\n      BufferLayout.u32('confirmationCount'),\n    ]),\n    BufferLayout.offset(BufferLayout.u32(), -8),\n    'votes',\n  ),\n  BufferLayout.u8('rootSlotValid'),\n  BufferLayout.nu64('rootSlot'),\n  BufferLayout.nu64('epoch'),\n  BufferLayout.nu64('credits'),\n  BufferLayout.nu64('lastEpochCredits'),\n  BufferLayout.nu64(), // epochCredits.length\n  BufferLayout.seq(\n    BufferLayout.struct([\n      BufferLayout.nu64('epoch'),\n      BufferLayout.nu64('credits'),\n      BufferLayout.nu64('prevCredits'),\n    ]),\n    BufferLayout.offset(BufferLayout.u32(), -8),\n    'epochCredits',\n  ),\n]);\n\n/**\n * VoteAccount class\n */\nexport class VoteAccount {\n  nodePubkey: PublicKey;\n  authorizedVoterPubkey: PublicKey;\n  authorizedWithdrawerPubkey: PublicKey;\n  commission: number;\n  votes: Array<Lockout>;\n  rootSlot: number | null;\n  epoch: number;\n  credits: number;\n  lastEpochCredits: number;\n  epochCredits: Array<EpochCredits>;\n\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n  static fromAccountData(\n    buffer: Buffer | Uint8Array | Array<number>,\n  ): VoteAccount {\n    const va = VoteAccountLayout.decode(toBuffer(buffer), 0);\n    va.nodePubkey = new PublicKey(va.nodePubkey);\n    va.authorizedVoterPubkey = new PublicKey(va.authorizedVoterPubkey);\n    va.authorizedWithdrawerPubkey = new PublicKey(\n      va.authorizedWithdrawerPubkey,\n    );\n    if (!va.rootSlotValid) {\n      va.rootSlot = null;\n    }\n    return va;\n  }\n}\n","// @flow\n\nimport {Connection} from '../connection';\nimport type {Commitment} from '../connection';\nimport {sleep} from './sleep';\nimport type {TransactionSignature} from '../transaction';\nimport {DEFAULT_TICKS_PER_SLOT, NUM_TICKS_PER_SECOND} from '../timing';\n\n/**\n * Sign, send and confirm a raw transaction\n */\nexport async function sendAndConfirmRawTransaction(\n  connection: Connection,\n  rawTransaction: Buffer,\n  commitment: ?Commitment,\n): Promise<TransactionSignature> {\n  const start = Date.now();\n  let signature = await connection.sendRawTransaction(rawTransaction);\n\n  // Wait up to a couple slots for a confirmation\n  let status = null;\n  let statusRetries = 6;\n  for (;;) {\n    status = await connection.getSignatureStatus(signature, commitment);\n    if (status) {\n      break;\n    }\n\n    // Sleep for approximately half a slot\n    await sleep((500 * DEFAULT_TICKS_PER_SLOT) / NUM_TICKS_PER_SECOND);\n\n    if (--statusRetries <= 0) {\n      const duration = (Date.now() - start) / 1000;\n      throw new Error(\n        `Raw Transaction '${signature}' was not confirmed in ${duration.toFixed(\n          2,\n        )} seconds (${JSON.stringify(status)})`,\n      );\n    }\n  }\n\n  if (status && 'Ok' in status) {\n    return signature;\n  }\n\n  throw new Error(\n    `Raw transaction ${signature} failed (${JSON.stringify(status)})`,\n  );\n}\n","//@flow\n\nimport {testnetDefaultChannel} from '../../package.json';\n\n/**\n * @private\n */\nconst endpoint = {\n  http: {\n    edge: 'http://edge.testnet.solana.com:8899',\n    beta: 'http://beta.testnet.solana.com:8899',\n    stable: 'http://testnet.solana.com:8899',\n  },\n  https: {\n    edge: 'https://edge.testnet.solana.com:8443',\n    beta: 'https://beta.testnet.solana.com:8443',\n    stable: 'https://testnet.solana.com:8443',\n  },\n};\n\n/**\n * Retrieves the RPC endpoint URL for the specified testnet release\n * channel\n */\nexport function testnetChannelEndpoint(\n  channel?: string,\n  tls?: boolean,\n): string {\n  const key = tls === false ? 'http' : 'https';\n\n  if (!channel) {\n    return endpoint[key][testnetDefaultChannel];\n  }\n\n  const url = endpoint[key][channel];\n  if (!url) {\n    throw new Error(`Unknown ${key} channel: ${channel}`);\n  }\n  return url;\n}\n","// @flow\nexport {Account} from './account';\nexport {BpfLoader} from './bpf-loader';\nexport {BudgetProgram} from './budget-program';\nexport {Connection} from './connection';\nexport {Loader} from './loader';\nexport {NonceAccount} from './nonce-account';\nexport {PublicKey} from './publickey';\nexport {\n  STAKE_CONFIG_ID,\n  Authorized,\n  Lockup,\n  StakeAuthorizationLayout,\n  StakeInstruction,\n  StakeInstructionLayout,\n  StakeProgram,\n} from './stake-program';\nexport {SystemInstruction, SystemProgram} from './system-program';\nexport {Transaction, TransactionInstruction} from './transaction';\nexport {VALIDATOR_INFO_KEY, ValidatorInfo} from './validator-info';\nexport {VOTE_PROGRAM_ID, VoteAccount} from './vote-account';\nexport {\n  SYSVAR_CLOCK_PUBKEY,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_REWARDS_PUBKEY,\n  SYSVAR_STAKE_HISTORY_PUBKEY,\n} from './sysvar';\nexport {\n  sendAndConfirmTransaction,\n  sendAndConfirmRecentTransaction,\n} from './util/send-and-confirm-transaction';\nexport {sendAndConfirmRawTransaction} from './util/send-and-confirm-raw-transaction';\nexport {testnetChannelEndpoint} from './util/testnet';\n\n// There are 1-billion lamports in one SOL\nexport const LAMPORTS_PER_SOL = 1000000000;\n"]},"metadata":{},"sourceType":"module"}