{"ast":null,"code":"import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport * as bs58 from \"bs58\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\n\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\n\nexport class InstructionCoder {\n  constructor(idl) {\n    this.idl = idl;\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    const sighashLayouts = new Map();\n    idl.instructions.forEach(ix => {\n      const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);\n      sighashLayouts.set(bs58.encode(sh), {\n        layout: this.ixLayout.get(ix.name),\n        name: ix.name\n      });\n    });\n\n    if (idl.state) {\n      idl.state.methods.map(ix => {\n        const sh = sighash(SIGHASH_STATE_NAMESPACE, ix.name);\n        sighashLayouts.set(bs58.encode(sh), {\n          layout: this.ixLayout.get(ix.name),\n          name: ix.name\n        });\n      });\n    }\n\n    this.sighashLayouts = sighashLayouts;\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  encode(ixName, ix) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n  /**\n   * Encodes a program state instruction.\n   */\n\n\n  encodeState(ixName, ix) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  _encode(nameSpace, ixName, ix) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const methodName = camelCase(ixName);\n    const layout = this.ixLayout.get(methodName);\n\n    if (!layout) {\n      throw new Error(`Unknown method: ${methodName}`);\n    }\n\n    const len = layout.encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  static parseIxLayout(idl) {\n    const stateMethods = idl.state ? idl.state.methods : [];\n    const ixLayouts = stateMethods.map(m => {\n      let fieldLayouts = m.args.map(arg => {\n        var _a, _b;\n\n        return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n      });\n      const name = camelCase(m.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }).concat(idl.instructions.map(ix => {\n      let fieldLayouts = ix.args.map(arg => {\n        var _a, _b;\n\n        return IdlCoder.fieldLayout(arg, Array.from([...((_a = idl.accounts) !== null && _a !== void 0 ? _a : []), ...((_b = idl.types) !== null && _b !== void 0 ? _b : [])]));\n      });\n      const name = camelCase(ix.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    })); // @ts-ignore\n\n    return new Map(ixLayouts);\n  }\n  /**\n   * Dewcodes a program instruction.\n   */\n\n\n  decode(ix) {\n    let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"hex\";\n\n    if (typeof ix === \"string\") {\n      ix = encoding === \"hex\" ? Buffer.from(ix, \"hex\") : bs58.decode(ix);\n    }\n\n    let sighash = bs58.encode(ix.slice(0, 8));\n    let data = ix.slice(8);\n    const decoder = this.sighashLayouts.get(sighash);\n\n    if (!decoder) {\n      return null;\n    }\n\n    return {\n      data: decoder.layout.decode(data),\n      name: decoder.name\n    };\n  }\n  /**\n   * Returns a formatted table of all the fields in the given instruction data.\n   */\n\n\n  format(ix, accountMetas) {\n    return InstructionFormatter.format(ix, accountMetas, this.idl);\n  }\n\n}\n\nclass InstructionFormatter {\n  static format(ix, accountMetas, idl) {\n    const idlIx = idl.instructions.filter(i => ix.name === i.name)[0];\n\n    if (idlIx === undefined) {\n      console.error(\"Invalid instruction given\");\n      return null;\n    }\n\n    const args = idlIx.args.map(idlField => {\n      return {\n        name: idlField.name,\n        type: InstructionFormatter.formatIdlType(idlField.type),\n        data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)\n      };\n    });\n    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n    const accounts = accountMetas.map((meta, idx) => {\n      if (idx < flatIdlAccounts.length) {\n        return {\n          name: flatIdlAccounts[idx].name,\n          ...meta\n        };\n      } // \"Remaining accounts\" are unnamed in Anchor.\n      else {\n        return {\n          name: undefined,\n          ...meta\n        };\n      }\n    });\n    return {\n      args,\n      accounts\n    };\n  }\n\n  static formatIdlType(idlType) {\n    if (typeof idlType === \"string\") {\n      return idlType;\n    }\n\n    if (\"vec\" in idlType) {\n      return `Vec<${this.formatIdlType(idlType.vec)}>`;\n    }\n\n    if (\"option\" in idlType) {\n      return `Option<${this.formatIdlType(idlType.option)}>`;\n    }\n\n    if (\"defined\" in idlType) {\n      return idlType.defined;\n    }\n\n    if (\"array\" in idlType) {\n      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n    }\n\n    throw new Error(`Unknown IDL type: ${idlType}`);\n  }\n\n  static formatIdlData(idlField, data, types) {\n    if (typeof idlField.type === \"string\") {\n      return data.toString();\n    } // @ts-ignore\n\n\n    if (idlField.type.vec) {\n      // @ts-ignore\n      return \"[\" + data // @ts-ignore\n      .map(d => this.formatIdlData( // @ts-ignore\n      {\n        name: \"\",\n        type: idlField.type.vec\n      }, d)).join(\", \") + \"]\";\n    } // @ts-ignore\n\n\n    if (idlField.type.option) {\n      // @ts-ignore\n      return data === null ? \"null\" : this.formatIdlData( // @ts-ignore\n      {\n        name: \"\",\n        type: idlField.type.option\n      }, data);\n    } // @ts-ignore\n\n\n    if (idlField.type.defined) {\n      if (types === undefined) {\n        throw new Error(\"User defined types not provided\");\n      } // @ts-ignore\n\n\n      const filtered = types.filter(t => t.name === idlField.type.defined);\n\n      if (filtered.length !== 1) {\n        // @ts-ignore\n        throw new Error(`Type not found: ${idlField.type.defined}`);\n      }\n\n      return InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);\n    }\n\n    return \"unknown\";\n  }\n\n  static formatIdlDataDefined(typeDef, data, types) {\n    if (typeDef.type.kind === \"struct\") {\n      const struct = typeDef.type;\n      const fields = Object.keys(data).map(k => {\n        const f = struct.fields.filter(f => f.name === k)[0];\n\n        if (f === undefined) {\n          throw new Error(\"Unable to find type\");\n        }\n\n        return k + \": \" + InstructionFormatter.formatIdlData(f, data[k], types);\n      }).join(\", \");\n      return \"{ \" + fields + \" }\";\n    } else {\n      if (typeDef.type.variants.length === 0) {\n        return \"{}\";\n      } // Struct enum.\n\n\n      if (typeDef.type.variants[0].name) {\n        const variants = typeDef.type.variants;\n        const variant = Object.keys(data)[0];\n        const enumType = data[variant];\n        const namedFields = Object.keys(enumType).map(f => {\n          var _a;\n\n          const fieldData = enumType[f];\n          const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.filter(v => v.name === f)[0];\n\n          if (idlField === undefined) {\n            throw new Error(\"Unable to find variant\");\n          }\n\n          return f + \": \" + InstructionFormatter.formatIdlData(idlField, fieldData, types);\n        }).join(\", \");\n        const variantName = camelCase(variant, {\n          pascalCase: true\n        });\n\n        if (namedFields.length === 0) {\n          return variantName;\n        }\n\n        return `${variantName} { ${namedFields} }`;\n      } // Tuple enum.\n      else {\n        // TODO.\n        return \"Tuple formatting not yet implemented\";\n      }\n    }\n  }\n\n  static flattenIdlAccounts(accounts, prefix) {\n    // @ts-ignore\n    return accounts.map(account => {\n      const accName = sentenceCase(account.name); // @ts-ignore\n\n      if (account.accounts) {\n        const newPrefix = prefix ? `${prefix} > ${accName}` : accName; // @ts-ignore\n\n        return InstructionFormatter.flattenIdlAccounts( // @ts-ignore\n        account.accounts, newPrefix);\n      } else {\n        return { ...account,\n          name: prefix ? `${prefix} > ${accName}` : accName\n        };\n      }\n    }).flat();\n  }\n\n}\n\nfunction sentenceCase(field) {\n  const result = field.replace(/([A-Z])/g, \" $1\");\n  return result.charAt(0).toUpperCase() + result.slice(1);\n}","map":{"version":3,"mappings":"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","names":["camelCase","borsh","bs58","IdlCoder","sighash","SIGHASH_STATE_NAMESPACE","SIGHASH_GLOBAL_NAMESPACE","InstructionCoder","constructor","idl","ixLayout","parseIxLayout","sighashLayouts","Map","instructions","forEach","ix","sh","name","set","encode","layout","get","state","methods","map","ixName","_encode","encodeState","nameSpace","buffer","Buffer","alloc","methodName","Error","len","data","slice","concat","stateMethods","ixLayouts","m","fieldLayouts","args","arg","fieldLayout","Array","from","accounts","_a","types","_b","struct","decode","encoding","decoder","format","accountMetas","InstructionFormatter","idlIx","filter","i","undefined","console","error","idlField","type","formatIdlType","formatIdlData","flatIdlAccounts","flattenIdlAccounts","meta","idx","length","idlType","vec","option","defined","array","toString","d","join","filtered","t","formatIdlDataDefined","typeDef","kind","fields","Object","keys","k","f","variants","variant","enumType","namedFields","fieldData","v","variantName","pascalCase","prefix","account","accName","sentenceCase","newPrefix","flat","field","result","replace","charAt","toUpperCase"],"sourceRoot":"","sources":["../../../src/coder/instruction.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}