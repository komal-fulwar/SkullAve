{"ast":null,"code":"var compoundSubject = require('compound-subject');\n\nvar isEmpty = require('101/is-empty');\n\nvar isString = require('101/is-string');\n\nvar isFunction = require('101/is-function');\n\nvar assertType = require('./assert-type');\n\nvar isClass = require('./is-class.js');\n\nvar validate = require('./validate.js');\n\nvar startsWithVowel = require('./starts-with-vowel.js');\n\nmodule.exports = multiValidate;\n/**\n * validate an argument against multiple validators\n * @param  {string} key argument name\n * @param  {*} arg  argument value\n * @param  {array} validators array of validators\n */\n\nfunction multiValidate(key, arg, validators) {\n  var errMessage = '\"' + key + '\" must be ';\n  assertType(!isEmpty(validators), '\"validators\" cannot be empty');\n  var typeArr = validators.map(function (validator) {\n    if (isString(validator)) {\n      return validator;\n    } else if (isClass(validator)) {\n      return '\"' + validator.name + '\"';\n    } else if (isFunction(validator)) {\n      return 'pass \"' + (validator.name || 'anonymous') + '\"';\n    } else {\n      throw new TypeError('\"validators\" must be an array containing only strings, classes, or functions');\n    }\n  });\n  var typeStr = compoundSubject(typeArr).endWith('or').make();\n  var article = startsWithVowel(typeStr) ? 'an' : 'a';\n  errMessage += article + ' ' + typeStr;\n  var passedAnyValidator = validators.some(function (validator) {\n    try {\n      validate(key, arg, validator);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  });\n\n  if (!passedAnyValidator) {\n    throw new TypeError(errMessage);\n  }\n}","map":{"version":3,"sources":["/Users/komalfulwar/Documents/GitHub/SkullAve/node_modules/assert-args/lib/multi-validate.js"],"names":["compoundSubject","require","isEmpty","isString","isFunction","assertType","isClass","validate","startsWithVowel","module","exports","multiValidate","key","arg","validators","errMessage","typeArr","map","validator","name","TypeError","typeStr","endWith","make","article","passedAnyValidator","some","e"],"mappings":"AAAA,IAAIA,eAAe,GAAGC,OAAO,CAAC,kBAAD,CAA7B;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,cAAD,CAArB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,iBAAD,CAAxB;;AAEA,IAAII,UAAU,GAAGJ,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIK,OAAO,GAAGL,OAAO,CAAC,eAAD,CAArB;;AACA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAIO,eAAe,GAAGP,OAAO,CAAC,wBAAD,CAA7B;;AAEAQ,MAAM,CAACC,OAAP,GAAiBC,aAAjB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,aAAT,CAAwBC,GAAxB,EAA6BC,GAA7B,EAAkCC,UAAlC,EAA8C;AAC5C,MAAIC,UAAU,GAAG,MAAMH,GAAN,GAAY,YAA7B;AACAP,EAAAA,UAAU,CAAC,CAACH,OAAO,CAACY,UAAD,CAAT,EAAuB,8BAAvB,CAAV;AACA,MAAIE,OAAO,GAAGF,UAAU,CAACG,GAAX,CAAe,UAAUC,SAAV,EAAqB;AAChD,QAAIf,QAAQ,CAACe,SAAD,CAAZ,EAAyB;AACvB,aAAOA,SAAP;AACD,KAFD,MAEO,IAAIZ,OAAO,CAACY,SAAD,CAAX,EAAwB;AAC7B,aAAO,MAAMA,SAAS,CAACC,IAAhB,GAAuB,GAA9B;AACD,KAFM,MAEA,IAAIf,UAAU,CAACc,SAAD,CAAd,EAA2B;AAChC,aAAO,YAAYA,SAAS,CAACC,IAAV,IAAkB,WAA9B,IAA6C,GAApD;AACD,KAFM,MAEA;AACL,YAAM,IAAIC,SAAJ,CAAc,8EAAd,CAAN;AACD;AACF,GAVa,CAAd;AAWA,MAAIC,OAAO,GAAGrB,eAAe,CAACgB,OAAD,CAAf,CACXM,OADW,CACH,IADG,EAEXC,IAFW,EAAd;AAGA,MAAIC,OAAO,GAAGhB,eAAe,CAACa,OAAD,CAAf,GAA2B,IAA3B,GAAkC,GAAhD;AAEAN,EAAAA,UAAU,IAAIS,OAAO,GAAG,GAAV,GAAgBH,OAA9B;AAEA,MAAII,kBAAkB,GAAGX,UAAU,CAACY,IAAX,CAAgB,UAAUR,SAAV,EAAqB;AAC5D,QAAI;AACFX,MAAAA,QAAQ,CAACK,GAAD,EAAMC,GAAN,EAAWK,SAAX,CAAR;AACA,aAAO,IAAP;AACD,KAHD,CAGE,OAAOS,CAAP,EAAU;AACV,aAAO,KAAP;AACD;AACF,GAPwB,CAAzB;;AASA,MAAI,CAACF,kBAAL,EAAyB;AACvB,UAAM,IAAIL,SAAJ,CAAcL,UAAd,CAAN;AACD;AACF","sourcesContent":["var compoundSubject = require('compound-subject')\nvar isEmpty = require('101/is-empty')\nvar isString = require('101/is-string')\nvar isFunction = require('101/is-function')\n\nvar assertType = require('./assert-type')\nvar isClass = require('./is-class.js')\nvar validate = require('./validate.js')\nvar startsWithVowel = require('./starts-with-vowel.js')\n\nmodule.exports = multiValidate\n/**\n * validate an argument against multiple validators\n * @param  {string} key argument name\n * @param  {*} arg  argument value\n * @param  {array} validators array of validators\n */\nfunction multiValidate (key, arg, validators) {\n  var errMessage = '\"' + key + '\" must be '\n  assertType(!isEmpty(validators), '\"validators\" cannot be empty')\n  var typeArr = validators.map(function (validator) {\n    if (isString(validator)) {\n      return validator\n    } else if (isClass(validator)) {\n      return '\"' + validator.name + '\"'\n    } else if (isFunction(validator)) {\n      return 'pass \"' + (validator.name || 'anonymous') + '\"'\n    } else {\n      throw new TypeError('\"validators\" must be an array containing only strings, classes, or functions')\n    }\n  })\n  var typeStr = compoundSubject(typeArr)\n    .endWith('or')\n    .make()\n  var article = startsWithVowel(typeStr) ? 'an' : 'a'\n\n  errMessage += article + ' ' + typeStr\n\n  var passedAnyValidator = validators.some(function (validator) {\n    try {\n      validate(key, arg, validator)\n      return true\n    } catch (e) {\n      return false\n    }\n  })\n\n  if (!passedAnyValidator) {\n    throw new TypeError(errMessage)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}